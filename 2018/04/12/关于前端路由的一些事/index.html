<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>关于前端路由的一些事 | swing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="##关于前端路由的一些事 路由实现一、hashchange回忆基础知识： 1、hash即URL中”#”字符后面的部分。(location.hash 看下) 　　①使用浏览器访问网页时，如果网页URL中带有hash，页面就会定位到id（或name）与hash值一样的元素的位置； 　　②hash还有另一个特点，它的改变不会导致页面重新加载； 　　③hash值浏览器是不会随请求发送到服务器端的； 　　④">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="关于前端路由的一些事">
<meta property="og:url" content="http://swingboy.github.io/2018/04/12/关于前端路由的一些事/index.html">
<meta property="og:site_name" content="swing">
<meta property="og:description" content="##关于前端路由的一些事 路由实现一、hashchange回忆基础知识： 1、hash即URL中”#”字符后面的部分。(location.hash 看下) 　　①使用浏览器访问网页时，如果网页URL中带有hash，页面就会定位到id（或name）与hash值一样的元素的位置； 　　②hash还有另一个特点，它的改变不会导致页面重新加载； 　　③hash值浏览器是不会随请求发送到服务器端的； 　　④">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://swingboy.github.io/2018/04/12/关于前端路由的一些事/imgs/pipeiguize.png">
<meta property="og:image" content="http://swingboy.github.io/2018/04/12/关于前端路由的一些事/imgs/match.png">
<meta property="og:updated_time" content="2019-11-23T14:29:26.793Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于前端路由的一些事">
<meta name="twitter:description" content="##关于前端路由的一些事 路由实现一、hashchange回忆基础知识： 1、hash即URL中”#”字符后面的部分。(location.hash 看下) 　　①使用浏览器访问网页时，如果网页URL中带有hash，页面就会定位到id（或name）与hash值一样的元素的位置； 　　②hash还有另一个特点，它的改变不会导致页面重新加载； 　　③hash值浏览器是不会随请求发送到服务器端的； 　　④">
<meta name="twitter:image" content="http://swingboy.github.io/2018/04/12/关于前端路由的一些事/imgs/pipeiguize.png">
  
    <link rel="alternate" href="/atom.xml" title="swing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://swingboy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-关于前端路由的一些事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/关于前端路由的一些事/" class="article-date">
  <time datetime="2018-04-12T12:18:56.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      关于前端路由的一些事
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##关于前端路由的一些事</p>
<h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><h4 id="一、hashchange"><a href="#一、hashchange" class="headerlink" title="一、hashchange"></a>一、hashchange</h4><p>回忆基础知识：<br></p>
<p>1、hash即URL中”#”字符后面的部分。(location.hash 看下)</p>
<p>　　①使用浏览器访问网页时，如果网页URL中带有hash，页面就会定位到id（或name）与hash值一样的元素的位置；</p>
<p>　　②hash还有另一个特点，它的改变不会导致页面重新加载；</p>
<p>　　③hash值浏览器是不会随请求发送到服务器端的；</p>
<p>　　④通过window.location.hash属性获取和设置hash值。</p>
<blockquote>
<p>window.location.hash值的变化会直接反应到浏览器地址栏（#后面的部分会发生变化），同时，浏览器地址栏hash值的变化也会触发window.location.hash值的变化，从而触发onhashchange事件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//实现实例</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">            &lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;/profile&quot;&gt;个人中心&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;/articles&quot;&gt;文章列表&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        const $ = (selector) =&gt; document.querySelector(selector);</span><br><span class="line">        const routeMap = &#123;</span><br><span class="line">            &apos;/&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = &apos;&lt;div&gt;the Home Page&lt;/div&gt;&apos;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;/profile&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = &apos;&lt;div&gt;the Profile Page&lt;/div&gt;&apos;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;/articles&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = `&lt;div&gt;</span><br><span class="line">                    &lt;p&gt;the Article Page&lt;/p&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;文章1&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;文章2&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;文章3&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/div&gt;`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        class Route &#123;</span><br><span class="line">            constructor(routeMap) &#123;</span><br><span class="line">                this.routeMap = routeMap;</span><br><span class="line">                this._bindPopState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            init(path) &#123;</span><br><span class="line">                path = Route.correctPath(path);</span><br><span class="line">                history.replaceState(&#123; path: path &#125;, &apos;&apos;, path);</span><br><span class="line">                this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            go(path) &#123;</span><br><span class="line">                path = Route.correctPath(path);</span><br><span class="line">                history.pushState(&#123; path: path &#125;, &apos;&apos;, path);</span><br><span class="line">                this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _bindPopState() &#123;</span><br><span class="line">                window.addEventListener(&apos;popstate&apos;, (e) =&gt; &#123;</span><br><span class="line">                    const path = e.state &amp;&amp; e.state.path;</span><br><span class="line">                    this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            static correctPath(path) &#123;</span><br><span class="line">                if(path !== &apos;/&apos; &amp;&amp; path.slice(-1) === &apos;/&apos;)&#123;</span><br><span class="line">                    path = path.match(/(.+)\/$/)[1];</span><br><span class="line">                &#125;</span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const router = new Route(routeMap);</span><br><span class="line">        router.init(location.pathname);</span><br><span class="line">        </span><br><span class="line">        $(&apos;.menu&apos;).addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">            if (e.target.tagName === &apos;A&apos;) &#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">                router.go(e.target.getAttribute(&apos;href&apos;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2、hashchange事件（IE8已支持该事件）</p>
<p>　　①当URL的片段标识符更改时，将触发hashchange事件（跟在#符号后面的URL部分，包括#符号）</p>
<p>　　②hashchange事件触发时，事件对象会有hash改变前的URL（oldURL）和hash改变后的URL（newURL）两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;hashchange&apos;, function(e) &#123;</span><br><span class="line">	console.log(e.oldURL); </span><br><span class="line">	console.log(e.newURL);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>
<h4 id="二、通过history"><a href="#二、通过history" class="headerlink" title="二、通过history"></a>二、通过history</h4><p>回忆:<br></p>
<p>history是HTML5新增的一个api。</p>
<blockquote>
<p>其中包括2个方法：<br><br>history.pushState() <br><br>history.replaceState() <br><br>1个事件：window.onpopstate。</p>
</blockquote>
<p>####说明:</p>
<h5 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h5><p>函数向浏览器的历史堆栈压入一个url为设定值的记录，并改变历史堆栈的当前指针至栈顶。</p>
<p>history.pushState(stateObject, title, url)，包括三个参数。</p>
<blockquote>
<p>stateObj，一个普通的js对象，可以包含任何数据，它包含在新的hsitory实体的state属性中。当用户导航到该状态时，一个popstate事件将会被触发，并且在该事件的e.state中会包含这个stateObj。</p>
</blockquote>
<blockquote>
<p>title，目前没什么用，我们可以传入一个空字符串，或者一个表示新history状态的字符串。</p>
</blockquote>
<blockquote>
<p>URL，可选参数，这将会改变浏览器当前的url，但是新的url并不会立刻加载。当时用户此时跳转到另外一个页面，然后再点击后退，该url会加载，并且触发popstate事件。</p>
</blockquote>
<p>示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;name: &apos;xwj&apos;, age: 22&#125;, &apos;&apos;, &apos;/profile&apos;);</span><br><span class="line"></span><br><span class="line">// 浏览器地址会变为http://www.example.com/profile，但并不会加载。同时history的length会加1，state会变为传入的stateObj</span><br></pre></td></tr></table></figure>
<h5 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h5><p>该接口与pushState参数相同，含义也相同。唯一的区别在于replaceState是替换浏览器历史堆栈的当前历史记录为设定的url。需要注意的是，replaceState不会改动浏览器历史堆栈的当前指针。length不会变。</p>
<h5 id="onpopstate"><a href="#onpopstate" class="headerlink" title="onpopstate"></a>onpopstate</h5><p>该事件是window的属性。该事件会在调用浏览器的前进、后退以及执行history.forward、history.back、和history.go触发，因为这些操作有一个共性，即修改了历史堆栈的当前指针。在不改变document的前提下，一旦当前指针改变则会触发onpopstate事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;turn white&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/blue&quot;&gt;turn blue&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/green&quot;&gt;turn green&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function Router() &#123;</span><br><span class="line">        this.routes = &#123;&#125;;</span><br><span class="line">        this.currentUrl = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    Router.prototype.addRoute = function(path, callback) &#123;</span><br><span class="line">        this.routes[path] = callback || function()&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Router.prototype.refresh = function(e) &#123;</span><br><span class="line">        this.currentUrl = location.hash.slice(1) || &apos;/&apos;;</span><br><span class="line">        console.log(e.oldURL , e.newURL);</span><br><span class="line">        this.routes[this.currentUrl]();</span><br><span class="line">    &#125;;</span><br><span class="line">    Router.prototype.init = function() &#123;</span><br><span class="line">        window.addEventListener(&apos;load&apos;, this.refresh.bind(this), false);</span><br><span class="line">        window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this), false);</span><br><span class="line">    &#125;</span><br><span class="line">    window.Router = new Router();</span><br><span class="line">    window.Router.init();</span><br><span class="line">    let content = document.querySelector(&apos;div&apos;);</span><br><span class="line">    </span><br><span class="line">    function changeBgColor(color) &#123;</span><br><span class="line">        content.style.backgroundColor = color;</span><br><span class="line">    &#125;</span><br><span class="line">    Router.addRoute(&apos;/&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;white&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Router.addRoute(&apos;/blue&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;blue&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Router.addRoute(&apos;/green&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;green&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router ?"></a>React Router ?</h3><p>完整的 React 路由解决方案</p>
<h4 id="React-Router-简介相关"><a href="#React-Router-简介相关" class="headerlink" title="React Router 简介相关"></a>React Router 简介相关</h4><p>恩，是v4</p>
<blockquote>
<p>3.x 版本相比于 2.x 并没有引入任何新的特性，只是将 2.x 版本中部分废弃 API 的 warning 移除掉而已。V4版本相对V2/V3几乎完全重写了，遵循 Just Component 的 API 设计理念。</p>
</blockquote>
<blockquote>
<p>React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能。例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。</p>
</blockquote>
<p>react-router V4 分成了三个包：react-router-dom(for web)、react-router-native(for #native)、react-router(core)。react-router提供核心的路由组件与函数。其余两个则提供运行环境（即浏览器与react-native）所需的特定组件。在浏览器中，我们只需使用react-router-dom。</p>
<p>###主要组件</p>
<h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>在4.0之前版本的 API 中，Router 组件的 children 只能是 React Router 提供的各种组件，如Route、IndexRoute、Redirect等。而在 React Router 4 中，你可以将各种组件及标签放进 Router组件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 示例1</span><br><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/topics&quot;&gt;主题列表&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;/topics&quot; component=&#123;Topics&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br></pre></td></tr></table></figure>
<p>Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;：使用 HTML5 提供的 history API 来保持 UI 和 URL 的同步；</span><br><span class="line">&lt;HashRouter&gt;：使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步；</span><br><span class="line">&lt;MemoryRouter&gt;：能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写)；</span><br><span class="line">&lt;NativeRouter&gt;：为使用React Native提供路由支持；</span><br><span class="line">&lt;StaticRouter&gt;：从不会改变地址；</span><br></pre></td></tr></table></figure>
<p>TIPS：和之前的Router不一样，这里<router>组件下只允许存在一个子元素</router></p>
<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>Route组件主要的作用就是当一个location匹配路由的path时，渲染某些UI。如果不匹配，路由不会进行任何操作。<br><br></p>
<p>Route 组件有如下属性：</p>
<blockquote>
</blockquote>
<p>path（string）: 路由匹配路径。（没有path属性的Route 总是会 匹配）；<br>exact（bool）：为true时，则要求路径与location.pathname必须完全匹配；<br>strict（bool）：true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</span><br><span class="line">// 匹配 /hello</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*&quot;&gt;</span><br><span class="line">// 匹配 /files/ </span><br><span class="line">// 匹配 /files/a</span><br><span class="line">// 匹配 /files/a/b</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/path/to/file.jpg</span><br></pre></td></tr></table></figure>
<p><img src="./imgs/pipeiguize.png" alt></p>
<h5 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h5><p>path-to-regexp包用来决定route元素的path参数与当前location是否匹配。它将路径字符串编译成正则表达式，并与当前location的路径名进行匹配比较。<br>当路由地址匹配成功后，会创建一个含有以下属性的match对象：</p>
<blockquote>
<p>url ：与当前location路径名所匹配部分</p>
</blockquote>
<blockquote>
<p>path ：路由的地址</p>
</blockquote>
<blockquote>
<p>isExact ：path 是否等于 pathname</p>
</blockquote>
<blockquote>
<p>params ：从path-to-regexp获取的路径中取出的值都被包含在这个对象中</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/roster&apos;/&gt;</span><br><span class="line">// 当路径名为&apos;/&apos;时, path不匹配</span><br><span class="line">// 当路径名为&apos;/roster&apos;或&apos;/roster/2&apos;时, path匹配</span><br><span class="line">// 当你只想匹配&apos;/roster&apos;时，你需要使用&quot;exact&quot;参数</span><br><span class="line">// 则路由仅匹配&apos;/roster&apos;而不会匹配&apos;/roster/2&apos;</span><br><span class="line">&lt;Route exact path=&apos;/roster&apos;/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在匹配路由时，React Router只关注location的路径名。当URL如下时：<br>http:/xxx/xx/x/a?extra=false<br>React Router去匹配的只是’/xxx/xx/x/a’这一部分。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/news&quot; component=&#123;News&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"></span><br><span class="line">// 如果应用的地址是/,那么相应的UI会类似这个样子：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 如果应用的地址是/news,那么相应的UI就会成为这个样子：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;News/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>新版的路由为Route提供了三种渲染内容的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route component&gt;：在地址匹配的时候React的组件才会被渲染，route props也会随着一起被渲染；</span><br><span class="line">&lt;Route render&gt;：这种方式对于内联渲染和包装组件却不引起意料之外的重新挂载特别方便；</span><br><span class="line">&lt;Route children&gt;：与render属性的工作方式基本一样，除了它是不管地址匹配与否都会被调用；</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 行内渲染示例</span><br><span class="line">&lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// 包装/合成</span><br><span class="line">const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (</span><br><span class="line">  &lt;Route &#123;...rest&#125; render=&#123;props =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...props&#125;/&gt;</span><br><span class="line">    &lt;/FadeIn&gt;</span><br><span class="line">  )&#125;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;FadingRoute path=&quot;/cool&quot; component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>Route component 的优先级要比 Route render高，所以不要在同一个Route中同时使用这两个属性。</p>
<blockquote>
<p>最后：你可以把Route组件放在任意你想要路由渲染的地方</p>
</blockquote>
<p>###Link<br>重点看下组件属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to（string/object）：要跳转的路径或地址；</span><br><span class="line">replace（bool）：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Link组件示例</span><br><span class="line"></span><br><span class="line">// to为string</span><br><span class="line">&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">// to为obj</span><br><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: &apos;/courses&apos;,</span><br><span class="line">  search: &apos;?sort=name&apos;,</span><br><span class="line">  hash: &apos;#the-hash&apos;,</span><br><span class="line">  state: &#123; fromDashboard: true &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// replace </span><br><span class="line">&lt;Link to=&quot;/courses&quot; replace /&gt;</span><br></pre></td></tr></table></figure>
<p>###NavLink<br>NavLink是Link的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数，组件属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeClassName（string）：设置选中样式，默认值为 active；</span><br><span class="line">activeStyle（object）：当元素被选中时, 为此元素添加样式；</span><br><span class="line">exact（bool）：为 true 时, 只有当地址完全匹配 class 和 style 才会应用；</span><br><span class="line">strict（bool）：为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线；</span><br><span class="line">isActive（func）：判断链接是否激活的额外逻辑的功能；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// activeClassName选中时样式为selected</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeClassName=&quot;selected&quot;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 选中时样式为activeStyle的样式设置</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    color: &apos;red&apos;</span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 当event id为奇数的时候，激活链接</span><br><span class="line">const oddEvent = (match, location) =&gt; &#123;</span><br><span class="line">  if (!match) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  const eventID = parseInt(match.params.eventID)</span><br><span class="line">  return !isNaN(eventID) &amp;&amp; eventID % 2 === 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/events/123&quot;</span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event 123&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>该组件用来渲染匹配地址的第一个Route或者Redirect。那么它与使用一堆route又有什么区别呢？</p>
<p>Switch的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的 Route都会被渲染。思考下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果现在的URL是/about，那么 About,  User, 还有 NoMatch都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个 Route组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个Route来渲染。如果我们现在处于/about，我们也不希望匹配/:user（或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，如果我们处于/about，Switch将开始寻找匹配的Route。Route path=”/about”  将被匹配， Switch将停止寻找匹配并渲染About。同样，如果我们处于/michael，User将被渲染。</p>
</blockquote>
<blockquote>
<p>通过Route路由的组件，可以拿到一个match参数，这个参数是一个对象，其中包含几个数据：<br><br>isExact：刚才已经说过这个关键字，表示是为作全等匹配<br>params：path中包含的一些额外数据<br>path：Route组件path属性的值<br>url：实际url的hash值</p>
</blockquote>
<p><img src="./imgs/match.png" alt></p>
<p><br></p>
<p>###v3 与 v4 的一些区别<br>在react-router v3中，仅有一个Router 组件，需要提供 history 对象作为他的属性 (prop)。</p>
<p>此外，可以使用 routes 作为 Router 的属性 (prop) 或者作为 children 的方式来定义程序的路由结构。</p>
<p>在v4中，没有集中的路由配置。任何需要根据路由渲染内容的地方，只需渲染一个 Route 组件  router 组件只能被赋予一个子元素</p>
<p>react-router v3 提供 onEnter, onUpdate, and onLeave 方法。这些方法本质上是重写（覆盖）了 react 生命周期方法。使用 v4，你将会使用生命周期方法 通过 Route 渲染的组件，你可以使用 componentDidMount 或 componentWillMount 代替 onEnter，你可以使用 componentDidUpdate 或者 componentWillUpdate (更或者 componentWillReceiveProps) 代替 onUpdate，你可以使用 componentWillUnmount 代替 onLeave。</p>
<p>v4 的Switch组件，当 Switch 被渲染时，它仅会渲染与当前路径匹配的第一个子 Route。</p>
<p>…<br>还有很多区别</p>
<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><a href="http://www.baidu.com/link?url=iUqZ8qoki-EPuX4LUXguiJ148mao0sYdb0qjVExb8eHXw_LtydvYYEMBWSzuLuLtupDvzONFn7YlZyyKNLJ8Aq" target="_blank" rel="noopener">麻烦的按需加载</a></p>
<p><a href="https://github.com/cheft/minrouter" target="_blank" rel="noopener">minrouter</a> 用于同构javaScript Web应用程序的微型中间件路由器</p>
<p><a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">React Router 中文</a></p>
<p><a href="https://www.zcfy.cc/article/react-router-v4-the-complete-guide-mdash-sitepoint-4448.html" target="_blank" rel="noopener">React Router v4 版本 完全指北</a></p>
<p><a href="https://github.com/YutHelloWorld/Blog/issues/4" target="_blank" rel="noopener">v2 v3 到 v4 版本的迁移</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/04/12/关于前端路由的一些事/" data-id="ck9dm2p5u001k8po77mgj7da1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/06/15/前端异常监控/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          前端异常监控
        
      </div>
    </a>
  
  
    <a href="/2018/03/05/visual-dom/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">visual dom</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/技术/" style="font-size: 20px;">技术</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/29/webpack原理/">webpack原理</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpackPlugin/">webpackPlugin</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpackLoader/">webpackLoader</a>
          </li>
        
          <li>
            <a href="/2019/03/29/about-tapable/">about tapable</a>
          </li>
        
          <li>
            <a href="/2018/11/23/聊聊前端安全/">聊聊前端安全</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 火柴人<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>