<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>简单梳理react优化相关 | swing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们知道关于react可以找到很多的最佳实践。这里从代码层面和一些业务层面简单梳理下  关于优化或者是调优一定是通过减少不必要的re-render和计算来提高性能。这些优化旨在提高维护性、可读性、扩展性。  1.从代码层面：首先，可能导致react重新render的方式有三种  setState new props forceUpdate  使用shouldComponentUpdate一般情况1">
<meta name="keywords" content="技术">
<meta property="og:type" content="article">
<meta property="og:title" content="简单梳理react优化相关">
<meta property="og:url" content="http://swingboy.github.io/2020/01/24/简单梳理react优化相关/index.html">
<meta property="og:site_name" content="swing">
<meta property="og:description" content="我们知道关于react可以找到很多的最佳实践。这里从代码层面和一些业务层面简单梳理下  关于优化或者是调优一定是通过减少不必要的re-render和计算来提高性能。这些优化旨在提高维护性、可读性、扩展性。  1.从代码层面：首先，可能导致react重新render的方式有三种  setState new props forceUpdate  使用shouldComponentUpdate一般情况1">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://swingboy.github.io/imgs/简单梳理react优化相关/reactdevtool.png">
<meta property="og:image" content="http://swingboy.github.io/imgs/简单梳理react优化相关/wdyrrerender.png">
<meta property="og:updated_time" content="2020-05-18T11:06:58.274Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="简单梳理react优化相关">
<meta name="twitter:description" content="我们知道关于react可以找到很多的最佳实践。这里从代码层面和一些业务层面简单梳理下  关于优化或者是调优一定是通过减少不必要的re-render和计算来提高性能。这些优化旨在提高维护性、可读性、扩展性。  1.从代码层面：首先，可能导致react重新render的方式有三种  setState new props forceUpdate  使用shouldComponentUpdate一般情况1">
<meta name="twitter:image" content="http://swingboy.github.io/imgs/简单梳理react优化相关/reactdevtool.png">
  
    <link rel="alternate" href="/atom.xml" title="swing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://swingboy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-简单梳理react优化相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/01/24/简单梳理react优化相关/" class="article-date">
  <time datetime="2020-01-24T06:56:12.000Z" itemprop="datePublished">2020-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      简单梳理react优化相关
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道关于react可以找到很多的最佳实践。这里从代码层面和一些业务层面简单梳理下</p>
<ul>
<li>关于优化或者是调优一定是通过减少不必要的re-render和计算来提高性能。这些优化旨在提高维护性、可读性、扩展性。</li>
</ul>
<h2 id="1-从代码层面："><a href="#1-从代码层面：" class="headerlink" title="1.从代码层面："></a>1.从代码层面：</h2><p><em>首先，可能导致react重新render的方式有三种</em></p>
<ul>
<li>setState</li>
<li>new props</li>
<li>forceUpdate</li>
</ul>
<h3 id="使用shouldComponentUpdate"><a href="#使用shouldComponentUpdate" class="headerlink" title="使用shouldComponentUpdate"></a>使用shouldComponentUpdate</h3><p>一般情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class SomeComp extends Component&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate，但它默认返回 true，即始终会执行 render 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈</p>
<p>对于此类写法，每次一定是重新执行render的。所以，你需要用到shouldComponentUpdate这个生命周期函数, 来进行判断是否需要进行渲染。</p>
<ul>
<li>这是在重新渲染组件之前触发的其中一个生命周期事件。</li>
<li>这个函数将 nextState 和 nextProps 作为输入，并可将其与当前 props 和state做对比，以决定是否需要重新渲染。如果没有变化，则返回false来阻止更新。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">  if(nextState.a != this.state.a || netState.b = this.state.b) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用PureComponent"><a href="#使用PureComponent" class="headerlink" title="使用PureComponent"></a>使用PureComponent</h3><p>React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent 通过props和state的浅对比来实现 shouldComponentUpate</p>
<p>唯一的区别就是：PureComponent多了个标识isPureReactComponent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class SomeComp extends React.PureComponent &#123;</span><br><span class="line">    // Pure Components are the components that do not re-render if the State data or props data is still the same</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;&#123;this.props.a&#125;&lt;/div&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在react中有这么一段代码检查是否更新component</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function checkShouldComponentUpdate(</span><br><span class="line">  workInProgress,</span><br><span class="line">  ctor,</span><br><span class="line">  oldProps,</span><br><span class="line">  newProps,</span><br><span class="line">  oldState,</span><br><span class="line">  newState,</span><br><span class="line">  nextContext,</span><br><span class="line">) &#123;</span><br><span class="line">  const instance = workInProgress.stateNode;</span><br><span class="line">  if (typeof instance.shouldComponentUpdate === &apos;function&apos;) &#123;</span><br><span class="line">    startPhaseTimer(workInProgress, &apos;shouldComponentUpdate&apos;);</span><br><span class="line">    const shouldUpdate = instance.shouldComponentUpdate(</span><br><span class="line">      newProps,</span><br><span class="line">      newState,</span><br><span class="line">      nextContext,</span><br><span class="line">    );</span><br><span class="line">    stopPhaseTimer();</span><br><span class="line"></span><br><span class="line">    return shouldUpdate;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (ctor.prototype &amp;&amp; ctor.prototype.isPureReactComponent) &#123;</span><br><span class="line">    return (</span><br><span class="line">      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出react中判断更新的几个判断：无论组件是否是 PureComponent，如果定义了 shouldComponentUpdate，那么会调用它并以它的执行结果来判断是否 update。在组件未定义 shouldComponentUpdate 的情况下，会判断该组件是否是 PureComponent，如果是的话，会对新旧 props、state 进行 shallowEqual 比较，一旦新旧不一致，会触发 update。</p>
<p>这里面的shallowEqual只会比较到两个对象的 ownProperty 是否符合 Object.js() 判等，不会递归地去深层比较,如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function shallowEqual(objA, objB) &#123;</span><br><span class="line">  if (is(objA, objB)) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (</span><br><span class="line">    typeof objA !== &apos;object&apos; ||</span><br><span class="line">    objA === null ||</span><br><span class="line">    typeof objB !== &apos;object&apos; ||</span><br><span class="line">    objB === null</span><br><span class="line">  ) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const keysA = Object.keys(objA);</span><br><span class="line">  const keysB = Object.keys(objB);</span><br><span class="line"></span><br><span class="line">  if (keysA.length !== keysB.length) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Test for A&apos;s keys different from B.</span><br><span class="line">  for (let i = 0; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    if (</span><br><span class="line">      !hasOwnProperty.call(objB, keysA[i]) ||</span><br><span class="line">      !is(objA[keysA[i]], objB[keysA[i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function is(x, y) &#123;</span><br><span class="line">  return (</span><br><span class="line">    (x === y &amp;&amp; (x !== 0 || 1 / x === 1 / y)) || (x !== x &amp;&amp; y !== y)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h3><p>React.memo 是一个高阶组件。和 PureComponent 很相似，它也是帮助我们控制何时重新渲染组件</p>
<ul>
<li>PureComponent 要依靠 class 才能使用。而 React.memo() 可以和 functional component 一起使用。</li>
<li>与纯组件类似，如果输入 props 相同则跳过组件渲染，从而提升组件性能。</li>
<li>它会记忆上次某个输入 prop 的执行输出并提升应用性能。即使在这些组件中比较也是浅层的。</li>
<li>通过自动shouldComponentUpdate帮助组件执行是否需要update，但也只是执行浅比较，其意义和价值有限。</li>
<li><p>当然，你还可以为这个组件传递自定义比较逻辑。</p>
</li>
<li><p>为什么它被称作 memo？在计算机领域，记忆化是一种主要用来提升计算机程序速度的优化技术方案。它将开销较大的函数调用的返回结果存储起来，当同样的输入再次发生时，则返回缓存好的数据，以此提升运算效率。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let func = React.memo((props) =&gt; &#123;</span><br><span class="line">    return &lt;div &#123;...props&#125;&gt;sck&lt;/div&gt;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">function compare(previosProps, nextProps) &#123;</span><br><span class="line">    if(previosProps.user.a == nextProps.user.a ||</span><br><span class="line">       previosProps.user.b == nextProps.user.b ||</span><br><span class="line">       ) &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var memoComponent1 = React.memo(func);</span><br><span class="line">var memoComponent2 = React.memo(func, compare);</span><br></pre></td></tr></table></figure>
<h3 id="使用React-Fragments-避免额外标记"><a href="#使用React-Fragments-避免额外标记" class="headerlink" title="使用React.Fragments 避免额外标记"></a>使用React.Fragments 避免额外标记</h3><p>react 中组件一定要有一个唯一的父级元素，使得我们不得不在顶层加一个并不需要的div来确保能够正确被react解析渲染。加深了层级和一些不必要的渲染。</p>
<p>而Fragments 允许你将子列表分组，代码没有额外的标记，而无需向 DOM 添加额外节点。因此节省了渲染器渲染额外元素的工作量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default class SomeComp extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">          &lt;div&gt;header&lt;/div&gt;</span><br><span class="line">          &lt;div&gt;xxxx&lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不要使用内联函数定义"><a href="#不要使用内联函数定义" class="headerlink" title="不要使用内联函数定义"></a>不要使用内联函数定义</h3><p>如果我们使用内联函数，则每次调用“render”时都会创建一个新的函数实例</p>
<p>当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。</p>
<p>因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export default class SomeComp extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input type=&quot;button&quot; onClick=&#123;()=&gt; &#123;this.setState(&#123;a: 100&#125;)&#125;&#125; value=&quot;Click&quot; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数创建了内联函数。每次调用 render 函数时都会创建一个函数的新实例，render 函数会将该函数的新实例绑定到该按钮。</p>
<p>此外最后一个函数实例会被垃圾回收，大大增加了 React 应用的工作量。</p>
<p>修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default class SomeComp extends React.Component &#123;</span><br><span class="line">  </span><br><span class="line">  setNewData = () =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      a: 100</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;input type=&quot;button&quot; onClick=&#123;this.setNewData&#125; value=&quot;click&quot; /&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="在Constructor中绑定函数"><a href="#在Constructor中绑定函数" class="headerlink" title="在Constructor中绑定函数"></a>在Constructor中绑定函数</h3><p>当我们在 React 中创建函数时，我们需要使用 bind 关键字将函数绑定到当前上下文。</p>
<p>绑定可以在构造函数中完成，也可以在我们将函数绑定到 DOM 元素的位置上完成。</p>
<p>两者之间似乎没有太大差异，但性能表现是不一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export default class Sth extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleButtonClick() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;Click&quot; onClick=&#123;this.handleButtonClick.bind(this)&#125; /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们在 render 函数的绑定期间将函数绑定到按钮上。</p>
<p>上面代码的问题在于，每次调用 render 函数时都会创建并使用绑定到当前上下文的新函数，但在每次渲染时使用已存在的函数效率更高。优化方案如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export default class Sth extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.handleButtonClick = this.handleButtonClick.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  handleButtonClick() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;Click&quot; onClick=&#123;this.handleButtonClick&#125; /&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此类情况，最好在构造函数调用期间使用绑定到当前上下文的函数覆盖 handleButtonClick 函数。</p>
<p>这将减少将函数绑定到当前上下文的开销，无需在每次渲染时重新创建函数，从而提高应用的性能。</p>
<h3 id="避免使用内联样式属性"><a href="#避免使用内联样式属性" class="headerlink" title="避免使用内联样式属性"></a>避免使用内联样式属性</h3><p>使用内联样式时浏览器需要花费更多时间来处理脚本和渲染，因为它必须映射传递给实际 CSS 属性的所有样式规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">export default class Sth extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;span style=&#123;&#123;&quot;backgroundColor&quot;: &quot;red&quot;&#125;&#125;&gt;i am text&lt;/span&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面创建的组件中，我们将内联样式加到组件。添加的内联样式是 JavaScript 对象而不是样式标记。</p>
<p>样式 backgroundColor 需要转换为等效的 CSS 样式属性，然后才应用样式。这样就需要额外的脚本处理和 JS 执行工作。</p>
<p>而且，每次render会创建新的样式对象。而且当style作为props时，每次创建新对象会引起子组件的重新渲染。最好是通过导入类减少不必要的对象定义</p>
<h3 id="不要在render函数做渲染意外的任何事"><a href="#不要在render函数做渲染意外的任何事" class="headerlink" title="不要在render函数做渲染意外的任何事"></a>不要在render函数做渲染意外的任何事</h3><p>render作为纯函数，他的状态的变更只跟state有关。其他不想管的操作不要在此书写。应保持纯净，以确保组件以一致的方式运行和渲染。</p>
<h3 id="为组件创建错误边界"><a href="#为组件创建错误边界" class="headerlink" title="为组件创建错误边界"></a>为组件创建错误边界</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    console.log(&apos;getDerivedStateFromError:&apos;, error)</span><br><span class="line">    return &#123; hasError: true &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    elog.i(T, &quot;componentDidCatch&quot;, &#123; error, errorInfo &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      return &lt;h1&gt;Something went wrong&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。</p>
</li>
<li><p>错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。</p>
</li>
</ul>
<h3 id="避免-componentWillMount-中的异步请求"><a href="#避免-componentWillMount-中的异步请求" class="headerlink" title="避免 componentWillMount 中的异步请求"></a>避免 componentWillMount 中的异步请求</h3><p>componentWillMount的 react 16.3开始已经是unsafe了。不推荐使用。新版的react请避免使用这个生命周期函数</p>
<p>在componentWillMount中执行this.setState是不会触发二次渲染的。</p>
<p>它也只会在挂载过程中被调用一次，它的作用和constructor没有太大差异。有很多人在componentWillMount中请求后台数据，认为这样可以更早的得到数据，componentWillMout是在render函数执行前执行的，虽然请求是在第一次render之前发送的，但是返回并不能保证在render之前完成。render不会等你慢慢请求.所以在渲染的时候没有办法等到数据到来再去setState触发二次渲染.</p>
<ul>
<li>仔细思考一下，componentWillMount好像没啥卵用了。其实，在服务端渲染的场景中componentDidMount是不会被执行的，因此可以在componnetWillMount中发生AJAX请求。</li>
</ul>
<h3 id="componentWillUpdate、componentDidUpdate不要setState"><a href="#componentWillUpdate、componentDidUpdate不要setState" class="headerlink" title="componentWillUpdate、componentDidUpdate不要setState"></a>componentWillUpdate、componentDidUpdate不要setState</h3><p>这个就太基本了，这两个生命周期中不能调用setState，在它们里面调用setState会造成死循环，导致程序崩溃。</p>
<h3 id="尽量减少数组下标当做key"><a href="#尽量减少数组下标当做key" class="headerlink" title="尽量减少数组下标当做key"></a>尽量减少数组下标当做key</h3><p>为什么我们要使用key？</p>
<p>使用key能够让组件保持结构的稳定性。我们都知道React以其DOM Diff算法而著名，在实际比对节点更新的过程中带有唯一性的key能够让React更快得定位到变更的节点，从而可以做到最小化更新。</p>
<p>在实际使用过程中，很多人常常图方便会直接使用数组的下标(index)作为key，这是很危险的。因为经常会对数组数据进行增删，容易导致下标值不稳定。所以在开发过程中，应该尽量避免这种情况发生。</p>
<ul>
<li>使用唯一id作为key值。如果你的数据项有id并且是唯一的，就使用id作为key。如果没有，可以设置一个全局变量来保证id的唯一性</li>
<li>在实际生产环境中，一般使用第三方库来生成唯一id</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const shortid = require(&apos;shortid&apos;);</span><br></pre></td></tr></table></figure>
<p>而且错误的使用key值会有严重的后果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">class Item extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;form-group&quot;&gt;</span><br><span class="line">        &lt;label className=&quot;col-xs-4 control-label&quot;&gt;&#123;this.props.name&#125;&lt;/label&gt;</span><br><span class="line">        &lt;div className=&quot;col-xs-8&quot;&gt;</span><br><span class="line">          &lt;input type=&apos;text&apos; className=&apos;form-control&apos; /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Example extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      list: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addItem() &#123;</span><br><span class="line">    const id = +new Date;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      list: [ &#123;name: &apos;Baz&apos; + id, id&#125; , ...this.state.list]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button className=&apos;btn btn-primary&apos; onClick=&#123;this.addItem.bind(this)&#125;&gt;添加&lt;/button&gt;</span><br><span class="line">        &lt;h3&gt;错误&lt;code&gt;key=index&lt;/code&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;form className=&quot;form-horizontal&quot;&gt;</span><br><span class="line">          &#123;this.state.list.map((todo, index) =&gt;</span><br><span class="line">            &lt;Item &#123;...todo&#125; key=&#123;index&#125; /&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">        &lt;h3&gt;正确&lt;code&gt;key=id&lt;/code&gt;&lt;/h3&gt;</span><br><span class="line">        &lt;form className=&quot;form-horizontal&quot;&gt;</span><br><span class="line">          &#123;this.state.list.map((todo) =&gt;</span><br><span class="line">            &lt;Item &#123;...todo&#125; key=&#123;todo.id&#125; /&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">React.render(&lt;Example /&gt;, document.getElementById(&apos;app&apos;))</span><br></pre></td></tr></table></figure>
<p>我们先点击添加按钮，在文本框中输入一些测试值。然后再点击一次添加按钮，在列表顶部添加一个空的文本框，这时候发现问题了。由于我们错误的使用 index 作为 key 值，React 在渲染 list 列表时，会假定 key = 0 就是我们之前添加的第一个文本框，于是错误的将第一次输入的内容渲染到了我们新添加的文本框上。</p>
<p>所以，除非列表是不可变的情况下，见谅减少index下表作为key</p>
<h3 id="懒加载-lazy-suspense"><a href="#懒加载-lazy-suspense" class="headerlink" title="懒加载 lazy suspense"></a>懒加载 lazy suspense</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Suspense&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const OtherComponent = React.lazy(() =&gt; import(&apos;./main/index.js&apos;));</span><br><span class="line"></span><br><span class="line">export default function MyComponent() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">        &lt;OtherComponent /&gt;</span><br><span class="line">      &lt;/Suspense&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>延迟加载，就会有一个加载过程，之前在渲染的时候，我们基本都是自顶一个默认的组件，然后通过变量控制进行操作，如果加载完成，则取消掉默认的加载组件。</li>
<li>Suspense 让你的组件在渲染之前进行“等待”，并在等待时显示 fallback 的内容</li>
<li>React.lazy 函数能让你像渲染常规组件一样处理动态引入（的组件）</li>
<li>React.lazy 和 suspense 并不适用于服务端渲染</li>
</ul>
<p>这里展示如何在你的应用中使用 React.lazy 和 React Router 这类的第三方库，来配置基于路由的代码分割。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Suspense, lazy &#125; from &apos;react&apos;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Switch &#125; from &apos;react-router-dom&apos;;</span><br><span class="line"></span><br><span class="line">const Home = lazy(() =&gt; import(&apos;./routes/Home&apos;));</span><br><span class="line">const About = lazy(() =&gt; import(&apos;./routes/About&apos;));</span><br><span class="line"></span><br><span class="line">const App = () =&gt; (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">        &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    &lt;/Suspense&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h4 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h4><p>state或者props比较复杂时，我们可以在 shouldComponentUpdate 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render，但 deepCopy 和 deepCompare 一般都是非常耗性能的。所以，我们一般使用Immuable.js</p>
<p>Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 Persistent Data Structure（持久化数据结构），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了 Structural Sharing（结构共享），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。</p>
<p>Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p>
<p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; is &#125; from &apos;immutable&apos;;</span><br><span class="line"></span><br><span class="line">shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123;</span><br><span class="line">  const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||</span><br><span class="line">    Object.keys(thisState).length !== Object.keys(nextState).length) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const key in nextProps) &#123;</span><br><span class="line">    if (!is(thisProps[key], nextProps[key])) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  for (const key in nextState) &#123;</span><br><span class="line">    if (thisState[key] !== nextState[key] &amp;&amp; !is(thisState[key], nextState[key])) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>虽然Immutable JS在性能上有它的优势，但请注意使用的影响面。不要让原生对象和Immutable对象进行混用，这样反而会导致性能下降，因为将Immutable数据再转换成原生JS对象在性能上是很差的。</p>
</li>
<li><p>!!注意 在react中使用immutable 时，state 本身必须是普通对象，但是里面的值可以是 immutable 的数据。</p>
</li>
</ul>
<h4 id="更小的seamless-Immutable"><a href="#更小的seamless-Immutable" class="headerlink" title="更小的seamless-Immutable"></a>更小的seamless-Immutable</h4><p>你也可以选择seamless-Immutable </p>
<p>seamless-Immutable是一套轻量级的持久化数据结构库 , seamless-immutable 并没有实现完整的 Persistent Data Structure 而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。相比 Immutable.js 压缩后下载有 16K而言，小巧了很多, 而且API比较简洁，易懂。</p>
<h3 id="小心使用getDerivedStateFromProps"><a href="#小心使用getDerivedStateFromProps" class="headerlink" title="小心使用getDerivedStateFromProps"></a>小心使用getDerivedStateFromProps</h3><p>这个生命周期函数是为了替代componentWillReceiveProps存在的，所以在你需要使用componentWillReceiveProps的时候，就可以考虑使用getDerivedStateFromProps来进行替代了。</p>
<p>而getDerivedStateFromProps是一个静态函数，也就是这个函数不能通过this访问到class的属性，也并不推荐直接访问属性。而是应该通过参数提供的nextProps以及prevState来进行判断，根据新传入的props来映射到state。</p>
<ul>
<li>需要注意的是，如果props传入的内容不需要影响到你的state，那么就需要返回一个null，这个返回值是必须的，所以尽量将其写到函数的末尾。</li>
</ul>
<p><strong><em>会被频繁地触发</em></strong><br>无论是组件调用了 setState、接收的 props 发生了变化, 或是父组件的更新都会导致子组件上的 getDerivedStateFromProps被触发.</p>
<p><strong><em>使用时须小心</em></strong></p>
<p>由于 getDerivedStateFromProps 会在 setState() 后被调用, 并且它的返回值会被用于更新数据. 这意味着你会在 setState之后触发 getDerivedStateFromProps, 然后可能意外地再次 “setState()”</p>
<p>getDerivedStateFromProps(nextProps) 函数中的第一个位置参数未必是 “新” 的 props. 在组件内调用了 setState() 时, getDerivedStateFromProps 会被调用. 但是此时的组件其实并没有获得 “新” 的 props,这个 nextProps 的值和原来的 props 是一样的。这就导致了我们在使用 getDerivedStateFromProps 时, 必须添加很多逻辑判断语句来处理 props 上的更新和 state 上的更新, 避免意外地返回了一个 Updater 再次更新数据, 导致数据异常.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  let &#123;sex, birthday, nickname&#125; = nextProps.profile</span><br><span class="line">  if ( (nickname != prevState.nickname</span><br><span class="line">    || sex != prevState.sex</span><br><span class="line">    || birthday != prevState.birthday)</span><br><span class="line">    &amp;&amp; prevState.random === &apos;&apos;) &#123;</span><br><span class="line">    return nextProps.profile</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (!prevState.random) &#123; // 我们也会在本组件的state添加一个random来区分是否是来自本组件内部的更新，而不是props的更新</span><br><span class="line">    return prevState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="hooks相关"><a href="#hooks相关" class="headerlink" title="hooks相关"></a>hooks相关</h3><p>Hooks最大的优势就在于逻辑复用。16.8及以上版本提供了很多的hooks。</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  const [name, setName] = useState(&apos;名称&apos;)</span><br><span class="line">  const [content,setContent] = useState(&apos;内容&apos;)</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setName(new Date().getTime())&#125;&gt;name&lt;/button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; setContent(new Date().getTime())&#125;&gt;content&lt;/button&gt;</span><br><span class="line">        &lt;Button name=&#123;name&#125;&gt;&#123;content&#125;&lt;/Button&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Button(&#123; name, children &#125;) &#123;</span><br><span class="line">  function changeName(name) &#123;</span><br><span class="line">    console.log(&apos;11&apos;)</span><br><span class="line">    return name + &apos;改变name的方法&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const otherName =  changeName(name)</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;&#123;otherName&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;children&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们点击父组件的按钮的时候，子组件的name和children都会发生变化。<br>不管我们是改变name或者content的值，我们发现 changeName的方法都会被调用。<br>是不是意味着 我们本来只想修改content的值，但是由于name并没有发生变化，所以无需执行对应的changeName方法。但是发现他却执行了。 这是不是就意味着性能的损耗，做了无用功。</p>
<p>优化之后的子组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Button(&#123; name, children &#125;) &#123;</span><br><span class="line">  function changeName(name) &#123;</span><br><span class="line">    console.log(&apos;11&apos;)</span><br><span class="line">    return name + &apos;改变name的方法&apos;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">const otherName = useMemo(()=&gt;changeName(name), [name])</span><br><span class="line">  return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div&gt;&#123;otherName&#125;&lt;/div&gt;</span><br><span class="line">        &lt;div&gt;&#123;children&#125;&lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line"></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">export default Button</span><br></pre></td></tr></table></figure></p>
<p>这个时候我们点击改变content值的按钮，发现changeName 并没有被调用。但是点击改变name值按钮的时候，changeName被调用了。<br>所以我们可以使用useMemo方法 避免无用方法的调用，当然一般我们changName里面可能会使用useState来改变state的值，那是不是就避免了组件的二次渲染。<br>达到了优化性能的目的。</p>
<h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p>const fnA = useCallback(fnB, [a])</p>
<p>useCallback跟useMemo比较类似，但它返回的是缓存的函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useCallback &#125; from &apos;react&apos;;</span><br><span class="line">const set = new Set();</span><br><span class="line">export default function Callback() &#123;</span><br><span class="line">    const [count, setCount] = useState(1);</span><br><span class="line">    const [val, setVal] = useState(&apos;&apos;);</span><br><span class="line"> </span><br><span class="line">    const callback = useCallback(() =&gt; &#123;</span><br><span class="line">        console.log(count);</span><br><span class="line">    &#125;, [count]);</span><br><span class="line">    set.add(callback);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">        &lt;h4&gt;&#123;count&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;h4&gt;&#123;set.size&#125;&lt;/h4&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，每次修改count，set.size就会+1，这说明useCallback依赖变量count，count变更时会返回新的函数；而val变更时，set.size不会变，说明返回的是缓存的旧版本函数。</p>
<p>还有这种场景：有一个父组件，其中包含子组件，子组件接收一个函数作为props；通常而言，如果父组件更新了，子组件也会执行更新；但是大多数场景下，更新是没有必要的，我们可以借助useCallback来返回函数，然后把这个函数作为props传递给子组件；这样，子组件就能避免不必要的更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useCallback, useEffect &#125; from &apos;react&apos;;</span><br><span class="line">function Parent() &#123;</span><br><span class="line">  const [count, setCount] = useState(1);</span><br><span class="line">  const [val, setVal] = useState(&apos;&apos;);</span><br><span class="line"></span><br><span class="line">  const callback = useCallback(() =&gt; &#123;</span><br><span class="line">      return count;</span><br><span class="line">  &#125;, [count]);</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">      &lt;h4&gt;&#123;count&#125;&lt;/h4&gt;</span><br><span class="line">      &lt;Child callback=&#123;callback&#125;/&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">          &lt;input value=&#123;val&#125; onChange=&#123;event =&gt; setVal(event.target.value)&#125;/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function Child(&#123; callback &#125;) &#123;</span><br><span class="line">  const [count, setCount] = useState(() =&gt; callback());</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">      setCount(callback());</span><br><span class="line">  &#125;, [callback]);</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">      &#123;count&#125;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</li>
</ul>
<h4 id="是否一定要用useMemo-useCallback进行优化"><a href="#是否一定要用useMemo-useCallback进行优化" class="headerlink" title="是否一定要用useMemo/useCallback进行优化"></a>是否一定要用useMemo/useCallback进行优化</h4><p>useMemo/useCallback的使用非常简单，不过我们需要思考一个问题，使用他们一定能够达到优化的目的吗？</p>
<p>React的学习经常容易陷入过度优化的误区。一些人在得知shouldComponentUpdate能够优化性能，恨不得每个组件都要用一下，不用就感觉自己的组件有问题。useMemo/useCallback也是一样。</p>
<p>我们知道记忆函数的原理，应该知道，记忆函数并非完全没有代价，我们需要创建闭包，占用更多的内存，用以解决计算上的冗余。<br>useMemo/useCallback也是一样，这是一种成本上的交换。那么我们在使用时，就必须要思考，这样的交换，到底值不值。</p>
<p>如果不使用useCallback，我们就必须在函数组件内部创建超多的函数，这种情况是不是就一定有性能问题呢？</p>
<p>答案是否定的</p>
<p>我们知道，一个函数执行完毕之后，就会从函数调用栈中被弹出，里面的内存也会被回收。因此，即使在函数内部创建了多个函数，执行完毕之后，这些创建的函数也都会被释放掉。函数式组件的性能是非常快的。相比class，函数更轻量，也避免了使用高阶组件、renderProps等会造成额外层级的技术。使用合理的情况下，性能几乎不会有什么问题。<br>而当我们使用useMemo/useCallback时，由于新增了对于闭包的使用，新增了对于依赖项的比较逻辑，因此，盲目使用它们，甚至可能会让你的组件变得更慢。<br>大多数情况下，这样的交换，并不划算，或者赚得不多。你的组件可能并不需要使用useMemo/useCallback来优化。</p>
<h3 id="mixin、hoc、render-props、hooks-？"><a href="#mixin、hoc、render-props、hooks-？" class="headerlink" title="mixin、hoc、render props、hooks ？"></a>mixin、hoc、render props、hooks ？</h3><p>区别与联系，合理运用</p>
<h3 id="数据流管理"><a href="#数据流管理" class="headerlink" title="数据流管理"></a>数据流管理</h3><p>“单向数据绑定”是 React 推崇的一种应用架构的方式。当应用足够复杂时才能体会到它的好处，虽然在一般应用场景下你可能不会意识到它的存在</p>
<ul>
<li>单向数据流中的‘单向’– 数据从父组件到子组件这个流向叫单向。</li>
</ul>
<p>对于复杂的父级与孙子组件的数据通信，我们平常用的通过props传值的方法就显的不那么优雅简单了。</p>
<p>react提供了context </p>
<p>老的版本：<br>Context需要用到两种组件，一个是Context生产者(Provider)，通常是一个父节点，另外是一个Context的消费者(Consumer)，通常是一个或者多个子节点。所以Context的使用基于生产者消费者模式。<br>对于父组件，也就是Context生产者，需要通过一个静态属性childContextTypes声明提供给子组件的Context对象的属性，并实现一个实例getChildContext方法，返回一个代表Context的纯对象 (plain object) 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">class MiddleComponent extends React.Component &#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return &lt;ChildComponent /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ParentComponent extends React.Component &#123;</span><br><span class="line">  // 声明Context对象属性</span><br><span class="line">  static childContextTypes = &#123;</span><br><span class="line">    propA: PropTypes.string,</span><br><span class="line">    methodA: PropTypes.func</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 返回Context对象，方法名是约定好的</span><br><span class="line">  getChildContext () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      propA: &apos;propA&apos;,</span><br><span class="line">      methodA: () =&gt; &apos;methodA&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render () &#123;</span><br><span class="line">    return &lt;MiddleComponent /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于Context的消费者，通过如下方式访问父组件提供的Context。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;</span><br><span class="line"></span><br><span class="line">class ChildComponent extends React.Component &#123;</span><br><span class="line">  // 声明需要使用的Context属性</span><br><span class="line">  static contextTypes = &#123;</span><br><span class="line">    propA: PropTypes.string</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  render () &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      propA,</span><br><span class="line">      methodA</span><br><span class="line">    &#125; = this.context</span><br><span class="line">    </span><br><span class="line">    console.log(`context.propA = $&#123;propA&#125;`)  // context.propA = propA</span><br><span class="line">    console.log(`context.methodA = $&#123;methodA&#125;`)  // context.methodA = undefined</span><br><span class="line">    </span><br><span class="line">    return ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新的context：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">//定义context</span><br><span class="line">const RootContext = React.createContext(&#123;</span><br><span class="line">  showEyeCareDialog: false,</span><br><span class="line">  eyeCareBtn: &apos;unchecked&apos;,</span><br><span class="line">  clickEyeCareFunc: () =&gt; &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// context 对象接受一个名为 displayName 的 property，类型为字符串。React DevTools 使用该字符串来确定 context 要显示的内容。</span><br><span class="line">RootContext.displayName = &apos;RootContext&apos;;</span><br><span class="line"></span><br><span class="line">export default RootContext</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 父组件render， 提供context</span><br><span class="line">render() &#123;</span><br><span class="line">  let &#123;showEyeCareDialog&#125; = this.state</span><br><span class="line">  return &lt;div class=&quot;outer_container&quot;&gt;</span><br><span class="line">    &lt;RootContext.Provider value=&#123;</span><br><span class="line">      &#123;</span><br><span class="line">        ...this.state,</span><br><span class="line">        clickEyeCareFunc: this.clickEyeCareFunc</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;&gt;</span><br><span class="line">      &#123;this.props.children&#125;</span><br><span class="line">      &lt;EyeCareDialog</span><br><span class="line">        visible=&#123;showEyeCareDialog&#125;</span><br><span class="line">        close=&#123;this.closeEyeCardDilog&#125;/&gt;</span><br><span class="line">    &lt;/RootContext.Provider&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//子组件，获取context数据</span><br><span class="line">return &lt;RootContext.Consumer&gt;</span><br><span class="line">  &#123;(&#123;clickEyeCareFunc, eyeCareBtn&#125;) =&gt; (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div class=&quot;set_container&quot;&gt;</span><br><span class="line">      xxxx</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  )&#125;</span><br><span class="line">&lt;/RootContext.Consumer&gt;</span><br></pre></td></tr></table></figure>
<p>useContext hooks 官方示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: &quot;#000000&quot;,</span><br><span class="line">    background: &quot;#eeeeee&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: &quot;#ffffff&quot;,</span><br><span class="line">    background: &quot;#222222&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;/ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ThemedButton() &#123;</span><br><span class="line">  const theme = useContext(ThemeContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，必不可少的还有redux，关于redux的内容就太多了</p>
<p>比如：<br>redux尽量扁平化store<br>本身的增强combineReducer？compose？<br>一些常用中间件？ reselect避免冗余计算、redux-actions<br>处理异步？ redux-saga、redux-promise、redux-thunk、redux-observable<br>…</p>
<p>简单写下redux-ignore的使用：</p>
<p>我们在构建应用时，无法避免地，当项目越来越大时，action和相应reducer的数量会骤增。但是也许与大部分人的预期相反，当一个 action 触发时，不仅仅是该 action 对应的 reducer 执行了，其他所有的 reducer 也同时被执行了，只是 action type 不匹配，state 的值不变而已。这种空操作，也在无形中消耗了宝贵的性能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &quot;redux&quot;</span><br><span class="line">import &#123; ignoreActions, filterActions &#125; from &apos;redux-ignore&apos;</span><br><span class="line">import home from &quot;./home/reducer&quot;</span><br><span class="line">import &#123;USER_INFO, UPDATE_USER_INFO, CLEAR_USER_INFO &#125; from &quot;./my/action-type&quot;;</span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">  home, // 首页</span><br><span class="line">  my: filterActions(my, [USER_INFO, UPDATE_USER_INFO, CLEAR_USER_INFO]), // 我的,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样在调用非my的reducer的时候，不再执行定义的my的reducer</p>
<h2 id="2-代码体积"><a href="#2-代码体积" class="headerlink" title="2.代码体积"></a>2.代码体积</h2><ul>
<li>使用 生产版本</li>
<li>使用 webpack-bundle-analyzer 可视化 webpack 输出文件的大小</li>
<li>使用动态 import，懒加载 React 组件</li>
<li>使用 Tree Shaking &amp; 教程 &amp; Tree Shaking 优化</li>
<li>使用 babel-plugin-import 优化业务组件的引入，实现按需加载</li>
<li>使用 SplitChunksPlugin 拆分公共代码</li>
<li>优化 Webpack 中的库</li>
<li>分析 CSS 和 JS 代码覆盖率<br>…</li>
</ul>
<h2 id="从业务流程方面："><a href="#从业务流程方面：" class="headerlink" title="从业务流程方面："></a>从业务流程方面：</h2><p>一般的渐进式加载的全过程如下：<br>用户打开页面，这个时候页面是完全空白的；<br>然后 html 和引用的 css 加载完毕，浏览器进行首次渲染，我们把首次渲染需要加载的资源体积称为 “首屏体积”；<br>然后 react、react-dom、业务代码加载完毕，应用第一次渲染，或者说首次内容渲染；<br>然后应用的代码开始执行，拉取数据、进行动态import、响应事件等等，完毕后页面进入可交互状态；<br>然后直到页面的其它资源（如错误上报组件、打点上报组件等）加载完毕，整个页面的加载就结束了。</p>
<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>在大量图片加载的情况下，会造成页面空白甚至卡顿，然而我们的视口就这么大，因此只需要让视口内的图片显示即可，同时图片未显示的时候给它一个默认的 src，让一张非常精简的图片占位。这就是图片懒加载的原理。我们采取一个成熟的方案 react-lazyload 库，易上手，效果不错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">npm install react-lazyload --save</span><br><span class="line">//components/list.js</span><br><span class="line">// 引入</span><br><span class="line">import LazyLoad from &quot;react-lazyload&quot;;</span><br><span class="line"></span><br><span class="line">//img 标签外部包裹一层 LazyLoad</span><br><span class="line">&lt;LazyLoad placeholder=&#123;&lt;img width=&quot;100%&quot; height=&quot;100%&quot; src=&#123;require (&apos;./music.png&apos;)&#125; alt=&quot;music&quot;/&gt;&#125;&gt;</span><br><span class="line">  &lt;img src=&#123;item.picUrl + &quot;?param=300x300&quot;&#125; width=&quot;100%&quot; height=&quot;100%&quot; alt=&quot;music&quot;/&gt;</span><br><span class="line">&lt;/LazyLoad&gt;</span><br></pre></td></tr></table></figure>
<p>还有我们在加载文本、图片的时候，经常出现“闪屏”的情况，比如图片或者文字还没有加载完毕，此时页面上对应的位置还是完全空着的，然后加载完毕，内容会突然撑开页面，导致“闪屏”的出现，造成不好的体验。<br>一些优秀的组件react-placeholder、react-hold 解决placeholder问题</p>
<h3 id="spa项目首屏加载缓慢过度办法"><a href="#spa项目首屏加载缓慢过度办法" class="headerlink" title="spa项目首屏加载缓慢过度办法"></a>spa项目首屏加载缓慢过度办法</h3><p>使用 html-webpack-plugin 自动插入 loading</p>
<p>创建loading.html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;div class=&quot;pre-loading&quot;&gt;</span><br><span class="line">      loading...</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>webpack配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 读取写好的 loading 态的 html 和 css</span><br><span class="line">var loading = &#123;</span><br><span class="line">  html: fs.readFileSync(path.join(__dirname, &apos;./loading.html&apos;)),</span><br><span class="line">  css: &apos;&lt;style&gt;&apos; + fs.readFileSync(path.join(__dirname, &apos;./loading.css&apos;)) + &apos;&lt;/style&gt;&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const htmlWebpackPluginArr = Array.of(&apos;a&apos;, &apos;b&apos;, &apos;c&apos;).map(p =&gt; &#123;</span><br><span class="line">  return new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: `$&#123;p&#125;.html`,</span><br><span class="line">      template: `sample$&#123;!args.dev ? &apos;/cdn&apos; : &apos;&apos;&#125;/$&#123;p&#125;.html`,</span><br><span class="line">      inject: true,</span><br><span class="line">      chunks: [p],</span><br><span class="line">      minify: args.dev ? &#123;&#125; : minifyOb,</span><br><span class="line">      cdnConfig: externalConfig,</span><br><span class="line">      loading: loading</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="长列表"><a href="#长列表" class="headerlink" title="长列表"></a>长列表</h3><p>对于较长的列表，比如1000个数组的数据结构，如果想要同时渲染这1000个数据，生成相应的1000个原生dom，我们知道原生的dom元素是很复杂的，同时渲染很多dom节点，也会造成一下几个问题：</p>
<ul>
<li>容易失帧，因为渲染很慢，所以无法维持浏览器的帧率，主观上会显得页面卡顿</li>
<li>网页失去响应，事件等无法及时被触发</li>
</ul>
<p>贯穿React核心的就是”virtual dom”,我们同样的可以通过用虚拟列表的方式来优雅的优化长列表</p>
<p>通过react-virtualized 能够很好地处理大型列表（它只会渲染列表显示在屏幕上的一小部分，只有滚动列表时才会更新）</p>
<ul>
<li>或者通过react-tiny-virtual-list来优化长列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">    return &lt;div style=&#123;&#123;width:&quot;240px&quot;,height:&quot;80px&quot;,padding:&quot;15px&quot;,border:&quot;4px double red&quot;,resize:&quot;both&quot;,overflow:&quot;auto&quot;&#125;&#125;&gt;</span><br><span class="line">        &lt;AutoSizer&gt;</span><br><span class="line">        &#123;(&#123; height, width &#125;) =&gt; (</span><br><span class="line">          &lt;List</span><br><span class="line">            height=&#123;height&#125;</span><br><span class="line">            rowCount=&#123;list.length&#125;</span><br><span class="line">            rowHeight=&#123;cache.rowHeight&#125;</span><br><span class="line">            deferredMeasurementCache=&#123;cache&#125;</span><br><span class="line">            rowRenderer=&#123;cellRenderer&#125;</span><br><span class="line">            width=&#123;width&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/AutoSizer&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>react-transition-group</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; TransitionGroup, CSSTransition &#125; from &apos;react-transition-group&apos;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;TransitionGroup className=&#123;&apos;router-wrapper&apos;&#125;&gt;</span><br><span class="line">      &lt;CSSTransition timeout=&#123;300&#125; classNames=&#123;&apos;fade&apos;&#125; key=&#123;location.hash&#125; unmountOnExit=&#123;true&#125;&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=&quot;/schedule&quot; exact component=&#123;Schedule&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/set&quot; exact component=&#123;Set&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/personal&quot; exact component=&#123;Personal&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/faq&quot; exact component=&#123;Faq&#125; /&gt;</span><br><span class="line">          &lt;Route path=&quot;/classHour&quot; exact component=&#123;ClassHour&#125; /&gt;</span><br><span class="line">          &lt;Redirect to=&quot;/schedule&quot; /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/CSSTransition&gt;</span><br><span class="line">    &lt;/TransitionGroup&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂运算引入webworker"><a href="#复杂运算引入webworker" class="headerlink" title="复杂运算引入webworker"></a>复杂运算引入webworker</h3><p>对于高的计算，引入webworker。后台执行复杂运算</p>
<h2 id="3-性能度量、性能检测"><a href="#3-性能度量、性能检测" class="headerlink" title="3.性能度量、性能检测"></a>3.性能度量、性能检测</h2><h3 id="3-1-React-DevTools"><a href="#3-1-React-DevTools" class="headerlink" title="3.1 React DevTools"></a>3.1 React DevTools</h3><p>React 16.5 增加了对新的开发者工具 DevTools 性能分析插件的支持。 此插件使用 React 实验性的 Profiler API 来收集有关每个组件渲染的用时信息，以便识别 React 应用程序中的性能瓶颈。它将与我们即将推出的time slicing（时间分片） 和 suspense（悬停） 功能完全兼容。</p>
<p>DevTools 将为支持新的 Profiler API 的应用显示 “Profiler” 选项卡：</p>
<p>like this: </p>
<p><img src="/imgs/简单梳理react优化相关/reactdevtool.png" alt></p>
<p>可以： 浏览 commits、过滤 commits、看火焰图、排序图标、查看组件图标等</p>
<p><a href="http://react.html.cn/blog/2018/09/10/introducing-the-react-profiler.html#flame-chart" target="_blank" rel="noopener">官方中文</a></p>
<ul>
<li>功能很强大</li>
</ul>
<h4 id="3-2-Profiler"><a href="#3-2-Profiler" class="headerlink" title="3.2 Profiler"></a>3.2 Profiler</h4><p>Profiler 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用类似 memoization 优化的部分，并从相关优化中获益。</p>
<p><a href="https://reactjs.bootcss.com/docs/profiler.html" target="_blank" rel="noopener">官方中文</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &lt;Profiler id=&quot;Navigation&quot; onRender=&#123;onRenderCallback&#125;&gt;</span><br><span class="line">      &lt;Navigation &#123;...props&#125; /&gt;</span><br><span class="line">    &lt;/Profiler&gt;</span><br><span class="line">    &lt;Main &#123;...props&#125; /&gt;</span><br><span class="line">  &lt;/App&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function onRenderCallback(</span><br><span class="line">  id, // 发生提交的 Profiler 树的 “id”</span><br><span class="line">  phase, // &quot;mount&quot; （如果组件树刚加载） 或者 &quot;update&quot; （如果它重渲染了）之一</span><br><span class="line">  actualDuration, // 本次更新 committed 花费的渲染时间</span><br><span class="line">  baseDuration, // 估计不使用 memoization 的情况下渲染整颗子树需要的时间</span><br><span class="line">  startTime, // 本次更新中 React 开始渲染的时间</span><br><span class="line">  commitTime, // 本次更新中 React committed 的时间</span><br><span class="line">  interactions // 属于本次更新的 interactions 的集合</span><br><span class="line">) &#123;</span><br><span class="line">  // 合计或记录渲染时间。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-welldone-software-why-did-you-render-组件"><a href="#3-3-welldone-software-why-did-you-render-组件" class="headerlink" title="3.3 @welldone-software/why-did-you-render 组件"></a>3.3 @welldone-software/why-did-you-render 组件</h3><p>可以使用@welldone-software/why-did-you-render在控制台查看触发 View 更新的原因</p>
<ul>
<li>由于why-did-you-update 已经弃用了，现转为@welldone-software/why-did-you-render </li>
</ul>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 创建wdyr.js 然后在入口导入</span><br><span class="line">import React from &apos;react&apos;;</span><br><span class="line">if (process.env.NODE_ENV === &apos;development&apos;) &#123;</span><br><span class="line">  const whyDidYouRender = require(&apos;@welldone-software/why-did-you-render&apos;);</span><br><span class="line">  whyDidYouRender(React, &#123;</span><br><span class="line">    trackAllPureComponents: true,</span><br><span class="line">    trackHooks: true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 导入</span><br><span class="line">import &apos;@common/wdyr&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在你想分析的组件添加静态属性whyDidYouRender</span><br><span class="line">class RootComp extends Component &#123;</span><br><span class="line">  // 静态属性</span><br><span class="line">  static whyDidYouRender = true</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state = &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出现不必要的render会有类似如下的提示：<br><img src="/imgs/简单梳理react优化相关/wdyrrerender.png" alt></p>
<h3 id="3-4-Performance-api"><a href="#3-4-Performance-api" class="headerlink" title="3.4 Performance api"></a>3.4 Performance api</h3><p>performance.mark：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 以一个标志开始。</span><br><span class="line">performance.mark(&quot;mySetTimeout-start&quot;);</span><br><span class="line">// 等待一些时间。</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  // 标志时间的结束。</span><br><span class="line">  performance.mark(&quot;mySetTimeout-end&quot;);</span><br><span class="line"></span><br><span class="line">  // 测量两个不同的标志。</span><br><span class="line">  performance.measure(</span><br><span class="line">    &quot;mySetTimeout&quot;,</span><br><span class="line">    &quot;mySetTimeout-start&quot;,</span><br><span class="line">    &quot;mySetTimeout-end&quot;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  // 获取所有的测量输出。</span><br><span class="line">  // 在这个例子中只有一个。</span><br><span class="line">  var measures = performance.getEntriesByName(&quot;mySetTimeout&quot;);</span><br><span class="line"></span><br><span class="line">  var measure = measures[0];</span><br><span class="line">  console.log(&quot;setTimeout milliseconds:&quot;, measure.duration)</span><br><span class="line"></span><br><span class="line">  // 清除存储的标志位</span><br><span class="line">  // performance.clearMarks();</span><br><span class="line">  // performance.clearMeasures();</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<ul>
<li>你可以react工程的任意位置用performance.mark进行统计数据分析</li>
</ul>
<p>当然performance还有其他的api, 控制台打印下看看就知道了<br>performance.memory<br>performance.navigation<br>performance.timeOrigin<br>performance.timing<br>…</p>
<h3 id="当然我们可以用chrome浏览器自带的工具-performance-面板、Audits面版、memory面板、Porformance-monitor等进行分析"><a href="#当然我们可以用chrome浏览器自带的工具-performance-面板、Audits面版、memory面板、Porformance-monitor等进行分析" class="headerlink" title="当然我们可以用chrome浏览器自带的工具 performance 面板、Audits面版、memory面板、Porformance monitor等进行分析"></a>当然我们可以用chrome浏览器自带的工具 performance 面板、Audits面版、memory面板、Porformance monitor等进行分析</h3><p>不一一列举分析了</p>
<p><strong><em>最好的优化就是不碰到瓶颈前别瞎优化</em></strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2020/01/24/简单梳理react优化相关/" data-id="cksdvd0a6001eu0jbzo5n03xt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/12/10/关于前端性能优化的一些事/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">关于前端性能优化的一些事</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/技术/" style="font-size: 10px;">技术</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/01/24/简单梳理react优化相关/">简单梳理react优化相关</a>
          </li>
        
          <li>
            <a href="/2019/12/10/关于前端性能优化的一些事/">关于前端性能优化的一些事</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpack原理/">webpack原理</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpackPlugin/">webpackPlugin</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpackLoader/">webpackLoader</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 火柴人<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>