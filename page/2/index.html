<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>swing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="描述">
<meta property="og:type" content="website">
<meta property="og:title" content="swing">
<meta property="og:url" content="http://swingboy.github.io/page/2/index.html">
<meta property="og:site_name" content="swing">
<meta property="og:description" content="描述">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="swing">
<meta name="twitter:description" content="描述">
  
    <link rel="alternate" href="/atom.xml" title="swing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">swing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://swingboy.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-node require与webpack模块化原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/18/node require与webpack模块化原理/" class="article-date">
  <time datetime="2018-06-18T13:57:29.000Z" itemprop="datePublished">2018-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/18/node require与webpack模块化原理/">node require与webpack模块化原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="about-node-require"><a href="#about-node-require" class="headerlink" title="about node require"></a>about node require</h2><p>首先：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//node 模块代码</span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">module.exports = a;</span><br></pre></td></tr></table></figure>
<p>问题：在node执行的时候会发现，代码变成了这样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">    var a = &#123;&#125;;</span><br><span class="line">    module.exports = a;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，我们的模块代码在运行的时候是被包裹了一层的，而上面列的这些变量正是在这个包裹函数中作为形参传入的。<br>其中module指向模块本身，module.exports和exports是等价的，表示模块要导出供调用的内容</p>
</blockquote>
<h2 id="require的内部处理流程"><a href="#require的内部处理流程" class="headerlink" title="require的内部处理流程"></a>require的内部处理流程</h2><p>先上<a href="https://github.com/nodejs/node/blob/v5.x/lib/module.js" target="_blank" rel="noopener">代码</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Loads a module at the given file path. Returns that module&apos;s</span><br><span class="line">// `exports` property.</span><br><span class="line">Module.prototype.require = function (path) &#123;</span><br><span class="line">    assert(path, &apos;missing path&apos;);</span><br><span class="line">    assert(typeof path === &apos;string&apos;, &apos;path must be a string&apos;);</span><br><span class="line">    return Module._load(path, this, /* isMain */ false);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">	// .....</span><br><span class="line">	</span><br><span class="line">	return module.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Module._load = function(request, parent, isMain) &#123;</span><br><span class="line">  // 1. 检查 Module._cache，是否缓存之中有指定模块</span><br><span class="line">  // 2. 如果缓存之中没有，就创建一个新的Module实例</span><br><span class="line">  // 3. 将它保存到缓存</span><br><span class="line">  // 4. 使用 module.load() 加载指定的模块文件，</span><br><span class="line">  //    读取文件内容之后，使用 module.compile() 执行文件代码</span><br><span class="line">  // 5. 如果加载/解析过程报错，就从缓存删除该模块</span><br><span class="line">  // 6. 返回该模块的 module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Given a file name, pass it to the proper extension handler.</span><br><span class="line">Module.prototype.load = function(filename) &#123;</span><br><span class="line">  debug(&apos;load %j for module %j&apos;, filename, this.id);</span><br><span class="line"></span><br><span class="line">  assert(!this.loaded);</span><br><span class="line">  this.filename = filename;</span><br><span class="line">  this.paths = Module._nodeModulePaths(path.dirname(filename));</span><br><span class="line">  </span><br><span class="line">  // .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// Run the file contents in the correct scope or sandbox. Expose</span><br><span class="line">// the correct helper variables (require, module, exports) to</span><br><span class="line">// the file.</span><br><span class="line">// Returns exception, if any.</span><br><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">	// .....</span><br><span class="line">	const dirname = path.dirname(filename);</span><br><span class="line">  	const require = internalModule.makeRequireFunction.call(this);</span><br><span class="line">  	const args = [this.exports, require, this, filename, dirname];</span><br><span class="line">  	const depth = internalModule.requireDepth;</span><br><span class="line">  	if (depth === 0) stat.cache = new Map();</span><br><span class="line">  	const result = compiledWrapper.apply(this.exports, args);</span><br><span class="line">  	if (depth === 0) stat.cache = null;</span><br><span class="line">  	return result;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">  // 1. 生成一个require函数，指向module.require</span><br><span class="line">  // 2. 加载其他辅助方法到require</span><br><span class="line">  // 3. 将文件内容放到一个函数之中，该函数可调用 require</span><br><span class="line">  // 4. 执行该函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的第1步和第2步，require函数及其辅助方法主要如下。</p>
<blockquote>
<p>require(): 加载外部模块<br>require.resolve()：将模块名解析到一个绝对路径<br>require.cache：指向所有缓存的模块<br>require.extensions：根据文件的后缀名，调用不同的执行函数  </p>
</blockquote>
<p>一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">  // YOUR CODE INJECTED HERE!</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。</p>
<p>在Module._complie中是会在我们模块的代码外面包裹一些内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Module.prototype._compile = function(content, filename) &#123;</span><br><span class="line">  // remove shebang</span><br><span class="line">  content = content.replace(shebangRe, &apos;&apos;);</span><br><span class="line"></span><br><span class="line">  // create wrapper function</span><br><span class="line">  var wrapper = Module.wrap(content);</span><br><span class="line"></span><br><span class="line">  var compiledWrapper = runInThisContext(wrapper,</span><br><span class="line">                                      &#123; filename: filename, lineOffset: 0 &#125;);</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Module的warp 来自NativeModule</span><br><span class="line"></span><br><span class="line">NativeModule.wrap = function(script) &#123;</span><br><span class="line">  return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">NativeModule.wrapper = [</span><br><span class="line">  &apos;(function (exports, require, module, __filename, __dirname) &#123; &apos;,</span><br><span class="line">  &apos;\n&#125;);&apos;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>自此我们的模块内容算是包装完了。</p>
<p>AND <del>~</del>~</p>
<p>我们可以模拟一个类似node require的办法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function require(path) &#123;</span><br><span class="line">    function load()&#123;</span><br><span class="line">        return &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    let code = load(path);</span><br><span class="line">    code = &apos;function add(a, b) &#123;return a+b&#125;; module.exports = add&apos;;</span><br><span class="line">    // 封装成闭包</span><br><span class="line">    code = `(function(module) &#123; $&#123;code&#125; &#125;)(context)`;</span><br><span class="line">    // 相当于 exports，用于导出对象</span><br><span class="line">    let context = &#123;&#125;;</span><br><span class="line">    // 运行代码，使得结果影响到 context</span><br><span class="line">    const run = new Function(&apos;context&apos;, code);</span><br><span class="line">    </span><br><span class="line">    //大概就是这样子</span><br><span class="line">    &lt;!-- function(context)&#123;</span><br><span class="line">        (function(module) &#123;</span><br><span class="line">            function add(a, b) &#123;return a+b&#125;; </span><br><span class="line">            module.exports = add;</span><br><span class="line">        &#125;)(context)</span><br><span class="line">    &#125; --&gt;</span><br><span class="line"></span><br><span class="line">    run(context, code);</span><br><span class="line">    </span><br><span class="line">    //返回导出的结果</span><br><span class="line">    return context.exports;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = require(&apos;xxx&apos;).exports;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">阮老师require</a></p>
<h2 id="about-webpack-模块化"><a href="#about-webpack-模块化" class="headerlink" title="about webpack 模块化"></a>about webpack 模块化</h2><h5 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h5><p>webpack作为一个构建工具，解决了前端代码缺少模块化能力的问题。代码经过webpack构建和包装之后，能够在浏览器以模块化的方式运行。这些能力，都是因为webpack对我们的代码进行了一层包装。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>首先我们创建一个简单入口模块index.js和一些依赖模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">let &#123;name, age, address&#125; = require(&apos;./common.js&apos;);</span><br><span class="line">import es6 from &apos;./es6.js&apos;;</span><br><span class="line"></span><br><span class="line">console.log(name, es6(10));</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//es6.js</span><br><span class="line">export default function(a)&#123;</span><br><span class="line">	return 1000 + a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function testfun(a)&#123;</span><br><span class="line">	return a + &apos;哈哈哈&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//common.js</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	age: 10,</span><br><span class="line">	name: &apos;zhangsan&apos;,</span><br><span class="line">	address: function()&#123;</span><br><span class="line">		return &apos;dddd&apos;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>webpack 配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: path.join(__dirname, &apos;index.js&apos;),</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.join(__dirname, &apos;outs&apos;),</span><br><span class="line">        filename: &apos;index.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这是一个最简单的配置，只指定了模块入口和输出路径。</p>
</blockquote>
<p>执行webpack，得到经过webpack打包的代码如下（去掉了不必要的注释）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/******/ (function(modules) &#123; // webpackBootstrap</span><br><span class="line">/******/ 	// The module cache</span><br><span class="line">/******/ 	var installedModules = &#123;&#125;;</span><br><span class="line">/******/ 	// The require function</span><br><span class="line">/******/ 	function __webpack_require__(moduleId) &#123;</span><br><span class="line">/******/ 		// Check if module is in cache</span><br><span class="line">/******/ 		if(installedModules[moduleId]) &#123;</span><br><span class="line">/******/ 			return installedModules[moduleId].exports;</span><br><span class="line">/******/ 		&#125;</span><br><span class="line">/******/ 		// Create a new module (and put it into the cache)</span><br><span class="line">/******/ 		var module = installedModules[moduleId] = &#123;</span><br><span class="line">/******/ 			i: moduleId,</span><br><span class="line">/******/ 			l: false,</span><br><span class="line">/******/ 			exports: &#123;&#125;</span><br><span class="line">/******/ 		&#125;;</span><br><span class="line">/******/ 		// Execute the module function</span><br><span class="line">/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line">/******/ 		// Flag the module as loaded</span><br><span class="line">/******/ 		module.l = true;</span><br><span class="line">/******/ 		// Return the exports of the module</span><br><span class="line">/******/ 		return module.exports;</span><br><span class="line">/******/ 	&#125;</span><br><span class="line">/******/ 	// expose the modules object (__webpack_modules__)</span><br><span class="line">/******/ 	__webpack_require__.m = modules;</span><br><span class="line">/******/</span><br><span class="line">/******/ 	// expose the module cache</span><br><span class="line">/******/ 	__webpack_require__.c = installedModules;</span><br><span class="line">/******/</span><br><span class="line">/******/ 	// define getter function for harmony exports</span><br><span class="line">/******/ 	__webpack_require__.d = function(exports, name, getter) &#123;</span><br><span class="line">/******/ 		if(!__webpack_require__.o(exports, name)) &#123;</span><br><span class="line">/******/ 			Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;);</span><br><span class="line">/******/ 		&#125;</span><br><span class="line">/******/ 	&#125;;</span><br><span class="line">/******/ 	// define __esModule on exports</span><br><span class="line">/******/ 	__webpack_require__.r = function(exports) &#123;</span><br><span class="line">/******/ 		if(typeof Symbol !== &apos;undefined&apos; &amp;&amp; Symbol.toStringTag) &#123;</span><br><span class="line">/******/ 			Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &apos;Module&apos; &#125;);</span><br><span class="line">/******/ 		&#125;</span><br><span class="line">/******/ 		Object.defineProperty(exports, &apos;__esModule&apos;, &#123; value: true &#125;);</span><br><span class="line">/******/ 	&#125;;</span><br><span class="line">/******/ 	__webpack_require__.t = function(value, mode) &#123;</span><br><span class="line">/******/ 		if(mode &amp; 1) value = __webpack_require__(value);</span><br><span class="line">/******/ 		if(mode &amp; 8) return value;</span><br><span class="line">/******/ 		if((mode &amp; 4) &amp;&amp; typeof value === &apos;object&apos; &amp;&amp; value &amp;&amp; value.__esModule) return value;</span><br><span class="line">/******/ 		var ns = Object.create(null);</span><br><span class="line">/******/ 		__webpack_require__.r(ns);</span><br><span class="line">/******/ 		Object.defineProperty(ns, &apos;default&apos;, &#123; enumerable: true, value: value &#125;);</span><br><span class="line">/******/ 		if(mode &amp; 2 &amp;&amp; typeof value != &apos;string&apos;) for(var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key));</span><br><span class="line">/******/ 		return ns;</span><br><span class="line">/******/ 	&#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ 	// getDefaultExport function for compatibility with non-harmony modules</span><br><span class="line">/******/ 	__webpack_require__.n = function(module) &#123;</span><br><span class="line">/******/ 		var getter = module &amp;&amp; module.__esModule ?</span><br><span class="line">/******/ 			function getDefault() &#123; return module[&apos;default&apos;]; &#125; :</span><br><span class="line">/******/ 			function getModuleExports() &#123; return module; &#125;;</span><br><span class="line">/******/ 		__webpack_require__.d(getter, &apos;a&apos;, getter);</span><br><span class="line">/******/ 		return getter;</span><br><span class="line">/******/ 	&#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ 	// Object.prototype.hasOwnProperty.call</span><br><span class="line">/******/ 	__webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;;</span><br><span class="line">/******/</span><br><span class="line">/******/ 	// __webpack_public_path__</span><br><span class="line">/******/ 	__webpack_require__.p = &quot;&quot;;</span><br><span class="line">/******/</span><br><span class="line">/******/</span><br><span class="line">/******/ 	// Load entry module and return exports</span><br><span class="line">/******/ 	return __webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);</span><br><span class="line">/******/ &#125;)</span><br><span class="line">/******/ (&#123;</span><br><span class="line"></span><br><span class="line">/***/ &quot;./src/common.js&quot;:</span><br><span class="line">/***/ (function(module, exports) &#123;</span><br><span class="line"></span><br><span class="line">  eval(&quot;module.exports = &#123;\n\tage: 10,\n\tname: &apos;zhangsan&apos;,\n\taddress: function()&#123;\n\t\treturn &apos;dddd&apos;\n\t&#125;\n&#125;\n\n//# sourceURL=webpack:///./src/common.js?&quot;);</span><br><span class="line">  /***/ &#125;),</span><br><span class="line">  </span><br><span class="line">  /***/ &quot;./src/es6.js&quot;:</span><br><span class="line">  /***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span><br><span class="line">  </span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  eval(&quot;__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \&quot;testfun\&quot;, function() &#123; return testfun; &#125;);\n/* harmony default export */ __webpack_exports__[\&quot;default\&quot;] = (function(a)&#123;\n\treturn 1000 + a;\n&#125;);\n\nfunction testfun(a)&#123;\n\treturn a + &apos;哈哈哈&apos;;\n&#125;\n\n//# sourceURL=webpack:///./src/es6.js?&quot;);</span><br><span class="line">  /***/ &#125;),</span><br><span class="line"></span><br><span class="line">  /***/ &quot;./src/index.js&quot;:</span><br><span class="line">  /***/ (function(module, __webpack_exports__, __webpack_require__) &#123;  </span><br><span class="line">  &quot;use strict&quot;;</span><br><span class="line">  eval(&quot;__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./es6.js */ \&quot;./src/es6.js\&quot;);\nlet &#123;name, age, address&#125; = __webpack_require__(/*! ./common.js */ \&quot;./src/common.js\&quot;);\n\n\nconsole.log(name, Object(_es6_js__WEBPACK_IMPORTED_MODULE_0__[\&quot;default\&quot;])(10));\n\n\n//# sourceURL=webpack:///./src/index.js?&quot;);</span><br><span class="line"></span><br><span class="line">  /***/ &#125;)</span><br><span class="line"></span><br><span class="line">  /******/ &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>上面webpack打包的代码，整体可以简化成下面的结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function (modules) &#123;/* xxxx */&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">    &apos;./src/common.js&apos;: (function(module, exports) &#123;</span><br><span class="line">                /* 模块common.js的代码 */</span><br><span class="line">                eval(&quot;module.exports = &#123;\n\tage: 10,\n\tname: &apos;zhangsan&apos;,\n\taddress: function()&#123;\n\t\treturn &apos;dddd&apos;\n\t&#125;\n&#125;\n\n//# sourceURL=webpack:///./src/common.js?&quot;);</span><br><span class="line">                &#125;),</span><br><span class="line">    &apos;./src/es6.js&apos;: f()&#123;&#125;, /* 模块es6.js的代码 */</span><br><span class="line">    &apos;./src/index.js&apos;: f()&#123;&#125;, /* 模块index.js的代码 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>入口处文件最后结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var str = `__webpack_require__.r(__webpack_exports__);</span><br><span class="line">var _es6_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\&quot;./src/es6.js\&quot;);</span><br><span class="line">var &#123;name, age, address&#125; = __webpack_require__(\&quot;./src/common.js\&quot;);</span><br><span class="line">console.log(name, Object(_es6_js__WEBPACK_IMPORTED_MODULE_0__[\&quot;default\&quot;])(10));`;</span><br><span class="line">eval(str);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，整个打包生成的代码是一个立即执行函数。</p>
</blockquote>
<p>首先：函数参数是我们写的各个模块组成的数组，只不过我们的代码，被webpack包装在了一个函数的内部（也就是说我们的模块），在这里就是一个函数。为什么要这样做，是因为浏览器本身不支持模块化，那么webpack就用函数作用域来hack模块化的效果。</p>
<p>如果你debug过node代码，你会发现一样的hack方式，node中的模块也是函数，跟模块相关的参数exports、require，或者其他参数<strong>filename和</strong>dirname等都是通过函数传值作为模块中的变量，模块与外部模块的访问就是通过这些参数进行的，当然这对开发者来说是透明的。</p>
<p>同样的方式，webpack也控制了模块的module、exports和require，那么我们就看看webpack是如何实现这些功能的。</p>
<p>下面是摘取的函数内容和一些注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 1、模块缓存对象</span><br><span class="line">var installedModules = &#123;&#125;;</span><br><span class="line">// 2、webpack实现的require</span><br><span class="line">function __webpack_require__(moduleId) &#123;</span><br><span class="line">    // 3、判断是否已缓存模块</span><br><span class="line">    if(installedModules[moduleId]) &#123;</span><br><span class="line">        return installedModules[moduleId].exports;</span><br><span class="line">    &#125;</span><br><span class="line">    // 4、缓存模块</span><br><span class="line">    var module = installedModules[moduleId] = &#123;</span><br><span class="line">        i: moduleId,</span><br><span class="line">        l: false,</span><br><span class="line">        exports: &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    // 5、调用模块函数</span><br><span class="line">    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class="line">    // 6、标记模块为已加载</span><br><span class="line">    module.l = true;</span><br><span class="line">    // 7、返回module.exports</span><br><span class="line">    return module.exports;</span><br><span class="line">&#125;</span><br><span class="line">// 8、require第一个模块</span><br><span class="line">return __webpack_require__(__webpack_require__.s = 0);</span><br></pre></td></tr></table></figure>
<p>webpack之前的版本打过的内容，是这样子的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function(module) &#123;</span><br><span class="line">&#125;)([(function ()&#123;&#125;), function() &#123;&#125;])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>模块数组作为参数传入IIFE函数后，IIFE做了一些初始化工作：<br>IIFE首先定义了installedModules ，这个变量被用来缓存已加载的模块。</p>
</blockquote>
<blockquote>
<p>定义了<strong>webpack_require</strong> 这个函数，函数参数为模块的id。这个函数用来实现模块的require。</p>
</blockquote>
<blockquote>
<p><strong>webpack_require</strong> 函数首先会检查是否缓存了已加载的模块，如果有则直接返回缓存模块的exports。如果没有缓存，也就是第一次加载，则首先初始化模块，并将模块进行缓存。</p>
</blockquote>
<blockquote>
<p>然后调用模块函数，也就是前面webpack对我们的模块的包装函数，将module、module.exports和<strong>webpack_require</strong>作为参数传入。注意这里做了一个动态绑定，将模块函数的调用对象绑定module.exports，这是为了保证在模块中的this指向当前模块。</p>
</blockquote>
<blockquote>
<p>调用完成后，模块标记为已加载。</p>
</blockquote>
<blockquote>
<p>返回模块exports的内容。</p>
</blockquote>
<blockquote>
<p>利用前面定义的<strong>webpack_require</strong> 函数，require第0个模块，也就是入口模块。</p>
</blockquote>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>打包过的模块生成了一些以自执行函数形式的闭包。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/06/18/node require与webpack模块化原理/" data-id="ck9dloq160010wao7xymx9wqw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端异常监控" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/15/前端异常监控/" class="article-date">
  <time datetime="2018-06-15T09:23:30.000Z" itemprop="datePublished">2018-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/06/15/前端异常监控/">前端异常监控</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>###前言: JS异常处理简介</p>
<p>每天调试会看到控制台各种各式的红色错误代码。</p>
<p>JavaScript错误是怎么输出到控制台的  ——  JavaScript的错误处理原理。</p>
<p>当抛出异常时，JavaScript解释器会立即停下当前正在执行的逻辑，并且跳到最近的异常处理程序（可以参考冒泡与变量作用域的相关概念。一句话简单理解：儿子犯了错误，找老子，一层一层往上找，直到找到能够承担错误的对象为止）。如果在所有的词法结构和调用栈上面没有找到错误处理程序。JavaScript就会把异常当做程序错误处理，并报告给用户。</p>
<blockquote>
<p>只要有异常对象抛出，不管是浏览器抛出的，还是代码主动抛出，都会让程序停止执行。如果想让程序继续执行，则有也可以用try…catch来捕获。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  error</span><br><span class="line">  console.log(&apos;永远不会执行&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&apos;我继续执行&apos;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>再解释一下：</p>
<blockquote>
<p>1.当前代码块将作为一个任务压入任务队列中，JavaScript线程会不断地从任务队列中提取任务执行；</p>
</blockquote>
<blockquote>
<p>2.当任务执行过程中报异常，且异常没有捕获处理，则会一路沿着调用栈从顶到底抛出，最终终止当前任务的执行；</p>
</blockquote>
<blockquote>
<p>3.JavaScript线程会继续从任务队列中提取下一个任务继续执行。</p>
</blockquote>
<h3 id="一、收集日志的方法"><a href="#一、收集日志的方法" class="headerlink" title="一、收集日志的方法"></a>一、收集日志的方法</h3><p>平时收集日志的手段，可以归类为两个方面，一个是逻辑中的错误判断，为主动判断；一个是利用语言给我们提供的捷径，暴力式获取错误信息，如 try..catch 和 window.onerror等</p>
<h5 id="1-主动判断"><a href="#1-主动判断" class="headerlink" title="1. 主动判断"></a>1. 主动判断</h5><p>我们在一些运算之后，得到一个期望的结果，然而结果不是我们想要的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">function calc()&#123;</span><br><span class="line">  // sth code...</span><br><span class="line">  return val;</span><br><span class="line">&#125;</span><br><span class="line">if(calc() !== &quot;someVal&quot;)&#123;</span><br><span class="line">  Reporter.send(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种属于逻辑错误/状态错误的反馈，在接口状态判断中用的比较多。</p>
<p>#####2. try..catch 捕获<br>判断一个代码段中存在的错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  init();</span><br><span class="line">  // code...</span><br><span class="line">&#125; catch(e)&#123;</span><br><span class="line">  Reporter.send(format(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以 init 为程序的入口，代码中所有同步执行出现的错误都会被捕获，这种方式也可以很好的避免程序刚跑起来就挂掉。</p>
<h5 id="3-window-onerror"><a href="#3-window-onerror" class="headerlink" title="3. window.onerror"></a>3. window.onerror</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = function() &#123;</span><br><span class="line">  var errInfo = format(arguments);</span><br><span class="line">  Reporter.send(errInfo);</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(上文中返回true时，便不会把错误暴露在控制台中)</p>
<h3 id="二、会出现的问题或注意事项或解决办法"><a href="#二、会出现的问题或注意事项或解决办法" class="headerlink" title="二、会出现的问题或注意事项或解决办法"></a>二、会出现的问题或注意事项或解决办法</h3><h5 id="关于window-onerror-的使用"><a href="#关于window-onerror-的使用" class="headerlink" title="关于window.onerror 的使用"></a>关于window.onerror 的使用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// test.js</span><br><span class="line">throw new Error(&quot;SHOW ME&quot;);</span><br><span class="line">window.onerror = function()&#123;</span><br><span class="line">	console.log(arguments);</span><br><span class="line">	// 阻止在控制台中打印错误信息</span><br><span class="line">	return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的代码直接报错了，没有继续往下执行。页面中可能有好几个 script 标签，但是 window.onerror 这个错误监听一定要放到最前头！</p>
<h5 id="关于-try-catch-的使用"><a href="#关于-try-catch-的使用" class="headerlink" title="关于 try..catch 的使用"></a>关于 try..catch 的使用</h5><p>对于 try..catch 的使用，一般建议是：能不用，尽量不要用。JS代码都是自己写出来的，哪里会出现问题，会出现什么问题，心中应该都有个谱，平时用到 try..catch 的一般只有两个地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JSON 格式不对</span><br><span class="line">try&#123;</span><br><span class="line">  JSON.parse(JSONString);</span><br><span class="line">&#125;catch(e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">// 存在不可 decode 的字符</span><br><span class="line">try&#123;</span><br><span class="line">  decodeURIComponent(&quot;%111&quot;)</span><br><span class="line">&#125;catch(e)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不能捕获异步的错误，promise、setTimeout等异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(2);</span><br><span class="line">        JSON.parse(&apos;&#123;&#123;&#125;&apos;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">    console.log(3);</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">    console.log(&apos;55&apos;); //是捕获不到的</span><br><span class="line">&#125;</span><br><span class="line">console.log(4);</span><br></pre></td></tr></table></figure>
<h4 id="如何监听promise错误"><a href="#如何监听promise错误" class="headerlink" title="如何监听promise错误"></a>如何监听promise错误</h4><p>（关于事件 unhandledrejection、rejectionhandled）</p>
<blockquote>
<p>h5新增的事件；</p>
</blockquote>
<h5 id="unhandledrejection"><a href="#unhandledrejection" class="headerlink" title="unhandledrejection"></a>unhandledrejection</h5><p>当Promise 被reject并且没有得到处理的时候，会触发unhandledrejection事件。<br>unhandledrejection继承自PromiseRejectionEvent，PromiseRejectionEvent又继承自Event。因此unhandledrejection含有PromiseRejectionEvent和Event的属性和方法。</p>
<h5 id="rejectionhandled"><a href="#rejectionhandled" class="headerlink" title="rejectionhandled"></a>rejectionhandled</h5><p>当一个Promise错误最初未被处理，但是稍后又得到了处理，则会触发rejectionhandled事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;error&apos;, error =&gt; &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(&apos;error 监听&apos;,error); // 不会触发,这里不会</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">window.addEventListener(&apos;unhandledrejection&apos;, event =&gt; &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(event.reason); // 打印&quot;啦啦啦啦 reject&quot;</span><br><span class="line">&#125;);</span><br><span class="line">window.addEventListener(&apos;rejectionhandled&apos;, event =&gt; &#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(&apos;rejection handled&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">function foo() &#123;</span><br><span class="line">    return Promise.reject(&apos;啦啦啦啦 reject&apos;);</span><br><span class="line">&#125;</span><br><span class="line">var r = foo();</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    r.catch(e =&gt; &#123; &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<h5 id="无具体报错信息，只有Script-error"><a href="#无具体报错信息，只有Script-error" class="headerlink" title="无具体报错信息，只有Script error"></a>无具体报错信息，只有Script error</h5><blockquote>
<p>需要设置 crossorigin 并且服务器要设置 Access-Control-Allow-Origin 的响应头(被引用的资源链)：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://localhost/test.js&quot; crossorigin&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种简单报错： Script error，目的是避免数据泄露到不安全的域中</p>
</blockquote>
<blockquote>
<p>crossOrigin参数 跳过跨域限制<br>image 和 script 标签都有此参数，它的作用就是告诉浏览器，我要加载一个外域的资源，并且我信任这个资源。</p>
</blockquote>
<h5 id="async-await-和捕获异常"><a href="#async-await-和捕获异常" class="headerlink" title="async/await 和捕获异常"></a>async/await 和捕获异常</h5><p>作为异步的中级方案，catch异常也是很简单的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var sleep = function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            reject(&apos;error&apos;);</span><br><span class="line">        &#125;, time);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func = async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        console.log(&apos;start&apos;);</span><br><span class="line">        await sleep(1000); // 这里得到了一个返回错误</span><br><span class="line">        </span><br><span class="line">        // 所以以下代码不会被执行了</span><br><span class="line">        console.log(&apos;end&apos;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(&apos;catch内容：&apos;, err); // 这里捕捉到错误 `error`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">func();</span><br></pre></td></tr></table></figure>
<p>#####有iframe的页面怎么监听？</p>
<ul>
<li>同源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.frames[0].onerror = function (msg, url, row, col, error) &#123;</span><br><span class="line">    console.log(&#123;</span><br><span class="line">      msg,  url,  row, col, error</span><br><span class="line">    &#125;)</span><br><span class="line">    return true;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非同源（包括可控与不可控）<br>可控的类似可以实行跨域那一套。postMessage等等。</li>
</ul>
<p>略</p>
<h4 id="关于网络请求的"><a href="#关于网络请求的" class="headerlink" title="关于网络请求的"></a>关于网络请求的</h4><p>由于网络请求异常不会冒泡，因此必须在capture阶段捕获才可以。但还有一个问题是这种方式无法精确判断异常的HTTP状态是404还是500等，因此还是要配合服务端日志来排查分析才可以。</p>
<p>所以，这种情况下onerror 是无法帮助我们捕获到异常的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.onerror = function (msg, url, row, col, error) &#123;</span><br><span class="line">    console.log(&apos;我知道异步错误了&apos;);</span><br><span class="line">    console.log(&#123;</span><br><span class="line">      msg,  url,  row, col, error</span><br><span class="line">    &#125;)</span><br><span class="line">    return true;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">//html</span><br><span class="line">&lt;img src=&quot;./404.png&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>必须要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;error&quot;, function(e)&#123;</span><br><span class="line">    debugger;</span><br><span class="line">    console.log(&apos;报错了啦啦&apos;, e.bubbles)</span><br><span class="line">&#125;,   true);</span><br><span class="line"></span><br><span class="line">//html</span><br><span class="line">&lt;img src=&quot;404.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="框架里面的问题"><a href="#框架里面的问题" class="headerlink" title="框架里面的问题"></a>框架里面的问题</h4><p>现在越来越多的项目开始使用前端框架，在MVVM框架中如果你一如既往的想使用window.onerror来捕获异常，很可能不好使，或许根本捕获不到，因为你的异常信息被框架自身的异常机制捕获了。<br>比如Vue 中我们应该这样捕获全局异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.errorHandler = function (err, vm, info) &#123;</span><br><span class="line">    let &#123; </span><br><span class="line">        message, // 异常信息</span><br><span class="line">        name, // 异常名称</span><br><span class="line">        script,  // 异常脚本url</span><br><span class="line">        line,  // 异常行号</span><br><span class="line">        column,  // 异常列号</span><br><span class="line">        stack  // 异常堆栈信息</span><br><span class="line">    &#125; = err;</span><br><span class="line"></span><br><span class="line">    // vm为抛出异常的 Vue 实例</span><br><span class="line">    // info为 Vue 特定的错误信息，比如错误所在的生命周期钩子</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有，react 16里面提供了componentDidCatch方法，可以直接捕获react组件里面的异常来直接上报。这样其实对于react的场景就更简单了。它能捕获在子组件树中任何地方的 JavaScript 异常，并打印这些错误和展示备用UI, 就像将 children 包裹在一个大的 try/catch 语句块中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">let Com = function()&#123;</span><br><span class="line">    return (&lt;div&gt;        </span><br><span class="line">        &lt;ErrorHandler&gt;</span><br><span class="line">            &lt;TestState/&gt;</span><br><span class="line">        &lt;/ErrorHandler&gt;</span><br><span class="line">    &lt;/div&gt;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Com/&gt;, document.getElementById(&apos;root&apos;));</span><br><span class="line"></span><br><span class="line">class ErrorHandler extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123; hasError: false &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidCatch(error, info) &#123;</span><br><span class="line">        console.log(&apos;err.&apos;, error);</span><br><span class="line">        this.setState(&#123; hasError: true &#125;);</span><br><span class="line">        // report(error, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        if (this.state.hasError) &#123;</span><br><span class="line">            return &lt;h1&gt;这是报错页面&lt;/h1&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">        return this.props.children;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在子组件中</span><br><span class="line">//throw Error(&apos;我错啦&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="定位错误"><a href="#定位错误" class="headerlink" title="定位错误"></a>定位错误</h2><p>我们的业务代码经webpack、gulp等打包压缩后产生如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(n)&#123;function t(e)&#123;if(r[e])return r[e].exports;var o=r[e]=&#123;i:e,l:!1,exports:&#123;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>在控制台会看到对应的数据：<br>代码如期报错，并上报相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; msg: &apos;Uncaught ReferenceError: xxx is not defined&apos;,</span><br><span class="line">  url: &apos;http://xxx/xxx.min.js&apos;,</span><br><span class="line">  row: &apos;10&apos;,</span><br><span class="line">  col: &apos;1000&apos; &#125;</span><br></pre></td></tr></table></figure>
<p>结合压缩后的代码，肉眼观察很难定位出具体问题</p>
<p>那我们如何定位到错误呢？</p>
<p>方法一：不压缩 js 代码</p>
<p>方法二：将压缩代码中分号变成换行</p>
<p>方案三：js 代码半压缩(保留空格和换行)</p>
<p>uglifyjs 的另一配置参数 beautify 设置为 true 时，最终代码将呈现压缩后进行格式化的效果（保留空格和换行），如</p>
<p>方案四：SourceMap 快速定位</p>
<blockquote>
<p>我们目前的办法是用chrome的DevTools这样的辅助工具。而且并不是每个线上资源都会添加 sourceMap 文件</p>
</blockquote>
<h5 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h5><p>SourceMap 是一个信息文件，存储着源文件的信息及源文件与处理后文件的映射关系。 里面储存着位置信息。也就是说，转换后的代码的每一个位置，所对应的转换前的位置。</p>
<p>我们在定位压缩代码的报错时，可以通过错误信息的行列数与对应的 SourceMap 文件，处理后得到源文件的具体错误信息。</p>
<p>打开Source map文件，它大概是这个样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	version : 3,</span><br><span class="line">　　file: &quot;out.js&quot;,</span><br><span class="line">　　sourceRoot : &quot;&quot;,</span><br><span class="line">　　sources: [&quot;a.js&quot;, &quot;b.js&quot;],</span><br><span class="line">　　names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span><br><span class="line">　　mappings: &quot;AAgBC,SAAQ,CAAEA&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>version：Source map的版本，目前为3。</li>
<li>file：转换后的文件名。</li>
<li>sourceRoot：转换前的文件所在的目录。如果与转换前的文件在同一目录，该项为空。</li>
<li>sources：转换前的文件。该项是一个数组，表示可能存在多个文件合并。</li>
<li>names：转换前的所有变量名和属性名。</li>
<li>mappings：记录位置信息的字符串。</li>
</ul>
<p>应用举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var sourceMap = require(&apos;source-map&apos;);</span><br><span class="line"></span><br><span class="line">// map文件</span><br><span class="line">var rawSourceMapJsonData = fs.readFileSync(&apos;./index.min.js.map&apos;, &apos;utf-8&apos;)</span><br><span class="line">rawSourceMapJsonData = JSON.parse(rawSourceMapJsonData)</span><br><span class="line"></span><br><span class="line">var consumer = new sourceMap.SourceMapConsumer(rawSourceMapJsonData);</span><br><span class="line"></span><br><span class="line">// 得到真实错误位置</span><br><span class="line">console.log(consumer.originalPositionFor(&#123;line: 1, column: 100&#125;))</span><br></pre></td></tr></table></figure>
<p><a href="http://www.ruanyifeng.com/blog/2013/01/javascript_source_map.html" target="_blank" rel="noopener">阮一峰JavaScript Source Map 详解</a></p>
<p><a href="https://github.com/swingboy/errorMonitor" target="_blank" rel="noopener">示例代码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/06/15/前端异常监控/" data-id="ck9dloq1c001awao7ajuap2r1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于前端路由的一些事" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/12/关于前端路由的一些事/" class="article-date">
  <time datetime="2018-04-12T12:18:56.000Z" itemprop="datePublished">2018-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/12/关于前端路由的一些事/">关于前端路由的一些事</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##关于前端路由的一些事</p>
<h3 id="路由实现"><a href="#路由实现" class="headerlink" title="路由实现"></a>路由实现</h3><h4 id="一、hashchange"><a href="#一、hashchange" class="headerlink" title="一、hashchange"></a>一、hashchange</h4><p>回忆基础知识：<br></p>
<p>1、hash即URL中”#”字符后面的部分。(location.hash 看下)</p>
<p>　　①使用浏览器访问网页时，如果网页URL中带有hash，页面就会定位到id（或name）与hash值一样的元素的位置；</p>
<p>　　②hash还有另一个特点，它的改变不会导致页面重新加载；</p>
<p>　　③hash值浏览器是不会随请求发送到服务器端的；</p>
<p>　　④通过window.location.hash属性获取和设置hash值。</p>
<blockquote>
<p>window.location.hash值的变化会直接反应到浏览器地址栏（#后面的部分会发生变化），同时，浏览器地址栏hash值的变化也会触发window.location.hash值的变化，从而触发onhashchange事件。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">//实现实例</span><br><span class="line">&lt;div class=&quot;main&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;menu&quot;&gt;</span><br><span class="line">            &lt;a href=&quot;/&quot;&gt;首页&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;/profile&quot;&gt;个人中心&lt;/a&gt;</span><br><span class="line">            &lt;a href=&quot;/articles&quot;&gt;文章列表&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=&quot;content&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">        const $ = (selector) =&gt; document.querySelector(selector);</span><br><span class="line">        const routeMap = &#123;</span><br><span class="line">            &apos;/&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = &apos;&lt;div&gt;the Home Page&lt;/div&gt;&apos;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;/profile&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = &apos;&lt;div&gt;the Profile Page&lt;/div&gt;&apos;;</span><br><span class="line">            &#125;,</span><br><span class="line">            &apos;/articles&apos;: () =&gt; &#123;</span><br><span class="line">                const content = $(&apos;.content&apos;);</span><br><span class="line">                content.innerHTML = `&lt;div&gt;</span><br><span class="line">                    &lt;p&gt;the Article Page&lt;/p&gt;</span><br><span class="line">                    &lt;ul&gt;</span><br><span class="line">                        &lt;li&gt;文章1&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;文章2&lt;/li&gt;</span><br><span class="line">                        &lt;li&gt;文章3&lt;/li&gt;</span><br><span class="line">                    &lt;/ul&gt;</span><br><span class="line">                &lt;/div&gt;`;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        class Route &#123;</span><br><span class="line">            constructor(routeMap) &#123;</span><br><span class="line">                this.routeMap = routeMap;</span><br><span class="line">                this._bindPopState();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            init(path) &#123;</span><br><span class="line">                path = Route.correctPath(path);</span><br><span class="line">                history.replaceState(&#123; path: path &#125;, &apos;&apos;, path);</span><br><span class="line">                this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            go(path) &#123;</span><br><span class="line">                path = Route.correctPath(path);</span><br><span class="line">                history.pushState(&#123; path: path &#125;, &apos;&apos;, path);</span><br><span class="line">                this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            _bindPopState() &#123;</span><br><span class="line">                window.addEventListener(&apos;popstate&apos;, (e) =&gt; &#123;</span><br><span class="line">                    const path = e.state &amp;&amp; e.state.path;</span><br><span class="line">                    this.routeMap[path] &amp;&amp; this.routeMap[path]();</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            static correctPath(path) &#123;</span><br><span class="line">                if(path !== &apos;/&apos; &amp;&amp; path.slice(-1) === &apos;/&apos;)&#123;</span><br><span class="line">                    path = path.match(/(.+)\/$/)[1];</span><br><span class="line">                &#125;</span><br><span class="line">                return path;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const router = new Route(routeMap);</span><br><span class="line">        router.init(location.pathname);</span><br><span class="line">        </span><br><span class="line">        $(&apos;.menu&apos;).addEventListener(&apos;click&apos;, (e) =&gt; &#123;</span><br><span class="line">            if (e.target.tagName === &apos;A&apos;) &#123;</span><br><span class="line">                e.preventDefault();</span><br><span class="line">                router.go(e.target.getAttribute(&apos;href&apos;))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2、hashchange事件（IE8已支持该事件）</p>
<p>　　①当URL的片段标识符更改时，将触发hashchange事件（跟在#符号后面的URL部分，包括#符号）</p>
<p>　　②hashchange事件触发时，事件对象会有hash改变前的URL（oldURL）和hash改变后的URL（newURL）两个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;hashchange&apos;, function(e) &#123;</span><br><span class="line">	console.log(e.oldURL); </span><br><span class="line">	console.log(e.newURL);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>
<h4 id="二、通过history"><a href="#二、通过history" class="headerlink" title="二、通过history"></a>二、通过history</h4><p>回忆:<br></p>
<p>history是HTML5新增的一个api。</p>
<blockquote>
<p>其中包括2个方法：<br><br>history.pushState() <br><br>history.replaceState() <br><br>1个事件：window.onpopstate。</p>
</blockquote>
<p>####说明:</p>
<h5 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a>pushState</h5><p>函数向浏览器的历史堆栈压入一个url为设定值的记录，并改变历史堆栈的当前指针至栈顶。</p>
<p>history.pushState(stateObject, title, url)，包括三个参数。</p>
<blockquote>
<p>stateObj，一个普通的js对象，可以包含任何数据，它包含在新的hsitory实体的state属性中。当用户导航到该状态时，一个popstate事件将会被触发，并且在该事件的e.state中会包含这个stateObj。</p>
</blockquote>
<blockquote>
<p>title，目前没什么用，我们可以传入一个空字符串，或者一个表示新history状态的字符串。</p>
</blockquote>
<blockquote>
<p>URL，可选参数，这将会改变浏览器当前的url，但是新的url并不会立刻加载。当时用户此时跳转到另外一个页面，然后再点击后退，该url会加载，并且触发popstate事件。</p>
</blockquote>
<p>示例： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;name: &apos;xwj&apos;, age: 22&#125;, &apos;&apos;, &apos;/profile&apos;);</span><br><span class="line"></span><br><span class="line">// 浏览器地址会变为http://www.example.com/profile，但并不会加载。同时history的length会加1，state会变为传入的stateObj</span><br></pre></td></tr></table></figure>
<h5 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState"></a>replaceState</h5><p>该接口与pushState参数相同，含义也相同。唯一的区别在于replaceState是替换浏览器历史堆栈的当前历史记录为设定的url。需要注意的是，replaceState不会改动浏览器历史堆栈的当前指针。length不会变。</p>
<h5 id="onpopstate"><a href="#onpopstate" class="headerlink" title="onpopstate"></a>onpopstate</h5><p>该事件是window的属性。该事件会在调用浏览器的前进、后退以及执行history.forward、history.back、和history.go触发，因为这些操作有一个共性，即修改了历史堆栈的当前指针。在不改变document的前提下，一旦当前指针改变则会触发onpopstate事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/&quot;&gt;turn white&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/blue&quot;&gt;turn blue&lt;/a&gt;&lt;/li&gt; </span><br><span class="line">            &lt;li&gt;&lt;a href=&quot;#/green&quot;&gt;turn green&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;script&gt;</span><br><span class="line">    function Router() &#123;</span><br><span class="line">        this.routes = &#123;&#125;;</span><br><span class="line">        this.currentUrl = &apos;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    Router.prototype.addRoute = function(path, callback) &#123;</span><br><span class="line">        this.routes[path] = callback || function()&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    Router.prototype.refresh = function(e) &#123;</span><br><span class="line">        this.currentUrl = location.hash.slice(1) || &apos;/&apos;;</span><br><span class="line">        console.log(e.oldURL , e.newURL);</span><br><span class="line">        this.routes[this.currentUrl]();</span><br><span class="line">    &#125;;</span><br><span class="line">    Router.prototype.init = function() &#123;</span><br><span class="line">        window.addEventListener(&apos;load&apos;, this.refresh.bind(this), false);</span><br><span class="line">        window.addEventListener(&apos;hashchange&apos;, this.refresh.bind(this), false);</span><br><span class="line">    &#125;</span><br><span class="line">    window.Router = new Router();</span><br><span class="line">    window.Router.init();</span><br><span class="line">    let content = document.querySelector(&apos;div&apos;);</span><br><span class="line">    </span><br><span class="line">    function changeBgColor(color) &#123;</span><br><span class="line">        content.style.backgroundColor = color;</span><br><span class="line">    &#125;</span><br><span class="line">    Router.addRoute(&apos;/&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;white&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Router.addRoute(&apos;/blue&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;blue&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    Router.addRoute(&apos;/green&apos;, function() &#123;</span><br><span class="line">        changeBgColor(&apos;green&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router ?"></a>React Router ?</h3><p>完整的 React 路由解决方案</p>
<h4 id="React-Router-简介相关"><a href="#React-Router-简介相关" class="headerlink" title="React Router 简介相关"></a>React Router 简介相关</h4><p>恩，是v4</p>
<blockquote>
<p>3.x 版本相比于 2.x 并没有引入任何新的特性，只是将 2.x 版本中部分废弃 API 的 warning 移除掉而已。V4版本相对V2/V3几乎完全重写了，遵循 Just Component 的 API 设计理念。</p>
</blockquote>
<blockquote>
<p>React Router 保持 UI 与 URL 同步。它拥有简单的 API 与强大的功能。例如代码缓冲加载、动态路由匹配、以及建立正确的位置过渡处理。</p>
</blockquote>
<p>react-router V4 分成了三个包：react-router-dom(for web)、react-router-native(for #native)、react-router(core)。react-router提供核心的路由组件与函数。其余两个则提供运行环境（即浏览器与react-native）所需的特定组件。在浏览器中，我们只需使用react-router-dom。</p>
<p>###主要组件</p>
<h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p>在4.0之前版本的 API 中，Router 组件的 children 只能是 React Router 提供的各种组件，如Route、IndexRoute、Redirect等。而在 React Router 4 中，你可以将各种组件及标签放进 Router组件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 示例1</span><br><span class="line">&lt;Router&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">        &lt;li&gt;&lt;Link to=&quot;/topics&quot;&gt;主题列表&lt;/Link&gt;&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">      &lt;Route path=&quot;/topics&quot; component=&#123;Topics&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br></pre></td></tr></table></figure>
<p>Router是所有路由组件共用的底层接口，一般我们的应用并不会使用这个接口，而是使用高级的路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;：使用 HTML5 提供的 history API 来保持 UI 和 URL 的同步；</span><br><span class="line">&lt;HashRouter&gt;：使用 URL 的 hash (例如：window.location.hash) 来保持 UI 和 URL 的同步；</span><br><span class="line">&lt;MemoryRouter&gt;：能在内存保存你 “URL” 的历史纪录(并没有对地址栏读写)；</span><br><span class="line">&lt;NativeRouter&gt;：为使用React Native提供路由支持；</span><br><span class="line">&lt;StaticRouter&gt;：从不会改变地址；</span><br></pre></td></tr></table></figure>
<p>TIPS：和之前的Router不一样，这里<router>组件下只允许存在一个子元素</router></p>
<h3 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h3><p>Route组件主要的作用就是当一个location匹配路由的path时，渲染某些UI。如果不匹配，路由不会进行任何操作。<br><br></p>
<p>Route 组件有如下属性：</p>
<blockquote>
</blockquote>
<p>path（string）: 路由匹配路径。（没有path属性的Route 总是会 匹配）；<br>exact（bool）：为true时，则要求路径与location.pathname必须完全匹配；<br>strict（bool）：true的时候，有结尾斜线的路径只能匹配有斜线的location.pathname；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/hello(/:name)&quot;&gt;</span><br><span class="line">// 匹配 /hello</span><br><span class="line">// 匹配 /hello/michael</span><br><span class="line">// 匹配 /hello/ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*.*&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/files/*&quot;&gt;</span><br><span class="line">// 匹配 /files/ </span><br><span class="line">// 匹配 /files/a</span><br><span class="line">// 匹配 /files/a/b</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/**/*.jpg&quot;&gt;</span><br><span class="line">// 匹配 /files/hello.jpg</span><br><span class="line">// 匹配 /files/path/to/file.jpg</span><br></pre></td></tr></table></figure>
<p><img src="/.io//pipeiguize.png" alt></p>
<h5 id="匹配路径"><a href="#匹配路径" class="headerlink" title="匹配路径"></a>匹配路径</h5><p>path-to-regexp包用来决定route元素的path参数与当前location是否匹配。它将路径字符串编译成正则表达式，并与当前location的路径名进行匹配比较。<br>当路由地址匹配成功后，会创建一个含有以下属性的match对象：</p>
<blockquote>
<p>url ：与当前location路径名所匹配部分</p>
</blockquote>
<blockquote>
<p>path ：路由的地址</p>
</blockquote>
<blockquote>
<p>isExact ：path 是否等于 pathname</p>
</blockquote>
<blockquote>
<p>params ：从path-to-regexp获取的路径中取出的值都被包含在这个对象中</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&apos;/roster&apos;/&gt;</span><br><span class="line">// 当路径名为&apos;/&apos;时, path不匹配</span><br><span class="line">// 当路径名为&apos;/roster&apos;或&apos;/roster/2&apos;时, path匹配</span><br><span class="line">// 当你只想匹配&apos;/roster&apos;时，你需要使用&quot;exact&quot;参数</span><br><span class="line">// 则路由仅匹配&apos;/roster&apos;而不会匹配&apos;/roster/2&apos;</span><br><span class="line">&lt;Route exact path=&apos;/roster&apos;/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：在匹配路由时，React Router只关注location的路径名。当URL如下时：<br>http:/xxx/xx/x/a?extra=false<br>React Router去匹配的只是’/xxx/xx/x/a’这一部分。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/news&quot; component=&#123;News&#125;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/Router&gt;</span><br><span class="line"></span><br><span class="line">// 如果应用的地址是/,那么相应的UI会类似这个样子：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Home/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 如果应用的地址是/news,那么相应的UI就会成为这个样子：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;News/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>新版的路由为Route提供了三种渲染内容的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route component&gt;：在地址匹配的时候React的组件才会被渲染，route props也会随着一起被渲染；</span><br><span class="line">&lt;Route render&gt;：这种方式对于内联渲染和包装组件却不引起意料之外的重新挂载特别方便；</span><br><span class="line">&lt;Route children&gt;：与render属性的工作方式基本一样，除了它是不管地址匹配与否都会被调用；</span><br><span class="line">?</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 行内渲染示例</span><br><span class="line">&lt;Route path=&quot;/home&quot; render=&#123;() =&gt; &lt;div&gt;Home&lt;/div&gt;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// 包装/合成</span><br><span class="line">const FadingRoute = (&#123; component: Component, ...rest &#125;) =&gt; (</span><br><span class="line">  &lt;Route &#123;...rest&#125; render=&#123;props =&gt; (</span><br><span class="line">    &lt;FadeIn&gt;</span><br><span class="line">      &lt;Component &#123;...props&#125;/&gt;</span><br><span class="line">    &lt;/FadeIn&gt;</span><br><span class="line">  )&#125;/&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&lt;FadingRoute path=&quot;/cool&quot; component=&#123;Something&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>Route component 的优先级要比 Route render高，所以不要在同一个Route中同时使用这两个属性。</p>
<blockquote>
<p>最后：你可以把Route组件放在任意你想要路由渲染的地方</p>
</blockquote>
<p>###Link<br>重点看下组件属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to（string/object）：要跳转的路径或地址；</span><br><span class="line">replace（bool）：为 true 时，点击链接后将使用新地址替换掉访问历史记录里面的原地址；为 false 时，点击链接后将在原有访问历史记录的基础上添加一个新的纪录。默认为 false；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Link组件示例</span><br><span class="line"></span><br><span class="line">// to为string</span><br><span class="line">&lt;Link to=&quot;/about&quot;&gt;关于&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">// to为obj</span><br><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">  pathname: &apos;/courses&apos;,</span><br><span class="line">  search: &apos;?sort=name&apos;,</span><br><span class="line">  hash: &apos;#the-hash&apos;,</span><br><span class="line">  state: &#123; fromDashboard: true &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br><span class="line"></span><br><span class="line">// replace </span><br><span class="line">&lt;Link to=&quot;/courses&quot; replace /&gt;</span><br></pre></td></tr></table></figure>
<p>###NavLink<br>NavLink是Link的一个特定版本, 会在匹配上当前 URL 的时候会给已经渲染的元素添加样式参数，组件属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">activeClassName（string）：设置选中样式，默认值为 active；</span><br><span class="line">activeStyle（object）：当元素被选中时, 为此元素添加样式；</span><br><span class="line">exact（bool）：为 true 时, 只有当地址完全匹配 class 和 style 才会应用；</span><br><span class="line">strict（bool）：为 true 时，在确定位置是否与当前 URL 匹配时，将考虑位置 pathname 后的斜线；</span><br><span class="line">isActive（func）：判断链接是否激活的额外逻辑的功能；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// activeClassName选中时样式为selected</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeClassName=&quot;selected&quot;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 选中时样式为activeStyle的样式设置</span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/faq&quot;</span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    fontWeight: &apos;bold&apos;,</span><br><span class="line">    color: &apos;red&apos;</span><br><span class="line">   &#125;&#125;</span><br><span class="line">&gt;FAQs&lt;/NavLink&gt;</span><br><span class="line"></span><br><span class="line">// 当event id为奇数的时候，激活链接</span><br><span class="line">const oddEvent = (match, location) =&gt; &#123;</span><br><span class="line">  if (!match) &#123;</span><br><span class="line">    return false</span><br><span class="line">  &#125;</span><br><span class="line">  const eventID = parseInt(match.params.eventID)</span><br><span class="line">  return !isNaN(eventID) &amp;&amp; eventID % 2 === 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink</span><br><span class="line">  to=&quot;/events/123&quot;</span><br><span class="line">  isActive=&#123;oddEvent&#125;</span><br><span class="line">&gt;Event 123&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h3><p>该组件用来渲染匹配地址的第一个Route或者Redirect。那么它与使用一堆route又有什么区别呢？</p>
<p>Switch的独特之处是独它仅仅渲染一个路由。相反地，每一个包含匹配地址(location)的 Route都会被渲染。思考下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">&lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">&lt;Route component=&#123;NoMatch&#125;/&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果现在的URL是/about，那么 About,  User, 还有 NoMatch都会被渲染，因为它们都与路径(path)匹配。这种设计，允许我们以多种方式将多个 Route组合到我们的应用程序中，例如侧栏(sidebars)，面包屑(breadcrumbs)，bootstrap tabs等等。 然而，偶尔我们只想选择一个Route来渲染。如果我们现在处于/about，我们也不希望匹配/:user（或者显示我们的 “404” 页面 ）。以下是使用 Switch 的方法来实现：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">  &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/about&quot; component=&#123;About&#125;/&gt;</span><br><span class="line">  &lt;Route path=&quot;/:user&quot; component=&#123;User&#125;/&gt;</span><br><span class="line">  &lt;Route component=&#123;NoMatch&#125;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>现在，如果我们处于/about，Switch将开始寻找匹配的Route。Route path=”/about”  将被匹配， Switch将停止寻找匹配并渲染About。同样，如果我们处于/michael，User将被渲染。</p>
</blockquote>
<blockquote>
<p>通过Route路由的组件，可以拿到一个match参数，这个参数是一个对象，其中包含几个数据：<br><br>isExact：刚才已经说过这个关键字，表示是为作全等匹配<br>params：path中包含的一些额外数据<br>path：Route组件path属性的值<br>url：实际url的hash值</p>
</blockquote>
<p><img src="/.io//match.png" alt></p>
<p><br></p>
<p>###v3 与 v4 的一些区别<br>在react-router v3中，仅有一个Router 组件，需要提供 history 对象作为他的属性 (prop)。</p>
<p>此外，可以使用 routes 作为 Router 的属性 (prop) 或者作为 children 的方式来定义程序的路由结构。</p>
<p>在v4中，没有集中的路由配置。任何需要根据路由渲染内容的地方，只需渲染一个 Route 组件  router 组件只能被赋予一个子元素</p>
<p>react-router v3 提供 onEnter, onUpdate, and onLeave 方法。这些方法本质上是重写（覆盖）了 react 生命周期方法。使用 v4，你将会使用生命周期方法 通过 Route 渲染的组件，你可以使用 componentDidMount 或 componentWillMount 代替 onEnter，你可以使用 componentDidUpdate 或者 componentWillUpdate (更或者 componentWillReceiveProps) 代替 onUpdate，你可以使用 componentWillUnmount 代替 onLeave。</p>
<p>v4 的Switch组件，当 Switch 被渲染时，它仅会渲染与当前路径匹配的第一个子 Route。</p>
<p>…<br>还有很多区别</p>
<h3 id="and"><a href="#and" class="headerlink" title="and"></a>and</h3><p><a href="http://www.baidu.com/link?url=iUqZ8qoki-EPuX4LUXguiJ148mao0sYdb0qjVExb8eHXw_LtydvYYEMBWSzuLuLtupDvzONFn7YlZyyKNLJ8Aq" target="_blank" rel="noopener">麻烦的按需加载</a></p>
<p><a href="https://github.com/cheft/minrouter" target="_blank" rel="noopener">minrouter</a> 用于同构javaScript Web应用程序的微型中间件路由器</p>
<p><a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">React Router 中文</a></p>
<p><a href="https://www.zcfy.cc/article/react-router-v4-the-complete-guide-mdash-sitepoint-4448.html" target="_blank" rel="noopener">React Router v4 版本 完全指北</a></p>
<p><a href="https://github.com/YutHelloWorld/Blog/issues/4" target="_blank" rel="noopener">v2 v3 到 v4 版本的迁移</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/04/12/关于前端路由的一些事/" data-id="ck9dloq1n001mwao7orrlhc57" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-visual-dom" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/05/visual-dom/" class="article-date">
  <time datetime="2018-03-05T15:48:14.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/visual-dom/">visual dom</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####引言<br>我们知道，DOM 操作真正的问题在于每次操作都会触发布局的改变、DOM树的修改和渲染。所以，当你一个接一个地去修改30个节点的时候，就会引起N次（潜在的）布局重算，N次（潜在的）重绘，等等。</p>
<h4 id="二、什么是虚拟DOM？"><a href="#二、什么是虚拟DOM？" class="headerlink" title="二、什么是虚拟DOM？"></a>二、什么是虚拟DOM？</h4><p>虚拟DOM是在DOM的基础上建立了一个抽象层，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟DOM，最后再批量同步到DOM中。</p>
<p>Virtual DOM 实际上没有使用什么全新的技术，仅仅是把 “ 双缓冲（double buffering）” 技术应用到了DOM上面。<br>这样一来，当你在这个单独的虚拟的DOM树上也一个接一个地修改30个节点的时候，它不会每次都去触发重绘，所以修改节点的开销就变小了。<br>之后，一旦你要把这些改动传递给真实DOM，之前所有的改动就会整合成一次DOM操作。这一次DOM操作引起的布局计算和重绘可能会更大，但是相比而言，整合起来的改动只做一次，减少了（多次）计算。</p>
<p>虚拟DOM是React等的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟DOM来确保只对界面上真正变化的部分进行实际的DOM操作。</p>
<p><img src="/.io//20170504161311010.png" alt><br><br><br><br><br><img src="/.io//20170504161319670.png" alt></p>
<p><br></p>
<p>innerHTML：render html字符串 + 重新创建所有 DOM 元素</p>
<p>虚拟DOM：render 虚拟DOM + diff + 更新必要的 DOM 元素</p>
<p><br></p>
<h4 id="虚拟DOM的优点："><a href="#虚拟DOM的优点：" class="headerlink" title="虚拟DOM的优点："></a>虚拟DOM的优点：</h4><p>最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染。</p>
<p>####虚拟DOM的缺点：<br>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h4><p>React会在内存中维护一个虚拟DOM树，对这个树进行读或写，实际上是对虚拟DOM进行。当数据变化时，会自动更新虚拟DOM，然后将新的虚拟DOM和旧的虚拟DOM进行对比，找到变更的部分，得出一个diff，然后将diff放到一个队列里，最终批量更新这些diff到DOM中。</p>
<h6 id="步骤一：用JS对象模拟DOM树"><a href="#步骤一：用JS对象模拟DOM树" class="headerlink" title="步骤一：用JS对象模拟DOM树 "></a>步骤一：用JS对象模拟DOM树 <br></h6><h6 id="步骤二：比较两棵虚拟DOM树的差异"><a href="#步骤二：比较两棵虚拟DOM树的差异" class="headerlink" title="步骤二：比较两棵虚拟DOM树的差异"></a>步骤二：比较两棵虚拟DOM树的差异<br></h6><h6 id="步骤三：把差异应用到真正的DOM树上"><a href="#步骤三：把差异应用到真正的DOM树上" class="headerlink" title="步骤三：把差异应用到真正的DOM树上 "></a>步骤三：把差异应用到真正的DOM树上 <br></h6><p><img src="/.io//20170504161331322.png" alt></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//模拟dom</span><br><span class="line">function Element(tagName, props, children) &#123;</span><br><span class="line">  this.tagName = tagName</span><br><span class="line">  this.props = props</span><br><span class="line">  this.children = children</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = function (tagName, props, children) &#123;</span><br><span class="line">  return new Element(tagName, props, children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//渲染</span><br><span class="line">Element.prototype.render = function () &#123;</span><br><span class="line">  var el = document.createElement(this.tagName) // 根据tagName构建</span><br><span class="line">  var props = this.props</span><br><span class="line"></span><br><span class="line">  for (var propName in props) &#123; // 设置节点的DOM属性</span><br><span class="line">    var propValue = props[propName]</span><br><span class="line">    el.setAttribute(propName, propValue)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var children = this.children || []</span><br><span class="line"></span><br><span class="line">  children.forEach(function (child) &#123;</span><br><span class="line">    var childEl = (child instanceof Element)</span><br><span class="line">      ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点</span><br><span class="line">      : document.createTextNode(child) // 如果字符串，只构建文本节点</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  return el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p></p><p style="color:blue;">例如上面的 DOM 结构就可以简单的表示：</p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var el = require(&apos;./element&apos;);</span><br><span class="line">var ul = el(&apos;ul&apos;, &#123;id: &apos;list&apos;&#125;, [</span><br><span class="line">  el(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 1&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 2&apos;]),</span><br><span class="line">  el(&apos;li&apos;, &#123;class: &apos;item&apos;&#125;, [&apos;Item 3&apos;])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p></p>
<p>注：在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比，上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。</p>
<p><img src="/.io//6d64b0b7889e7f020bb020aea5947a09_hd.jpg" alt></p>
<h4 id="1-深度优先遍历，记录差异"><a href="#1-深度优先遍历，记录差异" class="headerlink" title="(1)深度优先遍历，记录差异"></a>(1)深度优先遍历，记录差异</h4><p><img src="/.io//c4ba535164d29fd46383d19512c37349_hd.jpg" alt></p>
<p>在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">// diff 函数，对比两棵树</span><br><span class="line">function diff (oldTree, newTree) &#123;</span><br><span class="line">  var index = 0 // 当前节点的标志</span><br><span class="line">  var patches = &#123;&#125; // 用来记录每个节点差异的对象</span><br><span class="line">  dfsWalk(oldTree, newTree, index, patches)</span><br><span class="line">  return patches</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对两棵树进行深度优先遍历</span><br><span class="line">function dfsWalk (oldNode, newNode, index, patches) &#123;</span><br><span class="line">  // 对比oldNode和newNode的不同，记录下来</span><br><span class="line">  patches[index] = [...]</span><br><span class="line"></span><br><span class="line">  diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历子节点</span><br><span class="line">function diffChildren (oldChildren, newChildren, index, patches) &#123;</span><br><span class="line">  var leftNode = null</span><br><span class="line">  var currentNodeIndex = index</span><br><span class="line">  oldChildren.forEach(function (child, i) &#123;</span><br><span class="line">    var newChild = newChildren[i]</span><br><span class="line">    currentNodeIndex = (leftNode &amp;&amp; leftNode.count) // 计算节点的标识</span><br><span class="line">      ? currentNodeIndex + leftNode.count + 1</span><br><span class="line">      : currentNodeIndex + 1</span><br><span class="line">    dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点</span><br><span class="line">    leftNode = child</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####(2)差异类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//替换</span><br><span class="line">var REPLACE = 0;</span><br><span class="line">//排序</span><br><span class="line">var REORDER = 1;</span><br><span class="line">//属性变化</span><br><span class="line">var PROPS = 2;</span><br><span class="line">//文本</span><br><span class="line">var TEXT = 3;</span><br></pre></td></tr></table></figure></p>
<p>#####(3)列表对比算法</p>
<p>疑问：什么是DOM Diff算法 ？<br>Web界面由DOM树来构成，当其中某一部分发生变化时，其实就是对应的某个DOM节点发生了变化。在React中，构建UI界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由React来比较两个界面的区别，这就需要对DOM树进行Diff算法分析。</p>
<p>即给定任意两棵树，找到最少的转换步骤。但是标准的的Diff算法复杂度需要O(n^3)，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度直接降低到O(n)</p>
<p>1、两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；<br>2、对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</p>
<p></p><h4>逐层进行节点比较</h4><br>在React中，树的算法其实非常简单，那就是两棵树只会对同一层次的节点进行比较.<br><img src="/.io//0909000.png" alt><p></p>
<p>React只会对相同颜色方框内的DOM节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个DOM树的比较。</p>
<h3>例如：</h3>

<p><img src="/.io//0909001.png" alt></p>
<p>A节点被整个移动到D节点下，直观的考虑DOM Diff操作应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.parent.remove(A); </span><br><span class="line">D.append(A);</span><br></pre></td></tr></table></figure>
<p>但因为React只会简单的考虑同层节点的位置变换，对于不同层的节点，只有简单的创建和删除。当根节点发现子节点中A不见了，就会直接销毁A；而当D发现自己多了一个子节点A，则会创建一个新的A作为子节点。因此对于这种结构的转变的实际操作是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A.destroy();</span><br><span class="line">A = new A();</span><br><span class="line">A.append(new B());</span><br><span class="line">A.append(new C());</span><br><span class="line">D.append(A);</span><br></pre></td></tr></table></figure>
<h3>list-diff2算法 简介</h3>

<pre><code>oldList = [{id: 1}, {id: 2}, {id: 3}, {id: 4}, {id: 5}, {id: 6}];
newList = [{id: 2}, {id: 3}, {id: 1},];

var moves = diff(oldList, newList, &quot;id&quot;);

// children 是源列表 根据 新列表返回 移动或新增的数据。
// children = [
//     {id: 1},
//     {id: 2},
//     {id: 3},
//     null,
//     null,
//     null
// ]
// moves 是源列表oldList 根据新列表newList 返回的操作，children为null的话，依次删除掉掉，因此返回的是
// type = 0 是删除操作， type = 1 是新增操作
// moves = [
//     {type: 0, index:3},
//     {type: 0, index: 3},
//     {type: 0, index: 3},
//     {type: 0, index: 0},
//     {type: 1, index: 2, item: {id: 1}}
// ]
</code></pre><p><a href="https://www.npmjs.com/package/list-diff2" target="_blank" rel="noopener">npm 库</a></p>
<p>#####（4）把差异应用到真正的DOM树上<br>见代码</p>
<p><br><br><br><br><br></p>
<h4 id="对虚拟DOM的误解"><a href="#对虚拟DOM的误解" class="headerlink" title="对虚拟DOM的误解"></a>对虚拟DOM的误解</h4><p>React等从来没有说过 “React 比原生操作DOM快”。React给我们的保证是，在不需要手动优化的情况下，它依然可以给我们提供过得去的性能。</p>
<p>React掩盖了底层的DOM操作，可以用更声明式的方式来描述我们目的，从而让代码更容易维护。</p>
<p>没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。</p>
<p>####还有<br>虚拟dom并没有比直接原生操作更快, 所谓”快”是有条件的<br>比如改变个颜色, 直接操作dom会更快.如果每次都是改变该改变的。那dom操作永远比虚拟dom快.但如果你的改动的地方很多, 而且要保持状态, 那虚拟dom的自动diff无疑会省心.<br>如果有很多复杂的操作，A+B+C, 这时候你要直接操作dom会很繁琐.<br>而且虚拟dom的核心在于diff, 它自动帮你计算那些应该调整, 然后只修改该修改的区域, 省下的不是运行速度这种速度, 而且我们开发方面的一些速度。以及运维的速度。其次，如果任何一点的变化都需要重新渲染整个应用，如果是真实DOM的话，这样的性能是不能接受的</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/03/05/visual-dom/" data-id="ck9dloq180012wao7vozxg0r1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-几个简单排序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/01/几个简单排序/" class="article-date">
  <time datetime="2018-03-01T04:12:00.000Z" itemprop="datePublished">2018-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/01/几个简单排序/">几个简单排序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>####1.快速排序</p>
<p>基本思想：<br>1）选择一个基准元素,通常选择第一个元素或者最后一个元素,<br>2）通过一趟排序讲待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的 元素值比基准值大。<br>3）此时基准元素在其排好序后的正确位置<br>4）然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">    //如果数组&lt;=1,则直接返回</span><br><span class="line">    if (arr.length &lt;= 1) &#123; return arr; &#125;</span><br><span class="line">    var pivotIndex = Math.floor(arr.length / 2);</span><br><span class="line">    //找基准，并把基准从原数组删除</span><br><span class="line">    var pivot = arr.splice(pivotIndex, 1)[0];</span><br><span class="line">    //定义左右数组</span><br><span class="line">    var left = [];</span><br><span class="line">    var right = [];</span><br><span class="line"></span><br><span class="line">    //比基准小的放在left，比基准大的放在right</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //递归</span><br><span class="line">    return quickSort(left).concat([pivot], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = quickSort([0, 33, 43, 32, 39, 2]);</span><br><span class="line">// console.log(a);</span><br></pre></td></tr></table></figure>
<p>2 插入排序<br>基本思想:<br>将一个记录插入到已排序好的有序表中，从而得到一个新，记录数增1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后从第2个记录逐个进行插入，直至整个序列有序为止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function sort(elements) &#123;</span><br><span class="line">    //假设第0个元素是一个有序的数列，第1个以后的是无序的序列，</span><br><span class="line">    //所以从第1个元素开始将无序数列的元素插入到有序数列中</span><br><span class="line">    for (var i = 1; i &lt; elements.length; i++) &#123;</span><br><span class="line">        //升序</span><br><span class="line">        if (elements[i] &lt; elements[i - 1]) &#123;</span><br><span class="line">            //取出无序数列中的第i个作为被插入元素</span><br><span class="line">            var guard = elements[i];</span><br><span class="line">            //记住有序数列的最后一个位置，并且将有序数列位置扩大一个</span><br><span class="line">            var j = i - 1;</span><br><span class="line">            elements[i] = elements[j];</span><br><span class="line"></span><br><span class="line">            //比大小，找到被插入元素所在的位置</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; guard &lt; elements[j]) &#123;</span><br><span class="line">                elements[j + 1] = elements[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            // console.log(j + 1, &apos;ssss&apos;)</span><br><span class="line">            //插入</span><br><span class="line">            elements[j + 1] = guard;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var elements = [10, 9, 8, 7, 6, 5];</span><br><span class="line"></span><br><span class="line">// 8 9 10   9</span><br><span class="line">// 8 9 10 10</span><br><span class="line">// console.log(&apos;before: &apos; + elements);</span><br><span class="line">// sort(elements);</span><br><span class="line">// console.log(&apos; after: &apos; + elements);</span><br></pre></td></tr></table></figure>
<p>####3.选择排序<br>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法（比如序列[5， 5， 3]第一次就将第一个[5]与[3]交换，导致第一个5挪动到第二个5后面）。</p>
<p><code></code><br>var example = [8, 94, 15, 88, 55, 76, 21, 39];<br>function selectSort(arr) {<br>    var len = arr.length;<br>    var minIndex, temp;<br>    // console.time(‘选择排序耗时’);<br>    for (i = 0; i &lt; len - 1; i++) {<br>        minIndex = i;<br>        for (j = i + 1; j &lt; len; j++) {<br>            if (arr[j] &lt; arr[minIndex]) {<br>                minIndex = j;<br>            }<br>        }<br>        temp = arr[i];<br>        arr[i] = arr[minIndex];<br>        arr[minIndex] = temp;<br>    }<br>    // console.timeEnd(‘选择排序耗时’);<br>    return arr;<br>}<br>// console.log(selectSort(example));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####4.希尔排序</span><br><span class="line">希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的加强版。</span><br><span class="line">希尔排序的基本思想：</span><br><span class="line">把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。</span><br><span class="line">随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。</span><br><span class="line"></span><br><span class="line">希尔排序：http://blog.csdn.net/morewindows/article/details/6668714</span><br></pre></td></tr></table></figure></p>
<p>var arr1 = [2, 5, 1, 9, 0];<br>function shellSort(arr) {<br>    var gap = Math.floor(arr.length / 2);<br>    while (gap &gt;= 1) {<br>        for (var i = gap; i &lt; arr.length; i++) {<br>            var j, temp = arr[i];<br>            for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; arr[j]; j = j - gap) {<br>                arr[j + gap] = arr[j];<br>            }<br>            arr[j + gap] = temp;<br>        }<br>        // console.log(“gap=” + gap);<br>        // console.log(arr);<br>        gap = Math.floor(gap / 2);<br>    }<br>}<br>shellSort(arr1);</p>
<p>var arr1 = [2, 5, 1, 9, 0, 10];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5.归并排序</span><br><span class="line">归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。</span><br><span class="line">如　设有数列&#123;6，202，100，301，38，8，1&#125;</span><br><span class="line">初始状态：6,202,100,301,38,8,1</span><br><span class="line">第一次归并后：&#123;6,202&#125;,&#123;100,301&#125;,&#123;8,38&#125;,&#123;1&#125;，比较次数：3；</span><br><span class="line">第二次归并后：&#123;6,100,202,301&#125;，&#123;1,8,38&#125;，比较次数：4；</span><br><span class="line">第三次归并后：&#123;1,6,8,38,100,202,301&#125;,比较次数：4；</span><br><span class="line">总的比较次数为：3+4+4=11,；</span><br><span class="line">逆序数为14；</span><br></pre></td></tr></table></figure></p>
<p>function mergeSort(arr) {  //采用自上而下的递归方法<br>    var len = arr.length;<br>    if(len &lt; 2) {<br>        return arr;<br>    }<br>    var middle = Math.floor(len / 2),<br>        left = arr.slice(0, middle),<br>        right = arr.slice(middle);<br>    return merge(mergeSort(left), mergeSort(right));<br>}</p>
<p>function merge(left, right){<br>    var result = [];<br>    while (left.length&gt;0 &amp;&amp; right.length&gt;0) {<br>        if (left[0] &lt;= right[0]) {<br>            result.push(left.shift());<br>        } else {<br>            result.push(right.shift());<br>        }<br>    }<br>    // console.log(left.length, ‘left’)<br>    console.log(right.length, ‘right’)<br>    while (left.length)<br>        result.push(left.shift());</p>
<pre><code>while (right.length)
    result.push(right.shift());

return result;
</code></pre><p>}<br>var a = mergeSort(arr1);<br>console.log(‘a’, a)<br><code>`</code></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/03/01/几个简单排序/" data-id="ck9dloq0a0006wao7reaxkp6y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数组排序几种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/数组排序几种方法/" class="article-date">
  <time datetime="2018-02-27T11:20:47.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/数组排序几种方法/">数组排序几种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##<br>1.遍历数组法<br>最简单的去重方法.<br>实现思路：新建一数组，遍历传入数组，值不在新数组就加入该新数组中；<br>注意点：判断值是否在数组的方法“indexOf”是ECMAScript5 方法，IE8以下不支持，需多写一些兼容低版本浏览器代码</p>
<h3 id="最简单数组去重法"><a href="#最简单数组去重法" class="headerlink" title="最简单数组去重法"></a>最简单数组去重法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function unique1(array)&#123; </span><br><span class="line">	var n = [];</span><br><span class="line">	for(var i = 0; i &lt; array.length; i++)&#123; </span><br><span class="line">		if (n.indexOf(array[i]) == -1) </span><br><span class="line">			n.push(array[i]);</span><br><span class="line">	&#125; </span><br><span class="line">	return n; </span><br><span class="line">&#125; </span><br><span class="line">var a = [2,3,4,3,5,3];</span><br><span class="line">var b = unique1(a);</span><br></pre></td></tr></table></figure>
<p>2.对象键值对法<br>该方法执行的速度比其他任何方法都快，就是占用的内存大一些。<br>实现思路：新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，不是的话给对象新增该键并放入新数组。<br>注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，不同的键可能会被误认为一样；例如： a[1]、a[“1”] 。解决上述问题还是得调用“indexOf”。</p>
<p>###速度最快，占空间最多（空间换时间）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function unique2(array)&#123;</span><br><span class="line">	var n = &#123;&#125;, r = [], len = array.length, val, type;</span><br><span class="line">	for (var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">		val = array[i]; </span><br><span class="line">		type = typeof val; </span><br><span class="line">		if (!n[val]) &#123;</span><br><span class="line">			n[val] = [type];</span><br><span class="line">			r.push(val);</span><br><span class="line">		&#125; else if (n[val].indexOf(type) &lt; 0) &#123; </span><br><span class="line">			n[val].push(type); </span><br><span class="line">			r.push(val); </span><br><span class="line">		&#125; </span><br><span class="line">	&#125;</span><br><span class="line">	return r; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [&#123;a:1,b:2&#125;,&#123;a:1,b:2&#125;,2,&apos;2&apos;,3,4,3,5,3];</span><br><span class="line">var b = unique2(a);</span><br></pre></td></tr></table></figure></p>
<p>3.数组下标判断法<br>还是得调用“indexOf”性能跟方法1差不多，<br>实现思路：如果当前数组的第i项在当前数组中第一次出现的位置不是i，那么表示第i项是重复的，忽略掉。否则存入结果数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function unique3(array)&#123; </span><br><span class="line">	var n = [array[0]]; //结果数组 </span><br><span class="line">	//从第二项开始遍历 </span><br><span class="line">	for(var i = 1; i &lt; array.length; i++) &#123; </span><br><span class="line">		//如果当前数组的第i项在当前数组中第一次出现的位置不是i， </span><br><span class="line">		//那么表示第i项是重复的，忽略掉。否则存入结果数组 </span><br><span class="line">		if (array.indexOf(array[i]) == i) &#123;</span><br><span class="line">			n.push(array[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	return n; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">var a = [2,3,4,3,5,3];</span><br><span class="line">var b = unique3(a);</span><br><span class="line">// console.log(&apos;three:&apos; + b);</span><br></pre></td></tr></table></figure>
<p>4.排序后相邻去除法<br>原生数组的”sort”方法排序结果不怎么靠谱，对于不要求顺序的去重需求没什么问题。<br>实现思路：给传入数组排序，排序后相同值相邻，然后遍历时新数组只加入不与前一值重复的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 将相同的值相邻，然后遍历去除重复值</span><br><span class="line">function unique4(array)&#123;</span><br><span class="line">	array.sort();</span><br><span class="line">	var re=[array[0]];</span><br><span class="line">	for(var i = 1; i &lt; array.length; i++)&#123; </span><br><span class="line">		if( array[i] !== re[re.length-1])&#123; </span><br><span class="line">			re.push(array[i]); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	return re; </span><br><span class="line">&#125;</span><br><span class="line">var a = [2,3,4,3,3,5,3];</span><br><span class="line">var b = unique4(a);</span><br><span class="line">// console.log(b);</span><br></pre></td></tr></table></figure></p>
<p>5.优化遍历数组法<br>实现思路：获取没重复的最右一值放入新数组。（检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）<br>简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function unique5(array)&#123;</span><br><span class="line">	var r = [];</span><br><span class="line">	for(var i = 0, l = array.length; i &lt; l; i++) &#123;</span><br><span class="line">		// console.log(i);</span><br><span class="line">		for(var j = i + 1; j &lt; l; j++) &#123;</span><br><span class="line">			// console.log(i+&apos;-----&apos;+j);</span><br><span class="line">			if (array[i] === array[j]) &#123;</span><br><span class="line">				i++;</span><br><span class="line">				j = i;</span><br><span class="line">				// j = ++i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		console.log(array[i]);</span><br><span class="line">		r.push(array[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	return r;</span><br><span class="line">&#125;</span><br><span class="line">var a = [2,3,4,3,2,3,5,3];</span><br><span class="line">var b = unique5(a);</span><br><span class="line">console.log(&apos;unique5:&apos;+b);</span><br></pre></td></tr></table></figure></p>
<p>6.删除有重复的元素法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function unique6(array)&#123;</span><br><span class="line">	var arrayN = array.slice();</span><br><span class="line">	for(var i = 0 ; i &lt; arrayN.length; i++) &#123;</span><br><span class="line">		for(var j = i + 1; j &lt; arrayN.length; j++) &#123;</span><br><span class="line">			if (arrayN[i] === arrayN[j]) &#123;</span><br><span class="line">				arrayN.splice(j,1);</span><br><span class="line">				i-- ; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return arrayN; </span><br><span class="line">&#125;</span><br><span class="line">var a = [2,3,4,3,2,3,3,5,3];</span><br><span class="line">var b = unique6(a);</span><br><span class="line">// console.log(&apos;unique6:&apos;+b);</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>$.unique([2,3,4,3,2,3,5,3]);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// var a = [2,3,4,3,2,3,3,5,3];</span><br><span class="line">// var b = $.unique([2,3,4,3,2,3,5,3]);</span><br><span class="line">// console.log(&apos;last:&apos; + b);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>8正则匹配，不适用复杂的数据结构<br>原理基本差不多，效率我还没有验证。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function unique7(array)&#123;</span><br><span class="line">	var rArr = [];</span><br><span class="line">	for(var i = 0,len = array.length;i &lt; len; i++)&#123; </span><br><span class="line">		!RegExp(array[i],&quot;g&quot;).test(rArr.join(&quot;,&quot;)) &amp;&amp; (rArr.push(array[i])); </span><br><span class="line">	&#125;</span><br><span class="line">	return rArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = [2,3,4,3,2,3,3,5,3,&apos;3&apos;];</span><br><span class="line">var b = unique7(a);</span><br><span class="line">// console.log(&apos;unique7: &apos;+ b);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/02/27/数组排序几种方法/" data-id="ck9dloq0g000fwao7trpzrgul" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-关于数组" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/27/关于数组/" class="article-date">
  <time datetime="2018-02-27T09:02:57.000Z" itemprop="datePublished">2018-02-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/27/关于数组/">关于数组Array</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#ABOUT ARRAY</p>
<h4 id="Array构造器"><a href="#Array构造器" class="headerlink" title="Array构造器"></a>Array构造器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Array构造器</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Array</span>(<span class="number">8</span>); <span class="comment">// [undefined × 8]</span></span><br><span class="line"><span class="comment">// 使用对象字面量</span></span><br><span class="line"><span class="keyword">var</span> b = [];</span><br><span class="line">b.length = <span class="number">8</span>; <span class="comment">// [undefined × 8]</span></span><br></pre></td></tr></table></figure>
<h4 id="ES6新增的构造函数方法"><a href="#ES6新增的构造函数方法" class="headerlink" title="ES6新增的构造函数方法"></a>ES6新增的构造函数方法</h4><p>ES6专门扩展了数组构造器Array ，新增2个方法：Array.of、Array.from。</p>
<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.of() // []</span><br><span class="line">Array.of(undefined) // [undefined]</span><br><span class="line">Array.of(1) // [1]</span><br><span class="line">Array.of(1, 2) // [1, 2]</span><br></pre></td></tr></table></figure>
<p>#####Array.from</p>
<p>Array.from方法用于将两类对象转为真正的数组：<br>类似数组的对象  和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。</p>
<p>Array.from的设计初衷是快速便捷的基于其他对象创建新数组，准确来说就是从一个类似数组的可迭代对象创建一个新的数组实例，只要一个对象有迭代器，Array.from就能把它变成一个数组（当然，是返回新的数组，不改变原对象）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    &apos;0&apos;: &apos;a&apos;,</span><br><span class="line">    &apos;1&apos;: &apos;b&apos;,</span><br><span class="line">    &apos;2&apos;: &apos;c&apos;,</span><br><span class="line">    length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br><span class="line"></span><br><span class="line">// ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); // [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;0: &apos;a&apos;, 1: &apos;b&apos;, 2:&apos;c&apos;, length: 3&#125;;</span><br><span class="line">Array.from(obj, (value) =&gt; value.repeat(3));</span><br></pre></td></tr></table></figure>
<h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a>Array.isArray</h5><p>Array.isArray用来判断一个变量是否数组类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array.isArray([]);</span><br></pre></td></tr></table></figure></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>数组原型提供的方法非常多，主要分为三种，一种是会改变自身值的，一种是不会改变自身值的，还有就是遍历方法。<br>由于 Array.prototype 的某些属性被设置为[[DontEnum]]，因此不能用一般的方法进行遍历，我们可以通过如下方式获取 Array.prototype 的所有方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Array.prototy;</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyNames(Array.prototype);</span><br></pre></td></tr></table></figure>
<p>#####改变自身值的方法(9个)<br>改变自身值的方法一共有9个，分别为pop、push、reverse、shift、sort、splice、unshift，以及两个ES6新增的方法copyWithin 和 fill。</p>
<p>#####pop<br>pop()方法删除一个数组中的最后的一个元素，并且返回这个元素。如果是栈的话，这个过程就是栈顶弹出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;, &quot;mouse&quot;];</span><br><span class="line">var item = array.pop();</span><br><span class="line">console.log(array); // [&quot;cat&quot;, &quot;dog&quot;, &quot;cow&quot;, &quot;chicken&quot;]</span><br><span class="line">console.log(item); // mouse</span><br></pre></td></tr></table></figure>
<p>#####push<br>push()方法添加一个或者多个元素到数组末尾，并且返回数组新的长度。如果是栈的话，这个过程就是栈顶压入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;];</span><br><span class="line">var i = array.push(&quot;golfball&quot;);</span><br><span class="line">console.log(array); // [&quot;football&quot;, &quot;basketball&quot;, &quot;volleyball&quot;, &quot;Table tennis&quot;, &quot;badminton&quot;, &quot;golfball&quot;]</span><br><span class="line">console.log(i); // 6</span><br></pre></td></tr></table></figure>
<p>#####reverse<br>reverse()方法颠倒数组中元素的位置，第一个会成为最后一个，最后一个会成为第一个，该方法返回对数组的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5];</span><br><span class="line">var array2 = array.reverse();</span><br><span class="line">console.log(array); // [5,4,3,2,1]</span><br><span class="line">console.log(array2===array); // true</span><br></pre></td></tr></table></figure>
<p>#####shift<br>shift()方法删除数组的第一个元素，并返回这个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5];</span><br><span class="line">var item = array.shift();</span><br><span class="line">console.log(array); // [2,3,4,5]</span><br><span class="line">console.log(item); //</span><br></pre></td></tr></table></figure>
<p>#####sort<br>sort()方法对数组元素进行排序，并返回这个数组。</p>
<p>参数可选，如果省略，数组元素将按照各自转换为字符串的Unicode位点顺序排序，例如”Boy”将排到”apple”之前。当对数字排序的时候，25将会排到8之前，因为转换为字符串后，”25”将比”8”靠前。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;apple&quot;,&quot;Boy&quot;,&quot;Cat&quot;,&quot;dog&quot;];</span><br><span class="line">var array2 = array.sort();</span><br><span class="line">console.log(array); // [&quot;Boy&quot;, &quot;Cat&quot;, &quot;apple&quot;, &quot;dog&quot;]</span><br><span class="line">console.log(array2 == array); // true</span><br><span class="line">array = [10, 1, 3, 20];</span><br><span class="line">var array3 = array.sort();</span><br><span class="line">console.log(array3); // [1, 10, 20, 3]</span><br></pre></td></tr></table></figure>
<p>如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">若 comparefn(a, b) &lt; 0，那么a将排到b前面；</span><br><span class="line">若 comparefn(a, b) = 0，那么a和b相对位置不变；</span><br><span class="line">若 comparefn(a, b) &gt; 0，那么a,b将调换位置；</span><br></pre></td></tr></table></figure>
<p>#####splice<br>splice()方法用新元素替换旧元素的方式来修改数组。</p>
<p>语法：arr.splice(start,deleteCount[, item1[, item2[, …]]])<br>start指定从哪一位开始修改内容。如果超过了数组长度，则从数组末尾开始添加内容；如果是负值，则其指定的索引位置等同于length+start，表示从数组末尾开始的第 -start 位。</p>
<p>deleteCount:指定要删除的元素个数，若等于0，则不删除。这种情况下，至少应该添加一位新元素，若大于start之后的元素总和，则start及之后的元素都将被删除。</p>
<p>itemN: 指定新增的元素，如果缺省，则该方法只删除数组元素。</p>
<p>返回值: 由原数组中被删除元素组成的数组，如果没有删除，则返回一个空数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;apple&quot;,&quot;boy&quot;, &quot;girl&quot;];</span><br><span class="line">var splices = array.splice(1,1);</span><br><span class="line">console.log(array); //  [&quot;apple&quot;, &quot;girl&quot;]</span><br><span class="line">console.log(splices); // [&quot;boy&quot;] 可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span><br><span class="line"></span><br><span class="line">array = [&quot;apple&quot;,&quot;boy&quot;];</span><br><span class="line">splices = array.splice(2,1,&quot;cat&quot;);</span><br><span class="line">console.log(array); // [&quot;apple&quot;, &quot;boy&quot;, &quot;cat&quot;]</span><br><span class="line">console.log(splices); // [], 可见由于start超过数组长度,此时从数组末尾开始添加元素,并且原数组不会发生删除行为</span><br></pre></td></tr></table></figure>
<p>如果需要删除数组中一个已存在的元素，可参考:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;];</span><br><span class="line">array.splice(array.indexOf(&apos;b&apos;),1);</span><br></pre></td></tr></table></figure>
<p>#####unshift</p>
<p>unshift() 方法用于在数组开始处插入一些元素，并返回数组新的长度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span><br><span class="line">var length = array.unshift(&quot;yellow&quot;);</span><br><span class="line">console.log(array); // [&quot;yellow&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span><br><span class="line">console.log(length); // 4</span><br></pre></td></tr></table></figure>
<p>#####copyWithin(ES6)<br>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。使用这个方法，会修改当前数组。</p>
<p>它接受三个参数。<br>target（必需）：从该位置开始替换数据。<br>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。<br>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数</p>
<p>从target位置开始替换成从start 到end 的数据。</p>
<p>Array.prototype.copyWithin(target, start = 0, end = this.length)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line">var array2 = array.copyWithin(0,3);</span><br><span class="line">console.log(array===array2,array2); // true [4, 5, 3, 4, 5]</span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line">console.log(array.copyWithin(0,3,4)); // [4, 2, 3, 4, 5]</span><br><span class="line">var array = [1,2,3,4,5]; </span><br><span class="line">console.log(array.copyWithin(0,-2,-1)); // [4, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<p>#####fill(ES6)</p>
<p>fill()基于ES6，fill方法使用给定值，填充一个数组。它同样用于数组元素替换，但与copyWithin略有不同，它主要用于将数组指定区间内的元素替换为某个值。<br>语法：arr.fill(value, start[, end = this.length])<br>value 指定被替换的值，start 指定替换元素起始的索引，end 可选，指的是替换元素结束位置的索引。<br>如果start为负，则其指定的索引位置等同于length+start，length为数组的长度。end也是如此。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;].fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">new Array(3).fill(7)</span><br><span class="line">// [7, 7, 7]</span><br><span class="line"></span><br><span class="line">var array = [1,2,3,4,5];</span><br><span class="line">var array2 = array.fill(10,0,3);</span><br><span class="line">console.log(array===array2,array2); // true [10, 10, 10, 4, 5], 可见数组区间[0,3]的元素全部替换为10</span><br><span class="line">// 其他的举例请参考copyWithin</span><br></pre></td></tr></table></figure>
<p>####不会改变自身的方法(9个)<br>不会改变自身的方法一共有9个。分别为concat、join、slice、toString、toLocateString、indexOf、lastIndexOf、未标准的toSource以及ES7新增的方法includes。</p>
<p>#####concat<br>concat() 方法将传入的数组或者元素与原数组合并，组成一个新的数组并返回。<br>语法：arr.concat(value1, value2, …, valueN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 2, 3];</span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">console.log(array); // [1, 2, 3], 原数组并未被修改</span><br></pre></td></tr></table></figure>
<p>复制数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;a: 1&#125;];</span><br><span class="line">var array3 = array.concat();</span><br><span class="line">console.log(array3); // [&#123;a: 1&#125;]</span><br><span class="line">console.log(array3 === array); // false</span><br><span class="line">console.log(array[0] === array3[0]); // true，新旧数组第一个元素依旧共用一个同一个对象的引用</span><br></pre></td></tr></table></figure></p>
<p>链接数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = [1,2], b = [3,4];</span><br><span class="line">[...a, ...b]</span><br></pre></td></tr></table></figure></p>
<p>#####join<br>join() 方法将数组中的所有元素连接成一个字符串。<br>语法：arr.join([separator = ‘,’]) separator可选，缺省默认为逗号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">console.log(array.join()); // a,b,c</span><br><span class="line">console.log(array.join(&apos;+&apos;)); // a+b+c</span><br><span class="line">console.log(array.join(&apos;&apos;)); // abc</span><br></pre></td></tr></table></figure>
<p>####slice<br>slice() 方法将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。<br>语法：arr.slice([start[, end]])<br>参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。<br>如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。<br>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;];</span><br><span class="line">console.log(array.slice()); // [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span><br><span class="line">console.log(array.slice(2,3)); // [&quot;three&quot;]</span><br></pre></td></tr></table></figure></p>
<p>浅复制是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&#123;color:&quot;yellow&quot;&#125;, 2, 3];</span><br><span class="line">var array2 = array.slice(0,1);</span><br><span class="line">console.log(array2); // [&#123;color:&quot;yellow&quot;&#125;]</span><br><span class="line">array[0][&quot;color&quot;] = &quot;blue&quot;;</span><br><span class="line">console.log(array2); // [&#123;color:&quot;bule&quot;&#125;]</span><br></pre></td></tr></table></figure>
<p>#####toString<br>toString()方法返回数组的字符串形式，该字符串由数组中的每个元素的 toString() 返回值经调用join()方法连接（由逗号隔开）组成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;];</span><br><span class="line">var str = array.toString();</span><br><span class="line">console.log(str); // Jan,Feb,Mar,Apr</span><br></pre></td></tr></table></figure>
<p>注：当数组直接和字符串作连接操作时，将会自动调用其toString()方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = [&apos;Jan&apos;, &apos;Feb&apos;, &apos;Mar&apos;, &apos;Apr&apos;] + &apos;,May&apos;;</span><br><span class="line">console.log(str); // &quot;Jan,Feb,Mar,Apr,May&quot;</span><br></pre></td></tr></table></figure>
<p>#####toLocaleString<br>toLocaleString()类似toString()的变型，该字符串由数组中的每个元素toLocaleString()返回值经调用join()方法连接（由逗号隔开）组成。</p>
<p>数组中的元素将调用各自的toLocaleString方法：<br>Object：Object.prototype.toLocaleString()<br>Number：Number.prototype.toLocaleString()<br>Date：Date.prototype.toLocaleString()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var array= [&#123;name:&apos;zz&apos;&#125;, 123, &quot;abc&quot;, new Date()];</span><br><span class="line">var str = array.toLocaleString();</span><br><span class="line">console.log(str); // [object Object],123,abc,2017/9/1 下午1:06:23</span><br></pre></td></tr></table></figure></p>
<p>#####indexOf<br>indexOf() 方法用于查找元素在数组中第一次出现时的索引，如果没有，则返回-1。<br>语法：arr.indexOf(element, fromIndex=0)<br>element 为需要查找的元素。<br>fromIndex 为开始查找的位置，缺省默认为0。如果超出数组长度，则返回-1。如果为负值，假设数组长度为length，则从数组的第 length + fromIndex项开始往数组末尾查找，如果length + fromIndex&lt;0 则整个数组都会被查找。</p>
<p>indexOf使用严格相等（即使用 === 去匹配数组中的元素）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&apos;abc&apos;, &apos;def&apos;, &apos;ghi&apos;,&apos;123&apos;];</span><br><span class="line">console.log(array.indexOf(&apos;def&apos;)); // 1</span><br><span class="line">console.log(array.indexOf(&apos;def&apos;,-1)); // -1 此时表示从最后一个元素往后查找,因此查找失败返回-1</span><br><span class="line">console.log(array.indexOf(&apos;def&apos;,-4)); // 1 由于4大于数组长度,此时将查找整个数组,因此返回1</span><br><span class="line">console.log(array.indexOf(123)); // -1, 由于是严格匹配,因此并不会匹配到字符串&apos;123&apos;</span><br></pre></td></tr></table></figure>
<p>#####lastIndexOf<br>略</p>
<p>#####includes(ES7)<br>includes() 方法基于ES7规范，它用来判断当前数组是否包含某个指定的值，如果是，则返回 true，否则返回 false。<br>语法：arr.includes(element, fromIndex=0)<br>element 为需要查找的元素。<br>fromIndex 表示从该索引位置开始查找 element，缺省为0，它是正向查找，即从索引处往数组末尾查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var array = [0, 1, 2];</span><br><span class="line">console.log(array.includes(0)); // true</span><br><span class="line">console.log(array.includes(1)); // true</span><br><span class="line"></span><br><span class="line">[1, 2, 3].includes(3, 3);  // false</span><br><span class="line">[1, 2, 3].includes(3, -1); // true</span><br><span class="line">[1, 2, NaN].includes(NaN) // true</span><br></pre></td></tr></table></figure>
<p>####遍历方法(12个)<br>基于ES6，不会改变自身的方法一共有12个，分别为forEach、every、some、filter、map、reduce、reduceRight 以及ES6新增的方法entries、find、findIndex、keys、values。</p>
<p>#####entries(ES6)</p>
<p>entries() 方法基于ES6规范，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">var iterator = array.entries();</span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br></pre></td></tr></table></figure>
<p>#####find &amp; findIndex(ES6)<br>find()方法基于ES6规范，返回数组中第一个满足条件的元素（如果有的话），如果没有，则返回undefined。<br>findIndex() 方法也基于ES6规范，它返回数组中第一个满足条件的元素的索引（如果有的话）否则返回-1。</p>
<p>语法：arr.find(fn, thisArg)，arr.findIndex(fn, thisArg)<br>我们发现它们的语法与forEach等十分相似，其实不光语法，find（或findIndex）在参数及其使用注意事项上，均与forEach一致。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var array = [1, 3, 5, 7, 8, 9, 10];</span><br><span class="line">function f(value, index, array)&#123;</span><br><span class="line">  return value%2==0;</span><br><span class="line">&#125;</span><br><span class="line">function f2(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;</span><br><span class="line">&#125;</span><br><span class="line">console.log(array.find(f)); // 8</span><br><span class="line">console.log(array.find(f2)); // undefined</span><br><span class="line">console.log(array.findIndex(f)); // 4</span><br><span class="line">console.log(array.findIndex(f2)); // -1</span><br></pre></td></tr></table></figure>
<p>#####keys(ES6)<br>keys() 方法基于ES6规范，返回一个数组索引的迭代器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line">var iterator = array.keys();</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: 0, done: false&#125;</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: 1, done: false&#125;</span><br><span class="line">console.log(iterator.next()); // Object &#123;value: undefined, done: false&#125;</span><br></pre></td></tr></table></figure>
<p>#####values(ES6)<br>values() 方法基于ES6规范，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。</p>
<p>(遗憾的是，现在没有浏览器实现了该方法)</p>
<p>#####Symbol.iterator(ES6)<br>该方法基于ES6规范，同 values 方法功能相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var array = [&quot;abc&quot;, &quot;xyz&quot;];</span><br><span class="line">var iterator = array[Symbol.iterator]();</span><br><span class="line">console.log(iterator.next().value); // abc</span><br><span class="line">console.log(iterator.next().value); // xyz</span><br></pre></td></tr></table></figure>
<p>####js小实例之数组扁平化<br>？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line">console.log(flatten(arr)) // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 方法 1 地柜</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    var result = [];</span><br><span class="line">    for (var i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (Array.isArray(arr[i])) &#123;</span><br><span class="line">            result = result.concat(flatten(arr[i]))</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result.push(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 方法2 </span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&apos;,&apos;).map(function(item)&#123;</span><br><span class="line">        return item;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 方法3</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 方法4</span><br><span class="line">var arr = [1, [2, [3, 4]]];</span><br><span class="line"></span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line"></span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(flatten(arr))</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/jashkenas/underscore/blob/master/underscore.js#L528" target="_blank" rel="noopener">underscore</a></p>
<p>###JavaScript之数组去重</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">利用indexOf()遍历数组，如果临时数组找不到该元素，则push到临时数组，否则不做处理</span><br><span class="line">function uniqArr1(arr) &#123;</span><br><span class="line">　　var res = [];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 0,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">        if (res.indexOf(arr[i]) == -1) &#123;</span><br><span class="line">          res.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">同样利用indexOf()遍历数组，如果元素首次出现位置和它的索引相等，则说明不是重复元素，push到临时数组，否则不做处理</span><br><span class="line"></span><br><span class="line">function uniqArr2(arr) &#123;</span><br><span class="line">　　var res = [arr[0]];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (arr.indexOf(arr[i]) == i) &#123;</span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">查找第一个index，是否相同index</span><br><span class="line">function removeRepeat(arr)&#123;</span><br><span class="line">  return arr.filter(function(elem, pos) &#123;</span><br><span class="line">    return arr.indexOf(elem) == pos;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;4&quot;,&quot;4&quot;,&quot;4&quot;,&quot;5&quot;);</span><br><span class="line">var newArr = removeRepeat(arr);</span><br><span class="line">console.log(newArr); //1,2,3,4,5</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">利用对象键值唯一性，如果对象没有该属性，则添加该属性，同时将该元素push到临时数组</span><br><span class="line">function uniqArr3(arr) &#123;</span><br><span class="line">　　var obj = &#123;&#125;,</span><br><span class="line">　　res = [];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (!obj[arr[i]]) &#123;</span><br><span class="line">　　　　　　obj[arr[i]] = true;</span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">同样利用对象键值唯一性，唯一不同的地方是这里不再使用临时数组变量，而是利用Object.keys()方法将去重后的结果返回</span><br><span class="line">function uniqArr4(arr) &#123;</span><br><span class="line">　　var obj = &#123;&#125;;</span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (!obj[arr[i]]) &#123;</span><br><span class="line">　　　　　　obj[arr[i]] = true;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　</span><br><span class="line">　　return Object.keys(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">先对原数组进行排序，临时数组先存储第一个元素，然后从第二个元素开始循环判断排序后的原数组(arr)是否与临时数组(res)的第length-1个元素(即res的最后一个元素，也即res每次新添加的元素)是否相等，若不相等，则push到res，这样就确保了每次push到res中的都是不重复的。</span><br><span class="line">function uniqArr5(arr) &#123;</span><br><span class="line">　　arr.sort();</span><br><span class="line">　　var res = [arr[0]];</span><br><span class="line"> </span><br><span class="line">　　for (var i = 1,len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">　　　　if (arr[i] !== res[res.length -1]) &#123;</span><br><span class="line">　　　　　　res.push(arr[i]);</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">　　return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">嵌套循环，如果相等，则截掉后面的，这里要注意splice会影响到原数组，所以这里重新计算了len值和j值。</span><br><span class="line">unction uniqArr6(arr) &#123;</span><br><span class="line">　　var len = arr.length;</span><br><span class="line"> </span><br><span class="line">　　for (var i = 0; i &lt; len; i++) &#123;</span><br><span class="line">　　　　for (var j = i + 1; j &lt; len; j++) &#123;</span><br><span class="line">　　　　　　if (arr[i] === arr[j]) &#123;</span><br><span class="line">　　　　　　　　arr.splice(j, 1);</span><br><span class="line">　　　　　　　　len = arr.length;</span><br><span class="line">　　　　　　　　j--;</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line"> </span><br><span class="line">　　return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ES6新的数据结构set，类似数组，但成员的值都是唯一的，所以利用这个特性可以做到数组去重</span><br><span class="line"></span><br><span class="line">function uniqArr7(arr) &#123;</span><br><span class="line">　　var res = new Set(arr);</span><br><span class="line">　　return [...res];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function unique7 (arr) &#123;</span><br><span class="line">  return Array.from(new Set(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// ES6</span><br><span class="line">function unique8 (arr) &#123;</span><br><span class="line">  const seen = new Map()</span><br><span class="line">  return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2018/02/27/关于数组/" data-id="ck9dloq1m001iwao7grq6j19x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js随机数与简单抽奖" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/10/js随机数与简单抽奖/" class="article-date">
  <time datetime="2017-12-10T02:23:57.000Z" itemprop="datePublished">2017-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/10/js随机数与简单抽奖/">js随机数与简单抽奖</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#####<br>随机数分为三种：真随机数、准随机数、伪随机数。<br>真随机数是属于大自然的，真随机数只能通过随机的物理过程来获取，实际中是很难的。<br>准随机数来自于严格的数学方法，理论上可行，但实际上不可行。</p>
<p>伪随机数，就是假的随机数。因为它是根据某种已知的方法获取随机数，本质上已经去除了真正随机的可能。这种方法一旦重复，则获取到的随机数也会重复。</p>
<p>为什么是伪随机数呢？因为通过这种方式得到的“随机数”都是系统根据公式算出来的！既然是算出来的，那么只要输入的参数一致，那么每次获得的随机数就是同一个。输入的参数我们叫做seed。也就是说，如果程序设计者使用了一个预先确定好的seed来生成随机数，如果抽100次奖，那么这100次中奖的都会是同一个人，或者同一批人。更有甚者，虽然每次使用的seed看似不同，但这批seed会让特定的一部分人中奖概率更大！</p>
<p>真随机数是电脑通过对一些没有规律的自然现象量化后得到的，比如热力学噪声、量子现象等。获取这些真随机数的获取代价显然比用时间做个seed高多了。如果大家觉得年会抽奖的算法有必要使用真随机数，也有办法做到，random.org这个网站就提供了一系列通过“大气噪声”获取随机数序列的在线API，通过这些API获取的随机数序列都是真随机数。</p>
<p>如何产生随机数：产生随机数的方法有很多种，什么斐波那契法、线性同余法、梅森旋转算法Mersenne twister等。</p>
<p>下面简单介绍下。</p>
<p>说到js 的随机数，不得不提的就是Math.random这个方法了。<br>该方法可返回介于 [0 ~ 1) 之间的一个随机数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var r = Math.random(); //生成0-1 的随机数。</span><br></pre></td></tr></table></figure></p>
<p>还有其他简单的方法，简单回顾一下。<br>Math.ceil  //对一个数进行上取整 返回值：返回大于或等于x，并且与之最接近的整数。<br>注：如果x是正数，则把小数“入”；如果x是负数，则把小数“舍”。</p>
<p>Math.floor<br>对一个数进行下取整。 返回值：返回小于或等于x，并且与之最接近的整数。<br>注：如果x是正数，则把小数“舍”；如果x是负数，则把小数“入”。</p>
<p>Math.round  四舍五入取整。</p>
<p>问题: 想求解1-x的随机数<br>var x = 100;<br>// 1.0-x之间的随机数：<br>Math.round(Math.random()*x);</p>
<p>问题：x至y之间的随机数<br>var x = 100;<br>var y = 200;<br>Math.round(Math.random()*(y-x)+x);</p>
<p>还可以通过下面这种方式产生：<br>var r = +new Date();<br>var r = (new Date()-0) % 15;</p>
<p>问题：随机产生六位数字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Num = &quot;&quot;; </span><br><span class="line">for(var i=0;i&lt;6;i++)&#123; </span><br><span class="line">    Num+= Math.floor(Math.random()*10); </span><br><span class="line">&#125;</span><br><span class="line">console.log(Num);</span><br></pre></td></tr></table></figure></p>
<p>问题：随机的token 生成方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var r = Math.random().toString(36).slice(2); </span><br><span class="line">//或者</span><br><span class="line">var r = Math.random().toString(36).slice(7);</span><br><span class="line">console.log(r);</span><br></pre></td></tr></table></figure></p>
<p>but，这样有个问题。<br>for(var i = 0; i&lt; 20; i++){<br>    console.log(Math.random().toString(36).slice(2));<br>}</p>
<p>for(var i = 0; i&lt; 20; i++){<br>    console.log((+new Date()).toString(36));<br>}</p>
<p>问题：如果想不要数字和字母呢？<br>当然是正则了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var r = Math.random().toString(36).replace(/[^a-z]+/g, &apos;&apos;);</span><br><span class="line">//或者这样</span><br><span class="line">var r = Math.random().toString(36).slice(2).replace(/\d/g, &apos;&apos;);</span><br></pre></td></tr></table></figure>
<p>问题：从指定的字符中，抽取某一部分当做随机</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array(20).fill().map(function () &#123;</span><br><span class="line">    return (function (str) &#123;</span><br><span class="line">        return str.charAt(Math.floor(Math.random() * str.length));</span><br><span class="line">    &#125;(&apos;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&apos;));</span><br><span class="line"></span><br><span class="line">&#125;).join(&apos;&apos;);</span><br></pre></td></tr></table></figure>
<p>或者;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function rand(length, current) &#123;</span><br><span class="line">    var str = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;</span><br><span class="line">    current = current ? current : &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    return length ? rand(--length, str.charAt(Math.floor(Math.random() * 60)) + current) : current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然上面的办法bijiaolow</p>
<p>还有下面这种办法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">** randomWord 产生任意长度随机字母数字组合</span><br><span class="line">** randomFlag-是否任意长度 min-任意长度最小位[固定位数] max-任意长度最大位</span><br><span class="line">*/</span><br><span class="line"> </span><br><span class="line">function randomWord(randomFlag, min, max)&#123;</span><br><span class="line">    var str = &quot;&quot;,</span><br><span class="line">        range = min,</span><br><span class="line">        arr = [&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;I&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, &apos;N&apos;, &apos;O&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos;];</span><br><span class="line"> </span><br><span class="line">    // 随机产生</span><br><span class="line">    if(randomFlag)&#123;</span><br><span class="line">        range = Math.round(Math.random() * (max-min)) + min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for(var i=0; i&lt;range; i++)&#123;</span><br><span class="line">        pos = Math.round(Math.random() * (arr.length-1));</span><br><span class="line">        str += arr[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = randomWord(true, 3, 32); //生成3-32位随机串</span><br><span class="line">console.log(str)</span><br><span class="line">randomWord(false, 43); //生成43位随机串</span><br></pre></td></tr></table></figure></p>
<p>问题：产生len长度的字符串<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function generateRandomAlphaNum(len) &#123;</span><br><span class="line">    var rdmString = &quot;&quot;;</span><br><span class="line">    for (; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2));</span><br><span class="line"></span><br><span class="line">    return rdmString.substr(0, len);</span><br><span class="line">&#125;</span><br><span class="line">var str = generateRandomAlphaNum(5);</span><br><span class="line">// console.log(str);</span><br></pre></td></tr></table></figure></p>
<p>看下生成GUID的函数<br>什么是GUID：<br>全局唯一标识符（GUID，Globally Unique Identifier）也称作 UUID(Universally Unique IDentifier) 。</p>
<p>GUID是一种由算法生成的二进制长度为128位的数字标识符。GUID 的格式为“xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx”，其中的 x 是 0-9 或 a-f 范围内的一个32位十六进制数。在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID。</p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function S4() &#123;</span><br><span class="line">    return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);</span><br><span class="line">&#125;</span><br><span class="line">function NewGuid() &#123;</span><br><span class="line">    return (S4() + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + &quot;-&quot; + S4() + S4() + S4());</span><br><span class="line">&#125;</span><br><span class="line">console.log(NewGuid());</span><br></pre></td></tr></table></figure></p>
<p>问题：如果想随机中文呢？<br>我们知道，中文字符的范围是[\u4e00-\u9fa5]</p>
<p>也就是我们常常写的判断是否中文的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (/^[\u4E00-\u9FA5]+$/.test(content)) &#123;</span><br><span class="line">    console.log(&apos;is chinese&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们转化一下为10进制数字</span><br><span class="line">parseInt(&quot;4E00&quot;,16) //19968</span><br><span class="line">parseInt(&quot;9FA5&quot;,16) //40869</span><br><span class="line"></span><br><span class="line">40869-19968 = 20901 可以有这么多了！！！ 基本上够用</span><br><span class="line"></span><br><span class="line">randomHz = function()&#123;</span><br><span class="line">    eval( &quot;var word=&quot; +  &apos;&quot;\\u&apos; + (Math.round(Math.random() * 20901) + 19968).toString(16)+&apos;&quot;&apos;);</span><br><span class="line">    return word;</span><br><span class="line">&#125;</span><br><span class="line">for(i=0;i&lt;100;i++)&#123;</span><br><span class="line">    console.log(randomHz());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>附：<br>下面上几个随机抽奖的小实例，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">let arr  = [</span><br><span class="line">    &#123;</span><br><span class="line">        name: &apos;奖品1&apos;,</span><br><span class="line">        per: 10,</span><br><span class="line">        end: 0,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name: &apos;奖品2&apos;,</span><br><span class="line">        per: 20,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name: &apos;奖品3&apos;,</span><br><span class="line">        per: 30,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name:&apos;谢谢&apos;,</span><br><span class="line">        per: 50,</span><br><span class="line">        times: 0</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let len = 0;</span><br><span class="line">arr.forEach((item, index)=&gt;&#123;</span><br><span class="line">    len += item.per;</span><br><span class="line">    item.end =len;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function draw()&#123;</span><br><span class="line">    let random = parseInt(Math.random() * len);</span><br><span class="line">    for(let i = 0 ; i&lt; arr.length; i++)&#123;</span><br><span class="line">        if(random &lt; arr[i].end)&#123;</span><br><span class="line">            // console.log(arr[i].name);</span><br><span class="line">            arr[i].times ++ ;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// draw();</span><br><span class="line"></span><br><span class="line">for(var j = 0; j &lt; 100000; j++)&#123;</span><br><span class="line">    draw();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(function(item)&#123;</span><br><span class="line">    console.log(item.name, item.times);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">var gifts = [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品1&quot;,</span><br><span class="line">        &quot;prop&quot;:5, </span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品2&quot;,</span><br><span class="line">        &quot;prop&quot;:10,</span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品3&quot;,</span><br><span class="line">        &quot;prop&quot;:40,</span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        &quot;name&quot;:&quot;奖品4&quot;,</span><br><span class="line">        &quot;prop&quot;: 45,</span><br><span class="line">        &quot;times&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line">//抽奖经典算法</span><br><span class="line">function getResult(arr)&#123;</span><br><span class="line">    var leng = 0;</span><br><span class="line">    for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">        leng+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(var i=0; i&lt;arr.length; i++)&#123;</span><br><span class="line">        if(parseInt(Math.random()*leng)&lt;arr[i])&#123;</span><br><span class="line">            gifts[i].times ++;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            leng -= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var gArr = [];</span><br><span class="line">for(var i=0; i&lt; gifts.length; i++)&#123;</span><br><span class="line">    gArr.push(gifts[i][&apos;prop&apos;]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for(var i =0 ; i&lt; 100000; i++)&#123;</span><br><span class="line">    getResult(gArr);</span><br><span class="line">&#125; </span><br><span class="line">gifts.forEach(function(item)&#123;</span><br><span class="line">    console.log(item.times);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// console.log(gifts[getResult(gArr)][&apos;name&apos;]);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">function draw(n = 1)&#123;</span><br><span class="line">    let cards = Array(20).fill().map((_, i)=&gt;i+1);</span><br><span class="line">    let ret = [];</span><br><span class="line">    for(let i = 0; i &lt; n; i++)&#123;</span><br><span class="line">        let idx = Math.floor(cards.length * Math.random());</span><br><span class="line">        ret.push(...cards.splice(idx, 1));</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw(5));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function draw2(amount, n = 1)&#123;</span><br><span class="line">    const cards = Array(amount).fill().map((_, i)=&gt;i+1);</span><br><span class="line"></span><br><span class="line">    for(let i = amount - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">        let rand = Math.floor((i + 1) * Math.random());</span><br><span class="line">        [cards[rand], cards[i]] = [cards[i], cards[rand]];</span><br><span class="line">    &#125;</span><br><span class="line">    return cards.slice(0, n);</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw2(20, 5));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//-----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">function * draw3(amount)&#123;</span><br><span class="line">    const cards = Array(amount).fill().map((_,i)=&gt;i+1);</span><br><span class="line">    for(let i = amount - 1; i &gt;= 0; i--)&#123;</span><br><span class="line">        let rand = Math.floor((i + 1) * Math.random());</span><br><span class="line">        [cards[rand], cards[i]] =  [cards[i], cards[rand]];</span><br><span class="line">        yield cards[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var drawer = draw3(20);</span><br><span class="line">console.log(Array(5).fill().map(()=&gt;drawer.next().value));</span><br><span class="line"></span><br><span class="line">//------------------------------------------------</span><br><span class="line"></span><br><span class="line">//draw4</span><br><span class="line">function draw4(list = [], number = 0) &#123;</span><br><span class="line">    list = list.concat()</span><br><span class="line">    let result = []</span><br><span class="line">    while (number--) &#123;</span><br><span class="line">        result.push(list.splice(Math.floor(Math.random()*list.length), 1)[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw4([1,2,3,4,5,6,7,8,9,10], 5));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//------------------------------------------------</span><br><span class="line"></span><br><span class="line">var arr = Array(20).join(&apos;,&apos;).replace(/\,/g, function(a, b, arr)&#123;</span><br><span class="line">    //a ：元素，b：下标，c:数组</span><br><span class="line">    var n = +b + 1;</span><br><span class="line">    var m = n + (n == arr.length ? &apos;&apos;: &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">    return m;</span><br><span class="line">&#125;).split(&apos;.&apos;);</span><br><span class="line"></span><br><span class="line">function draw5()&#123;</span><br><span class="line">    var rst = function() &#123;</span><br><span class="line">        var r = Math.floor(Math.random() * arr.length);</span><br><span class="line">        return arr.splice(r, 1);</span><br><span class="line">    &#125;;</span><br><span class="line">    return rst;</span><br><span class="line">&#125;</span><br><span class="line">console.log(draw5()(), draw5()(), draw5()(), draw5()(), draw5()());</span><br></pre></td></tr></table></figure>
<div><br>参见： <a href="https://aotu.io/notes/2016/04/14/math-random/" target="_blank" rel="noopener">https://aotu.io/notes/2016/04/14/math-random/&lt;/&gt;<br></a></div>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2017/12/10/js随机数与简单抽奖/" data-id="ck9dloq14000ywao7bdlux1k6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js实现文件上传的几种方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/12/js实现文件上传的几种方式/" class="article-date">
  <time datetime="2017-10-12T05:17:21.000Z" itemprop="datePublished">2017-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/12/js实现文件上传的几种方式/">js实现文件上传的几种方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##文件上传</p>
<p>###准备：</p>
<p><a href="https://imququ.com/post/four-ways-to-post-data-in-http.html" target="_blank" rel="noopener">四种常见的 POST 提交数据方式</a></p>
<p>form可以用以下四种方式发送：<br></p>
<p>POST方法，并设置enctype 属性为 application/x-www-form-urlencoded <br><br>post方法设置 enctype 属性为 text/plain<br><br>post方法，并设置 enctype 属性为 multipart/form-data<br><br>使用get方法<br><br><br></p>
<h3 id="文件、图片上传方式方法与相关。"><a href="#文件、图片上传方式方法与相关。" class="headerlink" title="文件、图片上传方式方法与相关。"></a>文件、图片上传方式方法与相关。</h3><p>###一、传统形式<br>图片、文件上传的传统形式，是使用表单元素file。<br><img src="/.io//filebiaodan.png" alt></p>
<h4 id="二、iframe上传"><a href="#二、iframe上传" class="headerlink" title="二、iframe上传"></a>二、iframe上传</h4><p>思路:<br>    1: 点击”提交”时的瞬间,生成一个iframe对象,插入body中<br><br>    2: 修改form的target ,为iframe的name值<br><br>    3: 给iframe加1个事件 ,onload<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; target=&quot;upfile&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt;</span><br><span class="line">    &lt;br/&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<p>####注意：</p>
<p>1、需要设置iframe的name值与form的target属性值一样，就是把form表单上传文件的刷新转嫁到iframe里去了；</p><br><p>2、form表单的enctype属性值必须设置成multipart/form-data，将文件转换成文件流供后端接收；</p>


<h4 id="三、ajax上传"><a href="#三、ajax上传" class="headerlink" title="三、ajax上传"></a>三、ajax上传</h4><p>HTML5提出了XMLHttpRequest对象的第二版，从此ajax能够上传文件了。这是真正的”异步上传”。用iframe上传，可以用作老式浏览器的替代方案。该方案主要用的是FormData对象，它能够构建类似表单的键值对。用FormData的最大优点就是我们可以异步上传一个二进制文件。</p>
<h6 id="与普通的-Ajax-相比，使用-FormData的最大优点就是我们可以异步上传二进制文件。类似序列化对象"><a href="#与普通的-Ajax-相比，使用-FormData的最大优点就是我们可以异步上传二进制文件。类似序列化对象" class="headerlink" title="与普通的 Ajax 相比，使用 FormData的最大优点就是我们可以异步上传二进制文件。类似序列化对象"></a>与普通的 Ajax 相比，使用 FormData的最大优点就是我们可以异步上传二进制文件。类似序列化对象</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/upload&quot; id=&quot;form&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; id=&quot;File&quot; name=&quot;name1&quot;&gt;</span><br><span class="line">    &lt;div&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var fd = new FormData(document.getElementById(&quot;File&quot;));</span><br><span class="line">    fd.append(&quot;CustomField&quot;, &quot;This is some extra data&quot;);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: &quot;/upload&quot;,</span><br><span class="line">        type: &quot;POST&quot;,</span><br><span class="line">        data: fd,</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h3 id="—-图片上传时，可能会用到一些其他的api"><a href="#—-图片上传时，可能会用到一些其他的api" class="headerlink" title="-—- 图片上传时，可能会用到一些其他的api"></a>-—- 图片上传时，可能会用到一些其他的api</h3><p>###关于FileReader<br>FileReader是html5为我们提供的读取文件的api。它的作用就是把文本流按指定格式读取到缓存，以供js调用。</p>
<p>FileReader有四种读取文件的方式：<br><br>1.readAsBinaryString读取为二进制码<br><br>2.readAsDataURL读取为DataURL<br><br>3.readAsText读取为文本<br><br>4.readAsArrayBuffer<br></p>
<p><img src="/.io//doc.png" alt></p>
<p>#####举例，预览图片<br><img src="/.io//reader.png" alt></p>
<p>文件一旦开始读取，无论成功或失败，实例的 result 属性都会被填充。如果读取失败，则 result 的值为 null ，否则即是读取的结果</p>
<p>#####举例，其他类型文件，实现进度条</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=&quot;/upload&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;</span><br><span class="line">    &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;读取文件：&lt;/legend&gt;</span><br><span class="line">        &lt;input type=&quot;file&quot; id=&quot;File&quot; name=&quot;name1&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; value=&quot;中断&quot; id=&quot;Abort&quot;&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">            &lt;lable&gt;读取进度：&lt;/lable&gt;</span><br><span class="line">            &lt;progress id=&quot;Progress&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">    &lt;/fieldset&gt;</span><br><span class="line">    &lt;div&gt;&lt;input type=&quot;submit&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">    var progress = document.getElementById(&apos;Progress&apos;);</span><br><span class="line">    var events = &#123;</span><br><span class="line">        load: function () &#123;</span><br><span class="line">            console.log(&apos;loaded&apos;);</span><br><span class="line">        &#125;,</span><br><span class="line">        progress: function (percent) &#123;</span><br><span class="line">            console.log(percent);</span><br><span class="line">            progress.value = percent;</span><br><span class="line">        &#125;,</span><br><span class="line">        success: function () &#123;</span><br><span class="line">            console.log(&apos;success&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    var loader;</span><br><span class="line"></span><br><span class="line">    // 选择好要上传的文件后触发onchange事件</span><br><span class="line">    document.getElementById(&apos;File&apos;).onchange = function (e) &#123;</span><br><span class="line">        var file = this.files[0];</span><br><span class="line">        loader = new FileLoader(file, events);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.getElementById(&apos;Abort&apos;).onclick = function () &#123;</span><br><span class="line">        loader.abort();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="相关："><a href="#相关：" class="headerlink" title="相关："></a>相关：</h4><p><a href="https://github.com/bgrins/filereader.js" target="_blank" rel="noopener">FileReader.js</a></p>
<p>#####关于上传：<br>AjaxFileUpload实现ajax文件上传。<br>react-fileupload<br>jQuery插件AjaxFileUpload实现ajax文件上传<br>jQuery File Upload支持多文件上传、取消、删除，上传前缩略图预览、列表显示图片大小，支持上传进度条显示。</p>
<h4 id="问题1：文件下载的实现方式，每种方式的区别与优劣。"><a href="#问题1：文件下载的实现方式，每种方式的区别与优劣。" class="headerlink" title="问题1：文件下载的实现方式，每种方式的区别与优劣。"></a>问题1：文件下载的实现方式，每种方式的区别与优劣。</h4><h4 id="问题2：HTTP协议下文件上传断点续传的实现。"><a href="#问题2：HTTP协议下文件上传断点续传的实现。" class="headerlink" title="问题2：HTTP协议下文件上传断点续传的实现。"></a>问题2：HTTP协议下文件上传断点续传的实现。</h4><p><a href="https://github.com/swingboy/upload" target="_blank" rel="noopener">github</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2017/10/12/js实现文件上传的几种方式/" data-id="ck9dloq060003wao75klqitq7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ajax和XMLHttpRequest" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/07/16/ajax和XMLHttpRequest/" class="article-date">
  <time datetime="2017-07-16T06:44:03.000Z" itemprop="datePublished">2017-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/16/ajax和XMLHttpRequest/">ajax和XMLHttpRequest</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Ajax and XMLHttpRequest</p>
<p>ajax是一种技术方案，但并不是一种新技术。它依赖的是现有的CSS/HTML/Javascript，而其中最核心的依赖是浏览器提供的XMLHttpRequest对象，是这个对象使得浏览器可以发出HTTP请求与接收HTTP响应。</p>
<p>XMLHttpRequest一开始只是微软浏览器提供的一个接口，后来各大浏览器纷纷效仿也提供了这个接口，再后来W3C对它进行了标准化，提出了XMLHttpRequest标准。XMLHttpRequest标准又分为Level 1和Level 2。</p>
<p>XMLHttpRequest Level 1主要存在以下缺点：<br>  ● 受同源策略的限制，不能发送跨域请求；<br>  ● 不能发送二进制文件（如图片、视频、音频等），只能发送纯文本数据；<br>  ● 在发送和获取数据的过程中，无法实时获取进度信息，只能判断是否完成；</p>
<p>Level 2对Level 1进行了改进，XMLHttpRequest Level 2中新增了以下功能：<br>  ● 可以发送跨域请求，在服务端允许的情况下；<br>  ● 支持发送和接收二进制数据；<br>  ● 新增formData对象，支持发送表单数据；<br>  ● 发送和获取数据时，可以获取进度信息；<br>  ● 可以设置请求的超时时间；</p>
<h6 id="下面细说XMLHttpRequest这个东西。"><a href="#下面细说XMLHttpRequest这个东西。" class="headerlink" title="下面细说XMLHttpRequest这个东西。"></a>下面细说XMLHttpRequest这个东西。</h6><p>先来一段使用XMLHttpRequest发送Ajax请求的简单示例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function ajax() &#123;</span><br><span class="line">    //构造表单数据</span><br><span class="line">    var formData = new FormData();</span><br><span class="line">    formData.append(&apos;aaa&apos;, &apos;bbb&apos;);</span><br><span class="line">    //创建xhr对象 </span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    //设置xhr请求的超时时间</span><br><span class="line">    xhr.timeout = 3000;</span><br><span class="line">    //设置响应返回的数据格式</span><br><span class="line">    xhr.responseType = &quot;&quot;;</span><br><span class="line">    //创建一个 post 请求，采用异步</span><br><span class="line">    xhr.open(&apos;POST&apos;, &apos;/xxx&apos;, true);</span><br><span class="line">    //注册相关事件回调处理函数</span><br><span class="line">    xhr.onload = function(e) &#123; </span><br><span class="line">        if(this.status == 200||this.status == 304)&#123;</span><br><span class="line">            console.log(this.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.ontimeout = function(e) &#123; &#125;;</span><br><span class="line">    xhr.onerror = function(e) &#123;  &#125;;</span><br><span class="line">    xhr.upload.onprogress = function(e) &#123;&#125;;</span><br><span class="line">    //发送数据</span><br><span class="line">    xhr.send(formData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="说说你平时可能忽略的知识点："><a href="#说说你平时可能忽略的知识点：" class="headerlink" title="说说你平时可能忽略的知识点："></a>说说你平时可能忽略的知识点：</h5><p>*如何设置request header<br>在发送Ajax请求时，我们可能需要设置一些请求头部信息。<br>比如content-type、connection、cookie、accept-xxx等。xhr提供了setRequestHeader来允许我们修改请求 header。<br>void setRequestHeader(DOMString header, DOMString value);</p>
<p>注意：<br>  ● 方法的第一个参数 header 大小写不敏感，即可以写成content-type，也可以写成Content-Type，甚至写成content-Type;<br>  ● Content-Type的默认值与具体发送的数据类型有关<br>  ● setRequestHeader必须在open()方法之后，send()方法之前调用，否则会抛错；<br>  ● setRequestHeader可以调用多次，最终的值不会采用覆盖override的方式，而是采用追加append的方式。</p>
<p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var client = new XMLHttpRequest();</span><br><span class="line">client.open(&apos;GET&apos;, &apos;xxx.action&apos;);</span><br><span class="line">client.setRequestHeader(&apos;X-Test&apos;, &apos;bbb&apos;);</span><br><span class="line">client.setRequestHeader(&apos;X-Test&apos;, &apos;aaa&apos;);</span><br><span class="line">//最终request header中&quot;X-Test&quot;为: bbb, aaa</span><br><span class="line">client.send();</span><br></pre></td></tr></table></figure></p>
<p>*如何获取response header<br>xhr提供了2个用来获取响应头部的方法：getAllResponseHeaders和getResponseHeader。前者是获取 response 中的所有header 字段，后者只是获取某个指定 header 字段的值。<br>另外，getResponseHeader(header)的header参数不区分大小写。<br>DOMString getAllResponseHeaders();<br>DOMString getResponseHeader(DOMString header);</p>
<p>注意：</p>
<ol>
<li>使用getResponseHeader()获取某个 header 的值时，浏览器抛错Refused to get unsafe header “XXX”<br>● 原因1：W3C的 xhr 标准中做了限制，规定客户端无法获取 response 中的 Set-Cookie、Set-Cookie2(启用)这2个字段，无论是同域还是跨域请求；<br>● 还有一些其他的限制内的字段<br>● 原因2：W3C 的 cors 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的response header字段只限于“simple response header”和“Access-Control-Expose-Headers” 。</li>
</ol>
<p>“simple response header”包括的 header字段有：Cache-Control,Content-Language,Content-Type,Expires,Last-Modified,Pragma;</p>
<p>“Access-Control-Expose-Headers”：首先得注意是”Access-Control-Expose-Headers”进行跨域请求时响应头部中的一个字段，对于同域请求，响应头部是没有这个字段的。这个字段中列举的 header 字段就是服务器允许暴露给客户端访问的字段。</p>
<p>所以getAllResponseHeaders()只能拿到限制以外（即被视为safe）的header字段，而不是全部字段；而调用getResponseHeader(header)方法时，header参数必须是限制以外的header字段，否则调用就会报Refused to get unsafe header的错误。</p>
<p>*如何指定xhr.response的数据类型<br>有些时候我们希望xhr.response返回的就是我们想要的数据类型。比如：响应返回的数据是纯JSON字符串，但我们期望最终通过xhr.response拿到的直接就是一个 js 对象，该怎么实现？</p>
<p>有2种方法可以实现，一个是level 1就提供的overrideMimeType()方法，另一个是level 2提供的xhr.responseType属性。</p>
<p>xhr.overrideMimeType()<br>overrideMimeType是xhr level 1就有的方法，所以浏览器兼容性良好。这个方法的作用就是用来重写response的content-type.</p>
<p>这样做有什么意义呢？比如：server 端给客户端返回了一份document或者是 xml文档，我们希望最终通过xhr.response拿到的就是一个DOM对象，那么就可以用xhr.overrideMimeType(‘text/xml; charset = utf-8’)来实现。</p>
<p>xhr.responseType</p>
<p>responseType是xhr level 2新增的属性，用来指定xhr.response的数据类型，目前还存在些兼容性问题那么responseType可以设置为哪些格式呢，如下：<br>值 xhr.response 数据类型 说明<br>“” String字符串 默认值(在不设置responseType时)<br>“text” String字符串<br>“document” Document对象 希望返回 XML 格式数据时使用<br>“json” javascript 对象 存在兼容性问题，IE10/IE11不支持<br>“blob” Blob对象<br>“arrayBuffer” ArrayBuffer对象   </p>
<p>下面是同样是获取一张图片的代码示例，相比xhr.overrideMimeType,用xhr.response来实现简单得多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);</span><br><span class="line">//可以将`xhr.responseType`设置为`&quot;blob&quot;`也可以设置为`&quot; arrayBuffer&quot;`</span><br><span class="line">//xhr.responseType = &apos;arrayBuffer&apos;;</span><br><span class="line">xhr.responseType = &apos;blob&apos;;</span><br><span class="line"></span><br><span class="line">xhr.onload = function(e) &#123;</span><br><span class="line">  if (this.status == 200) &#123;</span><br><span class="line">    var blob = this.response;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>虽然在xhr level 2中，2者是共同存在的。xhr.responseType功能更强大，xhr.overrideMimeType()能做到的xhr.responseType都能做到。所以我们现在完全可以摒弃使用xhr.overrideMimeType()了。</p>
<p>*如何获取response数据<br>xhr提供了3个属性来获取请求返回的数据，分别是：xhr.response、xhr.responseText、xhr.responseXML<br>  ● xhr.response<br>      ○ 默认值：空字符串””<br>      ○ 当请求完成时，此属性才有正确的值<br>      ○ 请求未完成时，此属性的值可能是””或者 null，具体与 xhr.responseType有关：当responseType为””或”text”时，值为””；responseType为其他值时，值为 null<br>  ● xhr.responseText<br>      ○ 默认值为空字符串””<br>      ○ 只有当 responseType 为”text”、””时，xhr对象上才有此属性，此时才能调用xhr.responseText，否则抛错<br>      ○ 只有当请求成功时，才能拿到正确值。以下2种情况下值都为空字符串””：请求未完成、请求失败<br>  ● xhr.responseXML<br>      ○ 默认值为 null<br>      ○ 只有当 responseType 为”text”、””、”document”时，xhr对象上才有此属性，此时才能调用xhr.responseXML，否则抛错<br>      ○ 只有当请求成功且返回数据被正确解析时，才能拿到正确值。以下3种情况下值都为null：请求未完成、请求失败、请求成功但返回数据无法被正确解析时</p>
<p>*如何追踪ajax请求的当前状态<br>在发一个ajax请求后，如果想追踪请求当前处于哪种状态，该怎么做呢？<br>用xhr.readyState这个属性即可追踪到。这个属性是只读属性，总共有5种可能值，分别对应xhr不同的不同阶段。每次xhr.readyState的值发生变化时，都会触发xhr.onreadystatechange事件，我们可以在这个事件中进行相关状态判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">  switch(xhr.readyState)&#123;</span><br><span class="line">    case 1://OPENED</span><br><span class="line">      //do something</span><br><span class="line">          break;</span><br><span class="line">    case 2://HEADERS_RECEIVED</span><br><span class="line">      //do something</span><br><span class="line">      break;</span><br><span class="line">    case 3://LOADING</span><br><span class="line">      //do something</span><br><span class="line">      break;</span><br><span class="line">    case 4://DONE</span><br><span class="line">      //do something</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 UNSENT (初始状态，未打开) 此时xhr对象被成功构造，open()方法还未被调用</span><br><span class="line">1 OPENED (已打开，未发送) open()方法已被成功调用，send()方法还未被调用。注意：只有xhr处于OPENED状态，才能调用xhr.setRequestHeader()和xhr.send(),否则会报错</span><br><span class="line">2 HEADERS_RECEIVED(已获取响应头) send()方法已经被调用, 响应头和响应状态已经返回</span><br><span class="line">3 LOADING (正在下载响应体) 响应体(response entity body)正在下载中，此状态下通过xhr.response可能已经有了响应数据</span><br><span class="line">4 DONE (整个数据传输过程结束) 整个数据传输过程结束，不管本次请求是成功还是失败</span><br></pre></td></tr></table></figure>
<p>*如何设置请求的超时时间<br>如果请求过了很久还没有成功，为了不会白白占用的网络资源，我们一般会主动终止请求。XMLHttpRequest提供了timeout属性来允许设置请求的超时时间。<br>xhr.timeout<br>单位：milliseconds 毫秒<br>默认值：0，即不设置超时<br>我们知道从请求开始 算起，若超过 timeout 时间请求还没有结束（包括成功/失败），则会触发ontimeout事件，主动结束该请求。</p>
<p>那么到底什么时候才算是请求开始 ？<br>——xhr.onloadstart事件触发的时候，也就是调用xhr.send()方法的时候。</p>
<p>因为xhr.open()只是创建了一个连接，但并没有真正开始数据的传输，而xhr.send()才是真正开始了数据的传输过程。只有调用了xhr.send()，才会触发xhr.onloadstart 。</p>
<p>那么什么时候才算是请求结束 ？<br>—— xhr.loadend事件触发的时候。</p>
<p>另外，还有2个需要注意：</p>
<ol>
<li>可以在 send()之后再设置此xhr.timeout，但计时起始点仍为调用xhr.send()方法的时刻。</li>
<li>当xhr为一个sync同步请求时，xhr.timeout必须置为0，否则会抛错。</li>
</ol>
<p>为什么会报错？ 继续</p>
<p>如何发一个同步请求<br>xhr默认发的是异步请求，也支持发同步请求。由xhr.open（）传入的async参数决定。<br>open(method, url [, async = true [, username = null [, password = null]]])<br>  ● method: 请求的方式，如GET/POST/HEADER等，这个参数不区分大小写<br>  ● url: 请求的地址，可以是相对地址如xxx.action，这个相对是相对于当前网页的url路径；也可以是绝对地址如<a href="http://www.example.com/xxx.action" target="_blank" rel="noopener">http://www.example.com/xxx.action</a><br>  ● async: 默认值为true，即为异步请求，若async=false，则为同步请求</p>
<p>同步请求和异步请求只是阻塞和非阻塞的区别?  其他什么事件触发、参数设置应该是一样的?<br>事实证明并不是。</p>
<p>当xhr为同步请求时，有如下限制：<br>  ● xhr.timeout必须为0<br>  ● xhr.withCredentials必须为 false (xhr2 就不用设置了)<br>  ● xhr.responseType必须为””（注意置为”text”也不允许）<br>  ●<br>若上面任何一个限制不满足，都会抛错，而对于异步请求，则没有这些参数设置上的限制。<br>之前说过页面中应该尽量避免使用sync同步请求，为什么呢？</p>
<p>因为我们无法设置请求超时时间（xhr.timeout为0，即不限时）。在不限制超时的情况下，有可能同步请求一直处于pending状态，服务端迟迟不返回响应，这样整个页面就会一直阻塞，无法响应用户的其他交互。<br>另外，标准中并没有提及同步请求时事件触发的限制。在 chrome中，当xhr为同步请求时，在xhr.readyState由2变成3时，并不会触发 onreadystatechange事件，xhr.upload.onprogress和 xhr.onprogress事件也不会触发。</p>
<p>???</p>
<p>如何获取上传、下载的进度<br>在上传或者下载比较大的文件时，实时显示当前的上传、下载进度是很普遍的需求。<br>我们可以通过onprogress事件来实时显示进度，默认情况下这个事件每50ms触发一次。<br>需要注意的是，上传过程和下载过程触发的是不同对象的onprogress事件：<br>  ● 上传触发的是xhr.upload对象的 onprogress事件<br>  ● 下载触发的是xhr对象的onprogress事件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xhr.onprogress = updateProgress;</span><br><span class="line"></span><br><span class="line">xhr.upload.onprogress = updateProgress;</span><br><span class="line">function updateProgress(event) &#123;</span><br><span class="line">    if (event.lengthComputable) &#123;</span><br><span class="line">      var completedPercent = event.loaded / event.total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发送什么类型的数据<br>void send(data);<br>xhr.send(data)的参数data可以是以下几种类型：<br>  ● ArrayBuffer<br>  ● Blob<br>  ● Document<br>  ● DOMString<br>  ● FormData<br>  ● null</p>
<p>如果是 GET/HEAD请求，send()方法一般不传参或传 null。不过即使真传入了参数，参数也最终被忽略，xhr.send(data)中的data会被置为 null.<br>xhr.send(data)中data参数的数据类型会影响请求头部content-type的默认值：<br>  ● 如果data是 Document 类型，同时也是HTML Document类型，则content-type默认值为text/html;charset=UTF-8;否则为application/xml;charset=UTF-8；<br>  ● 如果data是 DOMString 类型，content-type默认值为text/plain;charset=UTF-8；<br>  ● 如果data是 FormData 类型，content-type默认值为multipart/form-data; boundary=[xxx]<br>  ● 如果data是其他类型，则不会设置content-type的默认值<br>当然这些只是content-type的默认值，但如果用xhr.setRequestHeader()手动设置了中content-type的值，以上默认值就会被覆盖。</p>
<p>另外需要注意的是，若在断网状态下调用xhr.send(data)方法，则会抛错：Uncaught NetworkError: Failed to execute ‘send’ on ‘XMLHttpRequest’。一旦程序抛出错误，如果不 catch 就无法继续执行后面的代码，所以调用 xhr.send(data)方法时，应该用 try-catch捕捉错误。<br>try{<br>    xhr.send(data)<br>  }catch(e) {<br>    //XXX…<br>  };</p>
<p>*xhr.withCredentials与 CORS 什么关系<br>在发同域请求时，浏览器会将cookie自动加在request header中。但大家是否遇到过这样的场景：在发送跨域请求时，cookie并没有自动加在request header中。</p>
<p>造成这个问题的原因是：在CORS标准中做了规定，默认情况下，浏览器在发送跨域请求时，不能发送任何认证信息，如”cookies”和”HTTP authentication schemes”。除非xhr.withCredentials为true.</p>
<p>所以根本原因是cookies也是一种认证信息，在跨域请求中，client端必须手动设置xhr.withCredentials=true，且server端也必须允许request能携带认证信息（即response header中包含Access-Control-Allow-Credentials:true），这样浏览器才会自动将cookie加在request header中。<br>另外，要特别注意一点，一旦跨域request能够携带认证信息，server端一定不能将Access-Control-Allow-Origin设置为*，而必须设置为请求页面的域名。</p>
<p>xhr相关事件</p>
<p>xhr相关事件有很多，下面是XMLHttpRequest的部分实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface XMLHttpRequestEventTarget : EventTarget &#123;</span><br><span class="line">  // event handlers</span><br><span class="line">  attribute EventHandler onloadstart;</span><br><span class="line">  attribute EventHandler onprogress;</span><br><span class="line">  attribute EventHandler onabort;</span><br><span class="line">  attribute EventHandler onerror;</span><br><span class="line">  attribute EventHandler onload;</span><br><span class="line">  attribute EventHandler ontimeout;</span><br><span class="line">  attribute EventHandler onloadend;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">interface XMLHttpRequestUpload : XMLHttpRequestEventTarget &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">interface XMLHttpRequest : XMLHttpRequestEventTarget &#123;</span><br><span class="line">  // event handler</span><br><span class="line">  attribute EventHandler onreadystatechange;</span><br><span class="line">  readonly attribute XMLHttpRequestUpload upload;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h5 id="从代码中我们可以看出："><a href="#从代码中我们可以看出：" class="headerlink" title="从代码中我们可以看出："></a>从代码中我们可以看出：</h5><ol>
<li>XMLHttpRequestEventTarget接口定义了7个事件：<br> ○ onloadstart<br> ○ onprogress<br> ○ onabort<br> ○ ontimeout<br> ○ onerror<br> ○ onload<br> ○ onloadend</li>
<li>每一个XMLHttpRequest里面都有一个upload属性，而upload是一个XMLHttpRequestUpload对象</li>
<li>XMLHttpRequest和XMLHttpRequestUpload都继承了同一个XMLHttpRequestEventTarget接口，所以xhr和xhr.upload都有第一条列举的7个事件</li>
<li>onreadystatechange是XMLHttpRequest独有的事件</li>
</ol>
<p>所以这么一看就很清晰了：<br>xhr一共有8个相关事件：7个XMLHttpRequestEventTarget事件+1个独有的onreadystatechange事件；而xhr.upload只有7个XMLHttpRequestEventTarget事件。</p>
<p>事件触发条件：<br>onreadystatechange 每当xhr.readyState改变时触发；但xhr.readyState由非0值变为0时不触发。<br>onloadstart 调用xhr.send()方法后立即触发，若xhr.send()未被调用则不会触发此事件。<br>onprogress xhr.upload.onprogress在上传阶段(即xhr.send()之后，xhr.readystate=2之前)触发，每50ms触发一次；xhr.onprogress在下载阶段（即xhr.readystate=3时）触发，每50ms触发一次。<br>onload 当请求成功完成时触发，此时xhr.readystate=4<br>onloadend 当请求结束（包括请求成功和请求失败）时触发<br>onabort 当调用xhr.abort()后触发<br>ontimeout xhr.timeout不等于0，由请求开始即onloadstart开始算起，当到达xhr.timeout所设置时间请求还未结束即onloadend，则触发此事件。<br>onerror 在请求过程中，若发生Network error则会触发此事件（若发生Network error时，上传还没有结束，则会先触发xhr.upload.onerror，再触发xhr.onerror；若发生Network error时，上传已经结束，则只会触发xhr.onerror）。注意，只有发生了网络层级别的异常才会触发此事件，对于应用层级别的异常，如响应返回的xhr.statusCode是4xx时，并不属于Network error，所以不会触发onerror事件，而是会触发onload事件。</p>
<p>*在哪个xhr事件中注册成功回调？</p>
<p>从上面介绍的事件中，可以知道若xhr请求成功，就会触发xhr.onreadystatechange和xhr.onload两个事件。 那么我们到底要将成功回调注册在哪个事件中呢？<br>是xhr.onload事件，因为xhr.onreadystatechange是每次xhr.readyState变化时都会触发，而不是xhr.readyState=4时才触发。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = function () &#123;</span><br><span class="line">    //如果请求成功</span><br><span class="line">    if(xhr.status == 200)&#123;</span><br><span class="line">        //do successCallback</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的示例代码是很常见的写法：先判断http状态码是否是200，如果是，则认为请求是成功的，接着执行成功回调。这样的判断是有坑儿的，比如当返回的http状态码不是200，而是201时，请求虽然也是成功的，但并没有执行成功回调逻辑。所以更靠谱的判断方法应该是：当http状态码为2xx或304时才认为成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload = function () &#123;</span><br><span class="line">    //如果请求成功</span><br><span class="line">    if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</span><br><span class="line">        //do successCallback</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://swingboy.github.io/2017/07/16/ajax和XMLHttpRequest/" data-id="ck9dloq1l001gwao7vae4sbyo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/技术/">技术</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/随笔/">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/技术/" style="font-size: 20px;">技术</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">八月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">七月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/03/29/webpack原理/">webpack原理</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpackPlugin/">webpackPlugin</a>
          </li>
        
          <li>
            <a href="/2019/03/29/webpackLoader/">webpackLoader</a>
          </li>
        
          <li>
            <a href="/2019/03/29/about-tapable/">about tapable</a>
          </li>
        
          <li>
            <a href="/2018/11/23/聊聊前端安全/">聊聊前端安全</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 火柴人<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>